import{B as D,i as H,P as Y,j as q,v as w,a as P,g as J,S as C,k as K,l as j,m as E,n as M}from"./styles-BT9ucHwM.js";function T(t,i=!1){const s=t[0].index!==null,l=new Set(Object.keys(t[0].attributes)),o=new Set(Object.keys(t[0].morphAttributes)),n={},h={},m=t[0].morphTargetsRelative,r=new D;let c=0;for(let e=0;e<t.length;++e){const f=t[e];let g=0;if(s!==(f.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const a in f.attributes){if(!l.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+a+'" attribute exists among all geometries, or in none of them.'),null;n[a]===void 0&&(n[a]=[]),n[a].push(f.attributes[a]),g++}if(g!==l.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(m!==f.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const a in f.morphAttributes){if(!o.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;h[a]===void 0&&(h[a]=[]),h[a].push(f.morphAttributes[a])}if(i){let a;if(s)a=f.index.count;else if(f.attributes.position!==void 0)a=f.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;r.addGroup(c,a,e),c+=a}}if(s){let e=0;const f=[];for(let g=0;g<t.length;++g){const a=t[g].index;for(let p=0;p<a.count;++p)f.push(a.getX(p)+e);e+=t[g].attributes.position.count}r.setIndex(f)}for(const e in n){const f=U(n[e]);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;r.setAttribute(e,f)}for(const e in h){const f=h[e][0].length;if(f===0)break;r.morphAttributes=r.morphAttributes||{},r.morphAttributes[e]=[];for(let g=0;g<f;++g){const a=[];for(let d=0;d<h[e].length;++d)a.push(h[e][d][g]);const p=U(a);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;r.morphAttributes[e].push(p)}}return r}function U(t){let i,s,l,o=-1,n=0;for(let c=0;c<t.length;++c){const e=t[c];if(i===void 0&&(i=e.array.constructor),i!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(s===void 0&&(s=e.itemSize),s!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(l===void 0&&(l=e.normalized),l!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(o===-1&&(o=e.gpuType),o!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;n+=e.count*s}const h=new i(n),m=new H(h,s,l);let r=0;for(let c=0;c<t.length;++c){const e=t[c];if(e.isInterleavedBufferAttribute){const f=r/s;for(let g=0,a=e.count;g<a;g++)for(let p=0;p<s;p++){const d=e.getComponent(g,p);m.setComponent(g+f,p,d)}}else h.set(e.array,r);r+=e.count*s}return o!==void 0&&(m.gpuType=o),m}const S=w.state([]),b=w.state([]),k={floors:1},x=.3,B=.3,R=document.createElement("div");R.setAttribute("id","parameters");const z=new Y({title:"Parameters",container:R});z.addBinding(k,"floors",{min:1,max:12,step:1});const u=w.state({points:[],stories:[],columns:[],slabs:[],slabsByStorey:new Map,columnsByStorey:new Map}),A=[[0,0,4],[0,10,4],[18,10,4],[18,0,4],[0,0,4]],G=[[[0,0,0],[0,0,4]],[[0,10,0],[0,10,4]],[[18,10,0],[18,10,4]],[[18,0,0],[18,0,4]],[[6,0,0],[6,0,4]],[[6,10,0],[6,10,4]]];F(A);for(let t=0;t<G.length;t++)_(G[t]);const O=new q({color:16770764}),N=I(u.val.points,u.val.slabs,.3),Q=V(u.val.points,u.val.columns),W=T([N,Q]),v=w.state([new P(W,O)]);z.on("change",t=>Z());w.derive(()=>{S.val=u.val.points,b.val=[],b.val.push(...u.val.columns);for(let t=0;t<u.val.slabs.length;t++){const i=u.val.slabs[t];b.val.push(...L(i[0]))}v.val=[...v.rawVal]});document.body.append(J({structure:{nodes:S,elements:b},settingsObj:{nodes:!0,solidModel:!1},objects3D:v}),R);function I(t,i,s=.2){const l=[];for(let o=0;o<i.length;o++)for(let n=0;n<i[o].length;n++){const h=[];for(let e=0;e<i[o][n].length;e++){const f=i[o][n][e];h.push(t[f])}const m=$(h,x/2),r=new C;new K;for(let e=0;e<m.length;e++)e==0?r.moveTo(m[0][0],m[0][1]):r.lineTo(m[e][0],m[e][1]);const c=new j(r,{depth:s,bevelEnabled:!1});c.translate(0,0,m[0][2]),l.push(c)}return T(l)}function V(t,i){const s=[],l=new C;l.lineTo(0+x,0),l.lineTo(0+x,0+B),l.lineTo(0,0+B);for(let o=0;o<i.length;o++){const n=t[i[o][0]],m=t[i[o][1]][2]-n[2],r=new j(l,{depth:m,bevelEnabled:!1});r.translate(n[0]-x/2,n[1]-B/2,n[2]),s.push(r)}return T(s)}function _(t,i){const s=u.val.points.length;u.val.points.push(...t),u.val.columns.push([s,s+1])}function F(t,i){const s=u.val.points.length,l=[];for(let o=0;o<t.length;o++)u.val.points.push(t[o]),l.push(o+s);u.val.slabs.push([l])}function Z(){u.val.points=[],u.val.slabs=[],u.val.columns=[];const t=4;for(let o=0;o<k.floors;o++){const n=[],h=[],m=t*o;for(let r=0;r<A.length;r++)n.push([A[r][0],A[r][1],A[r][2]+m]);F(n);for(let r=0;r<G.length;r++){const c=G[r];h.push([[c[0][0],c[0][1],c[0][2]+m],[c[1][0],c[1][1],c[1][2]+m]])}for(let r=0;r<h.length;r++)_(h[r])}const i=I(u.val.points,u.val.slabs,.3),s=V(u.val.points,u.val.columns),l=T([i,s]);v.val=[new P(l,O)],S.val=u.val.points,b.val=[],b.val.push(...u.val.columns);for(let o=0;o<u.val.slabs.length;o++){const n=u.val.slabs[o];b.val.push(...L(n[0]))}v.val=[...v.rawVal]}function $(t,i=0){const s=[],l=[];for(let n=0;n<t.length;n++)l.push(new E(t[n][0],t[n][1]));let o=new H(new Float32Array([i,0,0]),3);for(let n=0;n<l.length-1;n++){let h=new E().subVectors(l[n-1<0?l.length-1:n-1],l[n]),m=new E().subVectors(l[n+1==l.length?0:n+1],l[n]),e=(m.angle()-h.angle())*.5,f=m.angle()+Math.PI*.5,g=Math.tan(e-Math.PI*.5),a=new M().set(1,0,0,0,-g,1,0,0,0,0,1,0,0,0,0,1),p=f,d=new M().set(Math.cos(p),-Math.sin(p),0,0,Math.sin(p),Math.cos(p),0,0,0,0,1,0,0,0,0,1),X=new M().set(1,0,0,l[n].x,0,1,0,l[n].y,0,0,1,0,0,0,0,1),y=o.clone();y.needsUpdate=!0,y.applyMatrix4(a),y.applyMatrix4(d),y.applyMatrix4(X),s.push([y.getX(0),y.getY(0),t[n][2]])}return s}function L(t){if(!t||t.length<2)return[];const i=[];for(let s=0;s<t.length-1;s++)i.push([t[s],t[s+1]]);return i}
