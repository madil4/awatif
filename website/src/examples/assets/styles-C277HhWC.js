var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n);
  new MutationObserver((n) => {
    for (const r of n) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: true, subtree: true });
  function t(n) {
    const r = {};
    return n.integrity && (r.integrity = n.integrity), n.referrerPolicy && (r.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? r.credentials = "include" : n.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
  }
  function i(n) {
    if (n.ep) return;
    n.ep = true;
    const r = t(n);
    fetch(n.href, r);
  }
})();
let sn = Object.getPrototypeOf, sr, ol, vs, ir, ru = { isConnected: 1 }, ff = 1e3, Vr, mf = {}, gf = sn(ru), ou = sn(sn), In, au = (s, e, t, i) => (s ?? (setTimeout(t, i), /* @__PURE__ */ new Set())).add(e), lu = (s, e, t) => {
  let i = vs;
  vs = e;
  try {
    return s(t);
  } catch (n) {
    return console.error(n), t;
  } finally {
    vs = i;
  }
}, Oo = (s) => s.filter((e) => {
  var _a2;
  return (_a2 = e._dom) == null ? void 0 : _a2.isConnected;
}), cu = (s) => Vr = au(Vr, s, () => {
  for (let e of Vr) e._bindings = Oo(e._bindings), e._listeners = Oo(e._listeners);
  Vr = In;
}, ff), Uo = { get val() {
  var _a2;
  return (_a2 = vs == null ? void 0 : vs._getters) == null ? void 0 : _a2.add(this), this.rawVal;
}, get oldVal() {
  var _a2;
  return (_a2 = vs == null ? void 0 : vs._getters) == null ? void 0 : _a2.add(this), this._oldVal;
}, set val(s) {
  var _a2;
  (_a2 = vs == null ? void 0 : vs._setters) == null ? void 0 : _a2.add(this), s !== this.rawVal && (this.rawVal = s, this._bindings.length + this._listeners.length ? (ol == null ? void 0 : ol.add(this), sr = au(sr, this, vf)) : this._oldVal = s);
} }, hu = (s) => ({ __proto__: Uo, rawVal: s, _oldVal: s, _bindings: [], _listeners: [] }), lr = (s, e) => {
  let t = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, i = { f: s }, n = ir;
  ir = [];
  let r = lu(s, t, e);
  r = (r ?? document).nodeType ? r : new Text(r);
  for (let o of t._getters) t._setters.has(o) || (cu(o), o._bindings.push(i));
  for (let o of ir) o._dom = r;
  return ir = n, i._dom = r;
}, cc = (s, e = hu(), t) => {
  let i = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, n = { f: s, s: e };
  n._dom = t ?? (ir == null ? void 0 : ir.push(n)) ?? ru, e.val = lu(s, i, e.rawVal);
  for (let r of i._getters) i._setters.has(r) || (cu(r), r._listeners.push(n));
  return e;
}, du = (s, ...e) => {
  for (let t of e.flat(1 / 0)) {
    let i = sn(t ?? 0), n = i === Uo ? lr(() => t.val) : i === ou ? lr(t) : t;
    n != In && s.append(n);
  }
  return s;
}, uu = (s, e, ...t) => {
  var _a2;
  let [i, ...n] = sn(t[0] ?? 0) === gf ? t : [{}, ...t], r = s ? document.createElementNS(s, e) : document.createElement(e);
  for (let [o, a] of Object.entries(i)) {
    let l = (f) => f ? Object.getOwnPropertyDescriptor(f, o) ?? l(sn(f)) : In, c = e + "," + o, h = mf[c] ?? (mf[c] = ((_a2 = l(sn(r))) == null ? void 0 : _a2.set) ?? 0), d = o.startsWith("on") ? (f, m) => {
      let _ = o.slice(2);
      r.removeEventListener(_, m), r.addEventListener(_, f);
    } : h ? h.bind(r) : r.setAttribute.bind(r, o), u = sn(a ?? 0);
    o.startsWith("on") || u === ou && (a = cc(a), u = Uo), u === Uo ? lr(() => (d(a.val, a._oldVal), r)) : d(a);
  }
  return du(r, n);
}, hh = (s) => ({ get: (e, t) => uu.bind(In, s, t) }), pu = (s, e) => e ? e !== s && s.replaceWith(e) : s.remove(), vf = () => {
  let s = 0, e = [...sr].filter((i) => i.rawVal !== i._oldVal);
  do {
    ol = /* @__PURE__ */ new Set();
    for (let i of new Set(e.flatMap((n) => n._listeners = Oo(n._listeners)))) cc(i.f, i.s, i._dom), i._dom = In;
  } while (++s < 100 && (e = [...ol]).length);
  let t = [...sr].filter((i) => i.rawVal !== i._oldVal);
  sr = In;
  for (let i of new Set(t.flatMap((n) => n._bindings = Oo(n._bindings)))) pu(i._dom, lr(i.f, i._dom)), i._dom = In;
  for (let i of t) i._oldVal = i.rawVal;
};
const De = { tags: new Proxy((s) => new Proxy(uu, hh(s)), hh()), hydrate: (s, e) => pu(s, lr(e, s)), add: du, state: hu, derive: cc };
/**
* @license
* Copyright 2010-2024 Three.js Authors
* SPDX-License-Identifier: MIT
*/
const hc = "169", _s = { ROTATE: 0, DOLLY: 1, PAN: 2 }, fs = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, _f = 0, dh = 1, bf = 2, fu = 1, xf = 2, Ii = 3, dn = 0, Kt = 1, Yt = 2, an = 0, bs = 1, uh = 2, ph = 3, fh = 4, wf = 5, An = 100, yf = 101, Sf = 102, Ef = 103, Mf = 104, Cf = 200, Tf = 201, Af = 202, Pf = 203, al = 204, ll = 205, Rf = 206, Df = 207, Lf = 208, If = 209, Nf = 210, kf = 211, Of = 212, Uf = 213, Ff = 214, cl = 0, hl = 1, dl = 2, Ts = 3, ul = 4, pl = 5, fl = 6, ml = 7, dc = 0, zf = 1, Bf = 2, ln = 0, Vf = 1, Hf = 2, Gf = 3, $f = 4, Wf = 5, Xf = 6, jf = 7, mu = 300, As = 301, Ps = 302, gl = 303, vl = 304, Qo = 306, _l = 1e3, Rn = 1001, bl = 1002, ci = 1003, Yf = 1004, Hr = 1005, gi = 1006, ua = 1007, Dn = 1008, Bi = 1009, gu = 1010, vu = 1011, cr = 1012, uc = 1013, On = 1014, Ni = 1015, Sr = 1016, pc = 1017, fc = 1018, Rs = 1020, _u = 35902, bu = 1021, xu = 1022, vi = 1023, wu = 1024, yu = 1025, xs = 1026, Ds = 1027, Su = 1028, mc = 1029, Eu = 1030, gc = 1031, vc = 1033, Mo = 33776, Co = 33777, To = 33778, Ao = 33779, xl = 35840, wl = 35841, yl = 35842, Sl = 35843, El = 36196, Ml = 37492, Cl = 37496, Tl = 37808, Al = 37809, Pl = 37810, Rl = 37811, Dl = 37812, Ll = 37813, Il = 37814, Nl = 37815, kl = 37816, Ol = 37817, Ul = 37818, Fl = 37819, zl = 37820, Bl = 37821, Po = 36492, Vl = 36494, Hl = 36495, Mu = 36283, Gl = 36284, $l = 36285, Wl = 36286, qf = 3200, Kf = 3201, Cu = 0, Zf = 1, tn = "", bi = "srgb", gn = "srgb-linear", _c = "display-p3", ea = "display-p3-linear", Fo = "linear", pt = "srgb", zo = "rec709", Bo = "p3", Yn = 7680, mh = 519, Jf = 512, Qf = 513, em = 514, Tu = 515, tm = 516, im = 517, nm = 518, sm = 519, Xl = 35044, gh = "300 es", ki = 2e3, Vo = 2001;
class Gn {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return false;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const r = n.indexOf(t);
      r !== -1 && n.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let r = 0, o = n.length; r < o; r++) n[r].call(this, e);
      e.target = null;
    }
  }
}
const Nt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], Ro = Math.PI / 180, jl = 180 / Math.PI;
function Ui() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Nt[s & 255] + Nt[s >> 8 & 255] + Nt[s >> 16 & 255] + Nt[s >> 24 & 255] + "-" + Nt[e & 255] + Nt[e >> 8 & 255] + "-" + Nt[e >> 16 & 15 | 64] + Nt[e >> 24 & 255] + "-" + Nt[t & 63 | 128] + Nt[t >> 8 & 255] + "-" + Nt[t >> 16 & 255] + Nt[t >> 24 & 255] + Nt[i & 255] + Nt[i >> 8 & 255] + Nt[i >> 16 & 255] + Nt[i >> 24 & 255]).toLowerCase();
}
function It(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function rm(s, e) {
  return (s % e + e) % e;
}
function pa(s, e, t) {
  return (1 - t) * s + t * e;
}
function wi(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ot(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const om = { DEG2RAD: Ro };
class re {
  constructor(e = 0, t = 0) {
    re.prototype.isVector2 = true, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(It(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
    return this.x = r * i - o * n + e.x, this.y = r * n + o * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Be {
  constructor(e, t, i, n, r, o, a, l, c) {
    Be.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, n, r, o, a, l, c);
  }
  set(e, t, i, n, r, o, a, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = n, h[2] = a, h[3] = t, h[4] = r, h[5] = l, h[6] = i, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, o = i[0], a = i[3], l = i[6], c = i[1], h = i[4], d = i[7], u = i[2], f = i[5], m = i[8], _ = n[0], g = n[3], v = n[6], y = n[1], x = n[4], S = n[7], A = n[2], R = n[5], C = n[8];
    return r[0] = o * _ + a * y + l * A, r[3] = o * g + a * x + l * R, r[6] = o * v + a * S + l * C, r[1] = c * _ + h * y + d * A, r[4] = c * g + h * x + d * R, r[7] = c * v + h * S + d * C, r[2] = u * _ + f * y + m * A, r[5] = u * g + f * x + m * R, r[8] = u * v + f * S + m * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8];
    return t * o * h - t * a * c - i * r * h + i * a * l + n * r * c - n * o * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], d = h * o - a * c, u = a * l - h * r, f = c * r - o * l, m = t * d + i * u + n * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / m;
    return e[0] = d * _, e[1] = (n * c - h * i) * _, e[2] = (a * i - n * o) * _, e[3] = u * _, e[4] = (h * t - n * l) * _, e[5] = (n * r - a * t) * _, e[6] = f * _, e[7] = (i * l - c * t) * _, e[8] = (o * t - i * r) * _, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, n, r, o, a) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -n * c, n * l, -n * (-c * o + l * a) + a + t, 0, 0, 1), this;
  }
  scale(e, t) {
    return this.premultiply(fa.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(fa.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(fa.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 9; n++) if (t[n] !== i[n]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const fa = new Be();
function Au(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return true;
  return false;
}
function Ho(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function am() {
  const s = Ho("canvas");
  return s.style.display = "block", s;
}
const vh = {};
function Do(s) {
  s in vh || (vh[s] = true, console.warn(s));
}
function lm(s, e, t) {
  return new Promise(function(i, n) {
    function r() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          n();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(r, t);
          break;
        default:
          i();
      }
    }
    setTimeout(r, t);
  });
}
function cm(s) {
  const e = s.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function hm(s) {
  const e = s.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const _h = new Be().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), bh = new Be().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), Vs = { [gn]: { transfer: Fo, primaries: zo, luminanceCoefficients: [0.2126, 0.7152, 0.0722], toReference: (s) => s, fromReference: (s) => s }, [bi]: { transfer: pt, primaries: zo, luminanceCoefficients: [0.2126, 0.7152, 0.0722], toReference: (s) => s.convertSRGBToLinear(), fromReference: (s) => s.convertLinearToSRGB() }, [ea]: { transfer: Fo, primaries: Bo, luminanceCoefficients: [0.2289, 0.6917, 0.0793], toReference: (s) => s.applyMatrix3(bh), fromReference: (s) => s.applyMatrix3(_h) }, [_c]: { transfer: pt, primaries: Bo, luminanceCoefficients: [0.2289, 0.6917, 0.0793], toReference: (s) => s.convertSRGBToLinear().applyMatrix3(bh), fromReference: (s) => s.applyMatrix3(_h).convertLinearToSRGB() } }, dm = /* @__PURE__ */ new Set([gn, ea]), it = { enabled: true, _workingColorSpace: gn, get workingColorSpace() {
  return this._workingColorSpace;
}, set workingColorSpace(s) {
  if (!dm.has(s)) throw new Error(`Unsupported working color space, "${s}".`);
  this._workingColorSpace = s;
}, convert: function(s, e, t) {
  if (this.enabled === false || e === t || !e || !t) return s;
  const i = Vs[e].toReference, n = Vs[t].fromReference;
  return n(i(s));
}, fromWorkingColorSpace: function(s, e) {
  return this.convert(s, this._workingColorSpace, e);
}, toWorkingColorSpace: function(s, e) {
  return this.convert(s, e, this._workingColorSpace);
}, getPrimaries: function(s) {
  return Vs[s].primaries;
}, getTransfer: function(s) {
  return s === tn ? Fo : Vs[s].transfer;
}, getLuminanceCoefficients: function(s, e = this._workingColorSpace) {
  return s.fromArray(Vs[e].luminanceCoefficients);
} };
function ws(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function ma(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let qn;
class um {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      qn === void 0 && (qn = Ho("canvas")), qn.width = e.width, qn.height = e.height;
      const i = qn.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = qn;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Ho("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const n = i.getImageData(0, 0, e.width, e.height), r = n.data;
      for (let o = 0; o < r.length; o++) r[o] = ws(r[o] / 255) * 255;
      return i.putImageData(n, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(ws(t[i] / 255) * 255) : t[i] = ws(t[i]);
      return { data: t, width: e.width, height: e.height };
    } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let pm = 0;
class Pu {
  constructor(e = null) {
    this.isSource = true, Object.defineProperty(this, "id", { value: pm++ }), this.uuid = Ui(), this.data = e, this.dataReady = true, this.version = 0;
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" }, n = this.data;
    if (n !== null) {
      let r;
      if (Array.isArray(n)) {
        r = [];
        for (let o = 0, a = n.length; o < a; o++) n[o].isDataTexture ? r.push(ga(n[o].image)) : r.push(ga(n[o]));
      } else r = ga(n);
      i.url = r;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function ga(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? um.getDataURL(s) : s.data ? { data: Array.from(s.data), width: s.width, height: s.height, type: s.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let fm = 0;
class Vt extends Gn {
  constructor(e = Vt.DEFAULT_IMAGE, t = Vt.DEFAULT_MAPPING, i = Rn, n = Rn, r = gi, o = Dn, a = vi, l = Bi, c = Vt.DEFAULT_ANISOTROPY, h = tn) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: fm++ }), this.uuid = Ui(), this.name = "", this.source = new Pu(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new re(0, 0), this.repeat = new re(1, 1), this.center = new re(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Be(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== mu) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
      case _l:
        e.x = e.x - Math.floor(e.x);
        break;
      case Rn:
        e.x = e.x < 0 ? 0 : 1;
        break;
      case bl:
        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
        break;
    }
    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
      case _l:
        e.y = e.y - Math.floor(e.y);
        break;
      case Rn:
        e.y = e.y < 0 ? 0 : 1;
        break;
      case bl:
        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
        break;
    }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === true && (this.version++, this.source.needsUpdate = true);
  }
  set needsPMREMUpdate(e) {
    e === true && this.pmremVersion++;
  }
}
Vt.DEFAULT_IMAGE = null;
Vt.DEFAULT_MAPPING = mu;
Vt.DEFAULT_ANISOTROPY = 1;
class xt {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    xt.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = n;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, n) {
    return this.x = e, this.y = t, this.z = i, this.w = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * t + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * t + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * t + o[7] * i + o[11] * n + o[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n, r;
    const l = e.elements, c = l[0], h = l[4], d = l[8], u = l[1], f = l[5], m = l[9], _ = l[2], g = l[6], v = l[10];
    if (Math.abs(h - u) < 0.01 && Math.abs(d - _) < 0.01 && Math.abs(m - g) < 0.01) {
      if (Math.abs(h + u) < 0.1 && Math.abs(d + _) < 0.1 && Math.abs(m + g) < 0.1 && Math.abs(c + f + v - 3) < 0.1) return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const x = (c + 1) / 2, S = (f + 1) / 2, A = (v + 1) / 2, R = (h + u) / 4, C = (d + _) / 4, P = (m + g) / 4;
      return x > S && x > A ? x < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(x), n = R / i, r = C / i) : S > A ? S < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(S), i = R / n, r = P / n) : A < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(A), i = C / r, n = P / r), this.set(i, n, r, t), this;
    }
    let y = Math.sqrt((g - m) * (g - m) + (d - _) * (d - _) + (u - h) * (u - h));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (g - m) / y, this.y = (d - _) / y, this.z = (u - h) / y, this.w = Math.acos((c + f + v - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class mm extends Gn {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new xt(0, 0, e, t), this.scissorTest = false, this.viewport = new xt(0, 0, e, t);
    const n = { width: e, height: t, depth: 1 };
    i = Object.assign({ generateMipmaps: false, internalFormat: null, minFilter: gi, depthBuffer: true, stencilBuffer: false, resolveDepthBuffer: true, resolveStencilBuffer: true, depthTexture: null, samples: 0, count: 1 }, i);
    const r = new Vt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    r.flipY = false, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
    const o = i.count;
    for (let a = 0; a < o; a++) this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = true;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let n = 0, r = this.textures.length; n < r; n++) this.textures[n].image.width = e, this.textures[n].image.height = t, this.textures[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, n = e.textures.length; i < n; i++) this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = true;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Pu(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Un extends mm {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), this.isWebGLRenderTarget = true;
  }
}
class Ru extends Vt {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = ci, this.minFilter = ci, this.wrapR = Rn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class gm extends Vt {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = ci, this.minFilter = ci, this.wrapR = Rn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class un {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = n;
  }
  static slerpFlat(e, t, i, n, r, o, a) {
    let l = i[n + 0], c = i[n + 1], h = i[n + 2], d = i[n + 3];
    const u = r[o + 0], f = r[o + 1], m = r[o + 2], _ = r[o + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = d;
      return;
    }
    if (a === 1) {
      e[t + 0] = u, e[t + 1] = f, e[t + 2] = m, e[t + 3] = _;
      return;
    }
    if (d !== _ || l !== u || c !== f || h !== m) {
      let g = 1 - a;
      const v = l * u + c * f + h * m + d * _, y = v >= 0 ? 1 : -1, x = 1 - v * v;
      if (x > Number.EPSILON) {
        const A = Math.sqrt(x), R = Math.atan2(A, v * y);
        g = Math.sin(g * R) / A, a = Math.sin(a * R) / A;
      }
      const S = a * y;
      if (l = l * g + u * S, c = c * g + f * S, h = h * g + m * S, d = d * g + _ * S, g === 1 - a) {
        const A = 1 / Math.sqrt(l * l + c * c + h * h + d * d);
        l *= A, c *= A, h *= A, d *= A;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = d;
  }
  static multiplyQuaternionsFlat(e, t, i, n, r, o) {
    const a = i[n], l = i[n + 1], c = i[n + 2], h = i[n + 3], d = r[o], u = r[o + 1], f = r[o + 2], m = r[o + 3];
    return e[t] = a * m + h * d + l * f - c * u, e[t + 1] = l * m + h * u + c * d - a * f, e[t + 2] = c * m + h * f + a * u - l * d, e[t + 3] = h * m - a * d - l * u - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = true) {
    const i = e._x, n = e._y, r = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(i / 2), h = a(n / 2), d = a(r / 2), u = l(i / 2), f = l(n / 2), m = l(r / 2);
    switch (o) {
      case "XYZ":
        this._x = u * h * d + c * f * m, this._y = c * f * d - u * h * m, this._z = c * h * m + u * f * d, this._w = c * h * d - u * f * m;
        break;
      case "YXZ":
        this._x = u * h * d + c * f * m, this._y = c * f * d - u * h * m, this._z = c * h * m - u * f * d, this._w = c * h * d + u * f * m;
        break;
      case "ZXY":
        this._x = u * h * d - c * f * m, this._y = c * f * d + u * h * m, this._z = c * h * m + u * f * d, this._w = c * h * d - u * f * m;
        break;
      case "ZYX":
        this._x = u * h * d - c * f * m, this._y = c * f * d + u * h * m, this._z = c * h * m - u * f * d, this._w = c * h * d + u * f * m;
        break;
      case "YZX":
        this._x = u * h * d + c * f * m, this._y = c * f * d + u * h * m, this._z = c * h * m - u * f * d, this._w = c * h * d - u * f * m;
        break;
      case "XZY":
        this._x = u * h * d - c * f * m, this._y = c * f * d - u * h * m, this._z = c * h * m + u * f * d, this._w = c * h * d + u * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === true && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, n = Math.sin(i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], n = t[4], r = t[8], o = t[1], a = t[5], l = t[9], c = t[2], h = t[6], d = t[10], u = i + a + d;
    if (u > 0) {
      const f = 0.5 / Math.sqrt(u + 1);
      this._w = 0.25 / f, this._x = (h - l) * f, this._y = (r - c) * f, this._z = (o - n) * f;
    } else if (i > a && i > d) {
      const f = 2 * Math.sqrt(1 + i - a - d);
      this._w = (h - l) / f, this._x = 0.25 * f, this._y = (n + o) / f, this._z = (r + c) / f;
    } else if (a > d) {
      const f = 2 * Math.sqrt(1 + a - i - d);
      this._w = (r - c) / f, this._x = (n + o) / f, this._y = 0.25 * f, this._z = (l + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + d - i - a);
      this._w = (o - n) / f, this._x = (r + c) / f, this._y = (l + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(It(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, n = e._y, r = e._z, o = e._w, a = t._x, l = t._y, c = t._z, h = t._w;
    return this._x = i * h + o * a + n * c - r * l, this._y = n * h + o * l + r * a - i * c, this._z = r * h + o * c + i * l - n * a, this._w = o * h - i * a - n * l - r * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, n = this._y, r = this._z, o = this._w;
    let a = o * e._w + i * e._x + n * e._y + r * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * o + t * this._w, this._x = f * i + t * this._x, this._y = f * n + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(l), h = Math.atan2(c, a), d = Math.sin((1 - t) * h) / c, u = Math.sin(t * h) / c;
    return this._w = o * d + this._w * u, this._x = i * d + this._x * u, this._y = n * d + this._y * u, this._z = r * d + this._z * u, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), r = Math.sqrt(i);
    return this.set(n * Math.sin(e), n * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class I {
  constructor(e = 0, t = 0, i = 0) {
    I.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(xh.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(xh.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, n = this.z, r = e.x, o = e.y, a = e.z, l = e.w, c = 2 * (o * n - a * i), h = 2 * (a * t - r * n), d = 2 * (r * i - o * t);
    return this.x = t + l * c + o * d - a * h, this.y = i + l * h + a * c - r * d, this.z = n + l * d + r * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, n = e.y, r = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = n * l - r * a, this.y = r * o - i * l, this.z = i * a - n * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return va.copy(this).projectOnVector(e), this.sub(va);
  }
  reflect(e) {
    return this.sub(va.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(It(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, i = Math.sqrt(1 - t * t);
    return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const va = new I(), xh = new un();
class Er {
  constructor(e = new I(1 / 0, 1 / 0, 1 / 0), t = new I(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(pi.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(pi.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = pi.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = false) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = false) {
    e.updateWorldMatrix(false, false);
    const i = e.geometry;
    if (i !== void 0) {
      const r = i.getAttribute("position");
      if (t === true && r !== void 0 && e.isInstancedMesh !== true) for (let o = 0, a = r.count; o < a; o++) e.isMesh === true ? e.getVertexPosition(o, pi) : pi.fromBufferAttribute(r, o), pi.applyMatrix4(e.matrixWorld), this.expandByPoint(pi);
      else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Gr.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Gr.copy(i.boundingBox)), Gr.applyMatrix4(e.matrixWorld), this.union(Gr);
    }
    const n = e.children;
    for (let r = 0, o = n.length; r < o; r++) this.expandByObject(n[r], t);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, pi), pi.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return false;
    this.getCenter(Hs), $r.subVectors(this.max, Hs), Kn.subVectors(e.a, Hs), Zn.subVectors(e.b, Hs), Jn.subVectors(e.c, Hs), Wi.subVectors(Zn, Kn), Xi.subVectors(Jn, Zn), bn.subVectors(Kn, Jn);
    let t = [0, -Wi.z, Wi.y, 0, -Xi.z, Xi.y, 0, -bn.z, bn.y, Wi.z, 0, -Wi.x, Xi.z, 0, -Xi.x, bn.z, 0, -bn.x, -Wi.y, Wi.x, 0, -Xi.y, Xi.x, 0, -bn.y, bn.x, 0];
    return !_a(t, Kn, Zn, Jn, $r) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !_a(t, Kn, Zn, Jn, $r)) ? false : (Wr.crossVectors(Wi, Xi), t = [Wr.x, Wr.y, Wr.z], _a(t, Kn, Zn, Jn, $r));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, pi).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(pi).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ti[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ti[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ti[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ti[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ti[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ti[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ti[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ti[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ti), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ti = [new I(), new I(), new I(), new I(), new I(), new I(), new I(), new I()], pi = new I(), Gr = new Er(), Kn = new I(), Zn = new I(), Jn = new I(), Wi = new I(), Xi = new I(), bn = new I(), Hs = new I(), $r = new I(), Wr = new I(), xn = new I();
function _a(s, e, t, i, n) {
  for (let r = 0, o = s.length - 3; r <= o; r += 3) {
    xn.fromArray(s, r);
    const a = n.x * Math.abs(xn.x) + n.y * Math.abs(xn.y) + n.z * Math.abs(xn.z), l = e.dot(xn), c = t.dot(xn), h = i.dot(xn);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return false;
  }
  return true;
}
const vm = new Er(), Gs = new I(), ba = new I();
class Mr {
  constructor(e = new I(), t = -1) {
    this.isSphere = true, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : vm.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let r = 0, o = e.length; r < o; r++) n = Math.max(n, i.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
    Gs.subVectors(e, this.center);
    const t = Gs.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(Gs, n / i), this.radius += n;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (ba.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Gs.copy(e.center).add(ba)), this.expandByPoint(Gs.copy(e.center).sub(ba))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ai = new I(), xa = new I(), Xr = new I(), ji = new I(), wa = new I(), jr = new I(), ya = new I();
class Cr {
  constructor(e = new I(), t = new I(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ai)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ai.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Ai.copy(this.origin).addScaledVector(this.direction, t), Ai.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    xa.copy(e).add(t).multiplyScalar(0.5), Xr.copy(t).sub(e).normalize(), ji.copy(this.origin).sub(xa);
    const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(Xr), a = ji.dot(this.direction), l = -ji.dot(Xr), c = ji.lengthSq(), h = Math.abs(1 - o * o);
    let d, u, f, m;
    if (h > 0) if (d = o * l - a, u = o * a - l, m = r * h, d >= 0) if (u >= -m) if (u <= m) {
      const _ = 1 / h;
      d *= _, u *= _, f = d * (d + o * u + 2 * a) + u * (o * d + u + 2 * l) + c;
    } else u = r, d = Math.max(0, -(o * u + a)), f = -d * d + u * (u + 2 * l) + c;
    else u = -r, d = Math.max(0, -(o * u + a)), f = -d * d + u * (u + 2 * l) + c;
    else u <= -m ? (d = Math.max(0, -(-o * r + a)), u = d > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -d * d + u * (u + 2 * l) + c) : u <= m ? (d = 0, u = Math.min(Math.max(-r, -l), r), f = u * (u + 2 * l) + c) : (d = Math.max(0, -(o * r + a)), u = d > 0 ? r : Math.min(Math.max(-r, -l), r), f = -d * d + u * (u + 2 * l) + c);
    else u = o > 0 ? -r : r, d = Math.max(0, -(o * u + a)), f = -d * d + u * (u + 2 * l) + c;
    return i && i.copy(this.origin).addScaledVector(this.direction, d), n && n.copy(xa).addScaledVector(Xr, u), f;
  }
  intersectSphere(e, t) {
    Ai.subVectors(e.center, this.origin);
    const i = Ai.dot(this.direction), n = Ai.dot(Ai) - i * i, r = e.radius * e.radius;
    if (n > r) return null;
    const o = Math.sqrt(r - n), a = i - o, l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, n, r, o, a, l;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, u = this.origin;
    return c >= 0 ? (i = (e.min.x - u.x) * c, n = (e.max.x - u.x) * c) : (i = (e.max.x - u.x) * c, n = (e.min.x - u.x) * c), h >= 0 ? (r = (e.min.y - u.y) * h, o = (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h, o = (e.min.y - u.y) * h), i > o || r > n || ((r > i || isNaN(i)) && (i = r), (o < n || isNaN(n)) && (n = o), d >= 0 ? (a = (e.min.z - u.z) * d, l = (e.max.z - u.z) * d) : (a = (e.max.z - u.z) * d, l = (e.min.z - u.z) * d), i > l || a > n) || ((a > i || i !== i) && (i = a), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ai) !== null;
  }
  intersectTriangle(e, t, i, n, r) {
    wa.subVectors(t, e), jr.subVectors(i, e), ya.crossVectors(wa, jr);
    let o = this.direction.dot(ya), a;
    if (o > 0) {
      if (n) return null;
      a = 1;
    } else if (o < 0) a = -1, o = -o;
    else return null;
    ji.subVectors(this.origin, e);
    const l = a * this.direction.dot(jr.crossVectors(ji, jr));
    if (l < 0) return null;
    const c = a * this.direction.dot(wa.cross(ji));
    if (c < 0 || l + c > o) return null;
    const h = -a * ji.dot(ya);
    return h < 0 ? null : this.at(h / o, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class rt {
  constructor(e, t, i, n, r, o, a, l, c, h, d, u, f, m, _, g) {
    rt.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, n, r, o, a, l, c, h, d, u, f, m, _, g);
  }
  set(e, t, i, n, r, o, a, l, c, h, d, u, f, m, _, g) {
    const v = this.elements;
    return v[0] = e, v[4] = t, v[8] = i, v[12] = n, v[1] = r, v[5] = o, v[9] = a, v[13] = l, v[2] = c, v[6] = h, v[10] = d, v[14] = u, v[3] = f, v[7] = m, v[11] = _, v[15] = g, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new rt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, n = 1 / Qn.setFromMatrixColumn(e, 0).length(), r = 1 / Qn.setFromMatrixColumn(e, 1).length(), o = 1 / Qn.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(n), c = Math.sin(n), h = Math.cos(r), d = Math.sin(r);
    if (e.order === "XYZ") {
      const u = o * h, f = o * d, m = a * h, _ = a * d;
      t[0] = l * h, t[4] = -l * d, t[8] = c, t[1] = f + m * c, t[5] = u - _ * c, t[9] = -a * l, t[2] = _ - u * c, t[6] = m + f * c, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const u = l * h, f = l * d, m = c * h, _ = c * d;
      t[0] = u + _ * a, t[4] = m * a - f, t[8] = o * c, t[1] = o * d, t[5] = o * h, t[9] = -a, t[2] = f * a - m, t[6] = _ + u * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const u = l * h, f = l * d, m = c * h, _ = c * d;
      t[0] = u - _ * a, t[4] = -o * d, t[8] = m + f * a, t[1] = f + m * a, t[5] = o * h, t[9] = _ - u * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const u = o * h, f = o * d, m = a * h, _ = a * d;
      t[0] = l * h, t[4] = m * c - f, t[8] = u * c + _, t[1] = l * d, t[5] = _ * c + u, t[9] = f * c - m, t[2] = -c, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const u = o * l, f = o * c, m = a * l, _ = a * c;
      t[0] = l * h, t[4] = _ - u * d, t[8] = m * d + f, t[1] = d, t[5] = o * h, t[9] = -a * h, t[2] = -c * h, t[6] = f * d + m, t[10] = u - _ * d;
    } else if (e.order === "XZY") {
      const u = o * l, f = o * c, m = a * l, _ = a * c;
      t[0] = l * h, t[4] = -d, t[8] = c * h, t[1] = u * d + _, t[5] = o * h, t[9] = f * d - m, t[2] = m * d - f, t[6] = a * h, t[10] = _ * d + u;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_m, e, bm);
  }
  lookAt(e, t, i) {
    const n = this.elements;
    return ei.subVectors(e, t), ei.lengthSq() === 0 && (ei.z = 1), ei.normalize(), Yi.crossVectors(i, ei), Yi.lengthSq() === 0 && (Math.abs(i.z) === 1 ? ei.x += 1e-4 : ei.z += 1e-4, ei.normalize(), Yi.crossVectors(i, ei)), Yi.normalize(), Yr.crossVectors(ei, Yi), n[0] = Yi.x, n[4] = Yr.x, n[8] = ei.x, n[1] = Yi.y, n[5] = Yr.y, n[9] = ei.y, n[2] = Yi.z, n[6] = Yr.z, n[10] = ei.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, o = i[0], a = i[4], l = i[8], c = i[12], h = i[1], d = i[5], u = i[9], f = i[13], m = i[2], _ = i[6], g = i[10], v = i[14], y = i[3], x = i[7], S = i[11], A = i[15], R = n[0], C = n[4], P = n[8], z = n[12], w = n[1], E = n[5], N = n[9], k = n[13], V = n[2], q = n[6], G = n[10], ee = n[14], O = n[3], Q = n[7], X = n[11], K = n[15];
    return r[0] = o * R + a * w + l * V + c * O, r[4] = o * C + a * E + l * q + c * Q, r[8] = o * P + a * N + l * G + c * X, r[12] = o * z + a * k + l * ee + c * K, r[1] = h * R + d * w + u * V + f * O, r[5] = h * C + d * E + u * q + f * Q, r[9] = h * P + d * N + u * G + f * X, r[13] = h * z + d * k + u * ee + f * K, r[2] = m * R + _ * w + g * V + v * O, r[6] = m * C + _ * E + g * q + v * Q, r[10] = m * P + _ * N + g * G + v * X, r[14] = m * z + _ * k + g * ee + v * K, r[3] = y * R + x * w + S * V + A * O, r[7] = y * C + x * E + S * q + A * Q, r[11] = y * P + x * N + S * G + A * X, r[15] = y * z + x * k + S * ee + A * K, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], o = e[1], a = e[5], l = e[9], c = e[13], h = e[2], d = e[6], u = e[10], f = e[14], m = e[3], _ = e[7], g = e[11], v = e[15];
    return m * (+r * l * d - n * c * d - r * a * u + i * c * u + n * a * f - i * l * f) + _ * (+t * l * f - t * c * u + r * o * u - n * o * f + n * c * h - r * l * h) + g * (+t * c * d - t * a * f - r * o * d + i * o * f + r * a * h - i * c * h) + v * (-n * a * h - t * l * d + t * a * u + n * o * d - i * o * u + i * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], d = e[9], u = e[10], f = e[11], m = e[12], _ = e[13], g = e[14], v = e[15], y = d * g * c - _ * u * c + _ * l * f - a * g * f - d * l * v + a * u * v, x = m * u * c - h * g * c - m * l * f + o * g * f + h * l * v - o * u * v, S = h * _ * c - m * d * c + m * a * f - o * _ * f - h * a * v + o * d * v, A = m * d * l - h * _ * l - m * a * u + o * _ * u + h * a * g - o * d * g, R = t * y + i * x + n * S + r * A;
    if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / R;
    return e[0] = y * C, e[1] = (_ * u * r - d * g * r - _ * n * f + i * g * f + d * n * v - i * u * v) * C, e[2] = (a * g * r - _ * l * r + _ * n * c - i * g * c - a * n * v + i * l * v) * C, e[3] = (d * l * r - a * u * r - d * n * c + i * u * c + a * n * f - i * l * f) * C, e[4] = x * C, e[5] = (h * g * r - m * u * r + m * n * f - t * g * f - h * n * v + t * u * v) * C, e[6] = (m * l * r - o * g * r - m * n * c + t * g * c + o * n * v - t * l * v) * C, e[7] = (o * u * r - h * l * r + h * n * c - t * u * c - o * n * f + t * l * f) * C, e[8] = S * C, e[9] = (m * d * r - h * _ * r - m * i * f + t * _ * f + h * i * v - t * d * v) * C, e[10] = (o * _ * r - m * a * r + m * i * c - t * _ * c - o * i * v + t * a * v) * C, e[11] = (h * a * r - o * d * r - h * i * c + t * d * c + o * i * f - t * a * f) * C, e[12] = A * C, e[13] = (h * _ * n - m * d * n + m * i * u - t * _ * u - h * i * g + t * d * g) * C, e[14] = (m * a * n - o * _ * n - m * i * l + t * _ * l + o * i * g - t * a * g) * C, e[15] = (o * d * n - h * a * n + h * i * l - t * d * l - o * i * u + t * a * u) * C, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = 1 - i, o = e.x, a = e.y, l = e.z, c = r * o, h = r * a;
    return this.set(c * o + i, c * a - n * l, c * l + n * a, 0, c * a + n * l, h * a + i, h * l - n * o, 0, c * l - n * a, h * l + n * o, r * l * l + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, n, r, o) {
    return this.set(1, i, r, 0, e, 1, o, 0, t, n, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const n = this.elements, r = t._x, o = t._y, a = t._z, l = t._w, c = r + r, h = o + o, d = a + a, u = r * c, f = r * h, m = r * d, _ = o * h, g = o * d, v = a * d, y = l * c, x = l * h, S = l * d, A = i.x, R = i.y, C = i.z;
    return n[0] = (1 - (_ + v)) * A, n[1] = (f + S) * A, n[2] = (m - x) * A, n[3] = 0, n[4] = (f - S) * R, n[5] = (1 - (u + v)) * R, n[6] = (g + y) * R, n[7] = 0, n[8] = (m + x) * C, n[9] = (g - y) * C, n[10] = (1 - (u + _)) * C, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, i) {
    const n = this.elements;
    let r = Qn.set(n[0], n[1], n[2]).length();
    const o = Qn.set(n[4], n[5], n[6]).length(), a = Qn.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], fi.copy(this);
    const c = 1 / r, h = 1 / o, d = 1 / a;
    return fi.elements[0] *= c, fi.elements[1] *= c, fi.elements[2] *= c, fi.elements[4] *= h, fi.elements[5] *= h, fi.elements[6] *= h, fi.elements[8] *= d, fi.elements[9] *= d, fi.elements[10] *= d, t.setFromRotationMatrix(fi), i.x = r, i.y = o, i.z = a, this;
  }
  makePerspective(e, t, i, n, r, o, a = ki) {
    const l = this.elements, c = 2 * r / (t - e), h = 2 * r / (i - n), d = (t + e) / (t - e), u = (i + n) / (i - n);
    let f, m;
    if (a === ki) f = -(o + r) / (o - r), m = -2 * o * r / (o - r);
    else if (a === Vo) f = -o / (o - r), m = -o * r / (o - r);
    else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = h, l[9] = u, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, i, n, r, o, a = ki) {
    const l = this.elements, c = 1 / (t - e), h = 1 / (i - n), d = 1 / (o - r), u = (t + e) * c, f = (i + n) * h;
    let m, _;
    if (a === ki) m = (o + r) * d, _ = -2 * d;
    else if (a === Vo) m = r * d, _ = -1 * d;
    else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -u, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const Qn = new I(), fi = new rt(), _m = new I(0, 0, 0), bm = new I(1, 1, 1), Yi = new I(), Yr = new I(), ei = new I(), wh = new rt(), yh = new un();
class di {
  constructor(e = 0, t = 0, i = 0, n = di.DEFAULT_ORDER) {
    this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = true) {
    const n = e.elements, r = n[0], o = n[4], a = n[8], l = n[1], c = n[5], h = n[9], d = n[2], u = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(It(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(u, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-It(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(It(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-It(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(u, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(It(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(a, f));
        break;
      case "XZY":
        this._z = Math.asin(-It(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(u, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === true && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return wh.makeRotationFromQuaternion(e), this.setFromRotationMatrix(wh, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return yh.setFromEuler(this), this.setFromQuaternion(yh, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
di.DEFAULT_ORDER = "XYZ";
class bc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let xm = 0;
const Sh = new I(), es = new un(), Pi = new rt(), qr = new I(), $s = new I(), wm = new I(), ym = new un(), Eh = new I(1, 0, 0), Mh = new I(0, 1, 0), Ch = new I(0, 0, 1), Th = { type: "added" }, Sm = { type: "removed" }, ts = { type: "childadded", child: null }, Sa = { type: "childremoved", child: null };
class yt extends Gn {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: xm++ }), this.uuid = Ui(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = yt.DEFAULT_UP.clone();
    const e = new I(), t = new di(), i = new un(), n = new I(1, 1, 1);
    function r() {
      i.setFromEuler(t, false);
    }
    function o() {
      t.setFromQuaternion(i, void 0, false);
    }
    t._onChange(r), i._onChange(o), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e }, rotation: { configurable: true, enumerable: true, value: t }, quaternion: { configurable: true, enumerable: true, value: i }, scale: { configurable: true, enumerable: true, value: n }, modelViewMatrix: { value: new rt() }, normalMatrix: { value: new Be() } }), this.matrix = new rt(), this.matrixWorld = new rt(), this.matrixAutoUpdate = yt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new bc(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, true);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return es.setFromAxisAngle(e, t), this.quaternion.multiply(es), this;
  }
  rotateOnWorldAxis(e, t) {
    return es.setFromAxisAngle(e, t), this.quaternion.premultiply(es), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Eh, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Mh, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Ch, e);
  }
  translateOnAxis(e, t) {
    return Sh.copy(e).applyQuaternion(this.quaternion), this.position.add(Sh.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Eh, e);
  }
  translateY(e) {
    return this.translateOnAxis(Mh, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Ch, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(Pi.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? qr.copy(e) : qr.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(true, false), $s.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Pi.lookAt($s, qr, this.up) : Pi.lookAt(qr, $s, this.up), this.quaternion.setFromRotationMatrix(Pi), n && (Pi.extractRotation(n.matrixWorld), es.setFromRotationMatrix(Pi), this.quaternion.premultiply(es.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Th), ts.child = e, this.dispatchEvent(ts), ts.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Sm), Sa.child = e, this.dispatchEvent(Sa), Sa.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(true, false), Pi.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), Pi.multiply(e.parent.matrixWorld)), e.applyMatrix4(Pi), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(Th), ts.child = e, this.dispatchEvent(ts), ts.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const n = this.children;
    for (let r = 0, o = n.length; r < o; r++) n[r].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose($s, e, wm), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose($s, ym, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === false) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, e = true);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === true) {
      const n = this.children;
      for (let r = 0, o = n.length; r < o; r++) n[r].updateWorldMatrix(false, true);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === true && (n.castShadow = true), this.receiveShadow === true && (n.receiveShadow = true), this.visible === false && (n.visible = false), this.frustumCulled === false && (n.frustumCulled = false), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === false && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((a) => ({ boxInitialized: a.boxInitialized, boxMin: a.box.min.toArray(), boxMax: a.box.max.toArray(), sphereInitialized: a.sphereInitialized, sphereRadius: a.sphere.radius, sphereCenter: a.sphere.center.toArray() })), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (n.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (n.boundingSphere = { center: n.boundingSphere.center.toArray(), radius: n.boundingSphere.radius }), this.boundingBox !== null && (n.boundingBox = { min: n.boundingBox.min.toArray(), max: n.boundingBox.max.toArray() }));
    function r(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = r(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l)) for (let c = 0, h = l.length; c < h; c++) {
          const d = l[c];
          r(e.shapes, d);
        }
        else r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
      const a = [];
      for (let l = 0, c = this.material.length; l < c; l++) a.push(r(e.materials, this.material[l]));
      n.material = a;
    } else n.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let a = 0; a < this.children.length; a++) n.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        n.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), u = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), u.length > 0 && (i.skeletons = u), f.length > 0 && (i.animations = f), m.length > 0 && (i.nodes = m);
    }
    return i.object = n, i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = true) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
      const n = e.children[i];
      this.add(n.clone());
    }
    return this;
  }
}
yt.DEFAULT_UP = new I(0, 1, 0);
yt.DEFAULT_MATRIX_AUTO_UPDATE = true;
yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const mi = new I(), Ri = new I(), Ea = new I(), Di = new I(), is = new I(), ns = new I(), Ah = new I(), Ma = new I(), Ca = new I(), Ta = new I(), Aa = new xt(), Pa = new xt(), Ra = new xt();
class li {
  constructor(e = new I(), t = new I(), i = new I()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), mi.subVectors(e, t), n.cross(mi);
    const r = n.lengthSq();
    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, n, r) {
    mi.subVectors(n, t), Ri.subVectors(i, t), Ea.subVectors(e, t);
    const o = mi.dot(mi), a = mi.dot(Ri), l = mi.dot(Ea), c = Ri.dot(Ri), h = Ri.dot(Ea), d = o * c - a * a;
    if (d === 0) return r.set(0, 0, 0), null;
    const u = 1 / d, f = (c * l - a * h) * u, m = (o * h - a * l) * u;
    return r.set(1 - f - m, m, f);
  }
  static containsPoint(e, t, i, n) {
    return this.getBarycoord(e, t, i, n, Di) === null ? false : Di.x >= 0 && Di.y >= 0 && Di.x + Di.y <= 1;
  }
  static getInterpolation(e, t, i, n, r, o, a, l) {
    return this.getBarycoord(e, t, i, n, Di) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, Di.x), l.addScaledVector(o, Di.y), l.addScaledVector(a, Di.z), l);
  }
  static getInterpolatedAttribute(e, t, i, n, r, o) {
    return Aa.setScalar(0), Pa.setScalar(0), Ra.setScalar(0), Aa.fromBufferAttribute(e, t), Pa.fromBufferAttribute(e, i), Ra.fromBufferAttribute(e, n), o.setScalar(0), o.addScaledVector(Aa, r.x), o.addScaledVector(Pa, r.y), o.addScaledVector(Ra, r.z), o;
  }
  static isFrontFacing(e, t, i, n) {
    return mi.subVectors(i, t), Ri.subVectors(e, t), mi.cross(Ri).dot(n) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, i, n) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return mi.subVectors(this.c, this.b), Ri.subVectors(this.a, this.b), mi.cross(Ri).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return li.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return li.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, n, r) {
    return li.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
  }
  containsPoint(e) {
    return li.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return li.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, n = this.b, r = this.c;
    let o, a;
    is.subVectors(n, i), ns.subVectors(r, i), Ma.subVectors(e, i);
    const l = is.dot(Ma), c = ns.dot(Ma);
    if (l <= 0 && c <= 0) return t.copy(i);
    Ca.subVectors(e, n);
    const h = is.dot(Ca), d = ns.dot(Ca);
    if (h >= 0 && d <= h) return t.copy(n);
    const u = l * d - h * c;
    if (u <= 0 && l >= 0 && h <= 0) return o = l / (l - h), t.copy(i).addScaledVector(is, o);
    Ta.subVectors(e, r);
    const f = is.dot(Ta), m = ns.dot(Ta);
    if (m >= 0 && f <= m) return t.copy(r);
    const _ = f * c - l * m;
    if (_ <= 0 && c >= 0 && m <= 0) return a = c / (c - m), t.copy(i).addScaledVector(ns, a);
    const g = h * m - f * d;
    if (g <= 0 && d - h >= 0 && f - m >= 0) return Ah.subVectors(r, n), a = (d - h) / (d - h + (f - m)), t.copy(n).addScaledVector(Ah, a);
    const v = 1 / (g + _ + u);
    return o = _ * v, a = u * v, t.copy(i).addScaledVector(is, o).addScaledVector(ns, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Du = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, qi = { h: 0, s: 0, l: 0 }, Kr = { h: 0, s: 0, l: 0 };
function Da(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class Xe {
  constructor(e, t, i) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const n = e;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = bi) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, it.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, n = it.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, it.toWorkingColorSpace(this, n), this;
  }
  setHSL(e, t, i, n = it.workingColorSpace) {
    if (e = rm(e, 1), t = It(t, 0, 1), i = It(i, 0, 1), t === 0) this.r = this.g = this.b = i;
    else {
      const r = i <= 0.5 ? i * (1 + t) : i + t - i * t, o = 2 * i - r;
      this.r = Da(o, r, e + 1 / 3), this.g = Da(o, r, e), this.b = Da(o, r, e - 1 / 3);
    }
    return it.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = bi) {
    function i(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const o = n[1], a = n[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = n[1], o = r.length;
      if (o === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
      if (o === 6) return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = bi) {
    const i = Du[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ws(e.r), this.g = ws(e.g), this.b = ws(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = ma(e.r), this.g = ma(e.g), this.b = ma(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = bi) {
    return it.fromWorkingColorSpace(kt.copy(this), e), Math.round(It(kt.r * 255, 0, 255)) * 65536 + Math.round(It(kt.g * 255, 0, 255)) * 256 + Math.round(It(kt.b * 255, 0, 255));
  }
  getHexString(e = bi) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = it.workingColorSpace) {
    it.fromWorkingColorSpace(kt.copy(this), t);
    const i = kt.r, n = kt.g, r = kt.b, o = Math.max(i, n, r), a = Math.min(i, n, r);
    let l, c;
    const h = (a + o) / 2;
    if (a === o) l = 0, c = 0;
    else {
      const d = o - a;
      switch (c = h <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
        case i:
          l = (n - r) / d + (n < r ? 6 : 0);
          break;
        case n:
          l = (r - i) / d + 2;
          break;
        case r:
          l = (i - n) / d + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getRGB(e, t = it.workingColorSpace) {
    return it.fromWorkingColorSpace(kt.copy(this), t), e.r = kt.r, e.g = kt.g, e.b = kt.b, e;
  }
  getStyle(e = bi) {
    it.fromWorkingColorSpace(kt.copy(this), e);
    const t = kt.r, i = kt.g, n = kt.b;
    return e !== bi ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(qi), this.setHSL(qi.h + e, qi.s + t, qi.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(qi), e.getHSL(Kr);
    const i = pa(qi.h, Kr.h, t), n = pa(qi.s, Kr.s, t), r = pa(qi.l, Kr.l, t);
    return this.setHSL(i, n, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, i = this.g, n = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * i + r[6] * n, this.g = r[1] * t + r[4] * i + r[7] * n, this.b = r[2] * t + r[5] * i + r[8] * n, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const kt = new Xe();
Xe.NAMES = Du;
let Em = 0;
class vn extends Gn {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: Em++ }), this.uuid = Ui(), this.name = "", this.type = "Material", this.blending = bs, this.side = dn, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = al, this.blendDst = ll, this.blendEquation = An, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Xe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Ts, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = mh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Yn, this.stencilZFail = Yn, this.stencilZPass = Yn, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0) for (const t in e) {
      const i = e[t];
      if (i === void 0) {
        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
        continue;
      }
      const n = this[t];
      if (n === void 0) {
        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
        continue;
      }
      n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== bs && (i.blending = this.blending), this.side !== dn && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== al && (i.blendSrc = this.blendSrc), this.blendDst !== ll && (i.blendDst = this.blendDst), this.blendEquation !== An && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Ts && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== mh && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Yn && (i.stencilFail = this.stencilFail), this.stencilZFail !== Yn && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Yn && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(r) {
      const o = [];
      for (const a in r) {
        const l = r[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const r = n(e.textures), o = n(e.images);
      r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const n = t.length;
      i = new Array(n);
      for (let r = 0; r !== n; ++r) i[r] = t[r].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Fi extends vn {
  constructor(e) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new di(), this.combine = dc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Et = new I(), Zr = new re();
class _i {
  constructor(e, t, i = false) {
    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Xl, this.updateRanges = [], this.gpuType = Ni, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) Zr.fromBufferAttribute(this, t), Zr.applyMatrix3(e), this.setXY(t, Zr.x, Zr.y);
    else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) Et.fromBufferAttribute(this, t), Et.applyMatrix3(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++) Et.fromBufferAttribute(this, t), Et.applyMatrix4(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++) Et.fromBufferAttribute(this, t), Et.applyNormalMatrix(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++) Et.fromBufferAttribute(this, t), Et.transformDirection(e), this.setXYZ(t, Et.x, Et.y, Et.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = wi(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = ot(i, this.array)), this.array[e * this.itemSize + t] = i, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = ot(t, this.array), i = ot(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e *= this.itemSize, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array), r = ot(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (e.name = this.name), this.usage !== Xl && (e.usage = this.usage), e;
  }
}
class Lu extends _i {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Iu extends _i {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class lt extends _i {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let Mm = 0;
const ri = new rt(), La = new yt(), ss = new I(), ti = new Er(), Ws = new Er(), Rt = new I();
class ft extends Gn {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: Mm++ }), this.uuid = Ui(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Au(e) ? Iu : Lu)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const r = new Be().getNormalMatrix(e);
      i.applyNormalMatrix(r), i.needsUpdate = true;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return ri.makeRotationFromQuaternion(e), this.applyMatrix4(ri), this;
  }
  rotateX(e) {
    return ri.makeRotationX(e), this.applyMatrix4(ri), this;
  }
  rotateY(e) {
    return ri.makeRotationY(e), this.applyMatrix4(ri), this;
  }
  rotateZ(e) {
    return ri.makeRotationZ(e), this.applyMatrix4(ri), this;
  }
  translate(e, t, i) {
    return ri.makeTranslation(e, t, i), this.applyMatrix4(ri), this;
  }
  scale(e, t, i) {
    return ri.makeScale(e, t, i), this.applyMatrix4(ri), this;
  }
  lookAt(e) {
    return La.lookAt(e), La.updateMatrix(), this.applyMatrix4(La.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(ss).negate(), this.translate(ss.x, ss.y, ss.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new lt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Er());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new I(-1 / 0, -1 / 0, -1 / 0), new I(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, n = t.length; i < n; i++) {
        const r = t[i];
        ti.setFromBufferAttribute(r), this.morphTargetsRelative ? (Rt.addVectors(this.boundingBox.min, ti.min), this.boundingBox.expandByPoint(Rt), Rt.addVectors(this.boundingBox.max, ti.max), this.boundingBox.expandByPoint(Rt)) : (this.boundingBox.expandByPoint(ti.min), this.boundingBox.expandByPoint(ti.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Mr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new I(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (ti.setFromBufferAttribute(e), t) for (let r = 0, o = t.length; r < o; r++) {
        const a = t[r];
        Ws.setFromBufferAttribute(a), this.morphTargetsRelative ? (Rt.addVectors(ti.min, Ws.min), ti.expandByPoint(Rt), Rt.addVectors(ti.max, Ws.max), ti.expandByPoint(Rt)) : (ti.expandByPoint(Ws.min), ti.expandByPoint(Ws.max));
      }
      ti.getCenter(i);
      let n = 0;
      for (let r = 0, o = e.count; r < o; r++) Rt.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(Rt));
      if (t) for (let r = 0, o = t.length; r < o; r++) {
        const a = t[r], l = this.morphTargetsRelative;
        for (let c = 0, h = a.count; c < h; c++) Rt.fromBufferAttribute(a, c), l && (ss.fromBufferAttribute(e, c), Rt.add(ss)), n = Math.max(n, i.distanceToSquared(Rt));
      }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = t.position, n = t.normal, r = t.uv;
    this.hasAttribute("tangent") === false && this.setAttribute("tangent", new _i(new Float32Array(4 * i.count), 4));
    const o = this.getAttribute("tangent"), a = [], l = [];
    for (let P = 0; P < i.count; P++) a[P] = new I(), l[P] = new I();
    const c = new I(), h = new I(), d = new I(), u = new re(), f = new re(), m = new re(), _ = new I(), g = new I();
    function v(P, z, w) {
      c.fromBufferAttribute(i, P), h.fromBufferAttribute(i, z), d.fromBufferAttribute(i, w), u.fromBufferAttribute(r, P), f.fromBufferAttribute(r, z), m.fromBufferAttribute(r, w), h.sub(c), d.sub(c), f.sub(u), m.sub(u);
      const E = 1 / (f.x * m.y - m.x * f.y);
      isFinite(E) && (_.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(E), g.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(E), a[P].add(_), a[z].add(_), a[w].add(_), l[P].add(g), l[z].add(g), l[w].add(g));
    }
    let y = this.groups;
    y.length === 0 && (y = [{ start: 0, count: e.count }]);
    for (let P = 0, z = y.length; P < z; ++P) {
      const w = y[P], E = w.start, N = w.count;
      for (let k = E, V = E + N; k < V; k += 3) v(e.getX(k + 0), e.getX(k + 1), e.getX(k + 2));
    }
    const x = new I(), S = new I(), A = new I(), R = new I();
    function C(P) {
      A.fromBufferAttribute(n, P), R.copy(A);
      const z = a[P];
      x.copy(z), x.sub(A.multiplyScalar(A.dot(z))).normalize(), S.crossVectors(R, z);
      const E = S.dot(l[P]) < 0 ? -1 : 1;
      o.setXYZW(P, x.x, x.y, x.z, E);
    }
    for (let P = 0, z = y.length; P < z; ++P) {
      const w = y[P], E = w.start, N = w.count;
      for (let k = E, V = E + N; k < V; k += 3) C(e.getX(k + 0)), C(e.getX(k + 1)), C(e.getX(k + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0) i = new _i(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else for (let u = 0, f = i.count; u < f; u++) i.setXYZ(u, 0, 0, 0);
      const n = new I(), r = new I(), o = new I(), a = new I(), l = new I(), c = new I(), h = new I(), d = new I();
      if (e) for (let u = 0, f = e.count; u < f; u += 3) {
        const m = e.getX(u + 0), _ = e.getX(u + 1), g = e.getX(u + 2);
        n.fromBufferAttribute(t, m), r.fromBufferAttribute(t, _), o.fromBufferAttribute(t, g), h.subVectors(o, r), d.subVectors(n, r), h.cross(d), a.fromBufferAttribute(i, m), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, g), a.add(h), l.add(h), c.add(h), i.setXYZ(m, a.x, a.y, a.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(g, c.x, c.y, c.z);
      }
      else for (let u = 0, f = t.count; u < f; u += 3) n.fromBufferAttribute(t, u + 0), r.fromBufferAttribute(t, u + 1), o.fromBufferAttribute(t, u + 2), h.subVectors(o, r), d.subVectors(n, r), h.cross(d), i.setXYZ(u + 0, h.x, h.y, h.z), i.setXYZ(u + 1, h.x, h.y, h.z), i.setXYZ(u + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++) Rt.fromBufferAttribute(e, t), Rt.normalize(), e.setXYZ(t, Rt.x, Rt.y, Rt.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array, h = a.itemSize, d = a.normalized, u = new c.constructor(l.length * h);
      let f = 0, m = 0;
      for (let _ = 0, g = l.length; _ < g; _++) {
        a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * h;
        for (let v = 0; v < h; v++) u[m++] = c[f++];
      }
      return new _i(u, h, d);
    }
    if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new ft(), i = this.index.array, n = this.attributes;
    for (const a in n) {
      const l = n[a], c = e(l, i);
      t.setAttribute(a, c);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const l = [], c = r[a];
      for (let h = 0, d = c.length; h < d; h++) {
        const u = c[h], f = e(u, i);
        l.push(f);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const n = {};
    let r = false;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], h = [];
      for (let d = 0, u = c.length; d < u; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (n[l] = h, r = true);
    }
    r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const c in n) {
      const h = n[c];
      this.setAttribute(c, h.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const h = [], d = r[c];
      for (let u = 0, f = d.length; u < f; u++) h.push(d[u].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Ph = new rt(), wn = new Cr(), Jr = new Mr(), Rh = new I(), Qr = new I(), eo = new I(), to = new I(), Ia = new I(), io = new I(), Dh = new I(), no = new I();
class Ut extends yt {
  constructor(e = new ft(), t = new Fi()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, o = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const a = this.morphTargetInfluences;
    if (r && a) {
      io.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const h = a[l], d = r[l];
        h !== 0 && (Ia.fromBufferAttribute(d, e), o ? io.addScaledVector(Ia, h) : io.addScaledVector(Ia.sub(t), h));
      }
      t.add(io);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.material, r = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Jr.copy(i.boundingSphere), Jr.applyMatrix4(r), wn.copy(e.ray).recast(e.near), !(Jr.containsPoint(wn.origin) === false && (wn.intersectSphere(Jr, Rh) === null || wn.origin.distanceToSquared(Rh) > (e.far - e.near) ** 2)) && (Ph.copy(r).invert(), wn.copy(e.ray).applyMatrix4(Ph), !(i.boundingBox !== null && wn.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, wn)));
  }
  _computeIntersections(e, t, i) {
    let n;
    const r = this.geometry, o = this.material, a = r.index, l = r.attributes.position, c = r.attributes.uv, h = r.attributes.uv1, d = r.attributes.normal, u = r.groups, f = r.drawRange;
    if (a !== null) if (Array.isArray(o)) for (let m = 0, _ = u.length; m < _; m++) {
      const g = u[m], v = o[g.materialIndex], y = Math.max(g.start, f.start), x = Math.min(a.count, Math.min(g.start + g.count, f.start + f.count));
      for (let S = y, A = x; S < A; S += 3) {
        const R = a.getX(S), C = a.getX(S + 1), P = a.getX(S + 2);
        n = so(this, v, e, i, c, h, d, R, C, P), n && (n.faceIndex = Math.floor(S / 3), n.face.materialIndex = g.materialIndex, t.push(n));
      }
    }
    else {
      const m = Math.max(0, f.start), _ = Math.min(a.count, f.start + f.count);
      for (let g = m, v = _; g < v; g += 3) {
        const y = a.getX(g), x = a.getX(g + 1), S = a.getX(g + 2);
        n = so(this, o, e, i, c, h, d, y, x, S), n && (n.faceIndex = Math.floor(g / 3), t.push(n));
      }
    }
    else if (l !== void 0) if (Array.isArray(o)) for (let m = 0, _ = u.length; m < _; m++) {
      const g = u[m], v = o[g.materialIndex], y = Math.max(g.start, f.start), x = Math.min(l.count, Math.min(g.start + g.count, f.start + f.count));
      for (let S = y, A = x; S < A; S += 3) {
        const R = S, C = S + 1, P = S + 2;
        n = so(this, v, e, i, c, h, d, R, C, P), n && (n.faceIndex = Math.floor(S / 3), n.face.materialIndex = g.materialIndex, t.push(n));
      }
    }
    else {
      const m = Math.max(0, f.start), _ = Math.min(l.count, f.start + f.count);
      for (let g = m, v = _; g < v; g += 3) {
        const y = g, x = g + 1, S = g + 2;
        n = so(this, o, e, i, c, h, d, y, x, S), n && (n.faceIndex = Math.floor(g / 3), t.push(n));
      }
    }
  }
}
function Cm(s, e, t, i, n, r, o, a) {
  let l;
  if (e.side === Kt ? l = i.intersectTriangle(o, r, n, true, a) : l = i.intersectTriangle(n, r, o, e.side === dn, a), l === null) return null;
  no.copy(a), no.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(no);
  return c < t.near || c > t.far ? null : { distance: c, point: no.clone(), object: s };
}
function so(s, e, t, i, n, r, o, a, l, c) {
  s.getVertexPosition(a, Qr), s.getVertexPosition(l, eo), s.getVertexPosition(c, to);
  const h = Cm(s, e, t, i, Qr, eo, to, Dh);
  if (h) {
    const d = new I();
    li.getBarycoord(Dh, Qr, eo, to, d), n && (h.uv = li.getInterpolatedAttribute(n, a, l, c, d, new re())), r && (h.uv1 = li.getInterpolatedAttribute(r, a, l, c, d, new re())), o && (h.normal = li.getInterpolatedAttribute(o, a, l, c, d, new I()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const u = { a, b: l, c, normal: new I(), materialIndex: 0 };
    li.getNormal(Qr, eo, to, u.normal), h.face = u, h.barycoord = d;
  }
  return h;
}
class ks extends ft {
  constructor(e = 1, t = 1, i = 1, n = 1, r = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: o };
    const a = this;
    n = Math.floor(n), r = Math.floor(r), o = Math.floor(o);
    const l = [], c = [], h = [], d = [];
    let u = 0, f = 0;
    m("z", "y", "x", -1, -1, i, t, e, o, r, 0), m("z", "y", "x", 1, -1, i, t, -e, o, r, 1), m("x", "z", "y", 1, 1, e, i, t, n, o, 2), m("x", "z", "y", 1, -1, e, i, -t, n, o, 3), m("x", "y", "z", 1, -1, e, t, i, n, r, 4), m("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(l), this.setAttribute("position", new lt(c, 3)), this.setAttribute("normal", new lt(h, 3)), this.setAttribute("uv", new lt(d, 2));
    function m(_, g, v, y, x, S, A, R, C, P, z) {
      const w = S / C, E = A / P, N = S / 2, k = A / 2, V = R / 2, q = C + 1, G = P + 1;
      let ee = 0, O = 0;
      const Q = new I();
      for (let X = 0; X < G; X++) {
        const K = X * E - k;
        for (let Le = 0; Le < q; Le++) {
          const Re = Le * w - N;
          Q[_] = Re * y, Q[g] = K * x, Q[v] = V, c.push(Q.x, Q.y, Q.z), Q[_] = 0, Q[g] = 0, Q[v] = R > 0 ? 1 : -1, h.push(Q.x, Q.y, Q.z), d.push(Le / C), d.push(1 - X / P), ee += 1;
        }
      }
      for (let X = 0; X < P; X++) for (let K = 0; K < C; K++) {
        const Le = u + K + q * X, Re = u + K + q * (X + 1), Y = u + (K + 1) + q * (X + 1), se = u + (K + 1) + q * X;
        l.push(Le, Re, se), l.push(Re, Y, se), O += 6;
      }
      a.addGroup(f, O, z), f += O, u += ee;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ks(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Ls(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const i in s[t]) {
      const n = s[t][i];
      n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
    }
  }
  return e;
}
function zt(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const i = Ls(s[t]);
    for (const n in i) e[n] = i[n];
  }
  return e;
}
function Tm(s) {
  const e = [];
  for (let t = 0; t < s.length; t++) e.push(s[t].clone());
  return e;
}
function Nu(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === true ? e.texture.colorSpace : it.workingColorSpace;
}
const Am = { clone: Ls, merge: zt };
var Pm = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Rm = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class pn extends vn {
  constructor(e) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Pm, this.fragmentShader = Rm, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = { clipCullDistance: false, multiDraw: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ls(e.uniforms), this.uniformsGroups = Tm(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const n in this.uniforms) {
      const o = this.uniforms[n].value;
      o && o.isTexture ? t.uniforms[n] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[n] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[n] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[n] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[n] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[n] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[n] = { type: "m4", value: o.toArray() } : t.uniforms[n] = { value: o };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions) this.extensions[n] === true && (i[n] = true);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class ku extends yt {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new rt(), this.projectionMatrix = new rt(), this.projectionMatrixInverse = new rt(), this.coordinateSystem = ki;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ki = new I(), Lh = new re(), Ih = new re();
class ai extends ku {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = jl * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ro * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return jl * 2 * Math.atan(Math.tan(Ro * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    Ki.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Ki.x, Ki.y).multiplyScalar(-e / Ki.z), Ki.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Ki.x, Ki.y).multiplyScalar(-e / Ki.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, Lh, Ih), t.subVectors(Ih, Lh);
  }
  setViewOffset(e, t, i, n, r, o) {
    this.aspect = e / t, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Ro * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, c = o.fullHeight;
      r += o.offsetX * n / l, t -= o.offsetY * i / c, n *= o.width / l, i *= o.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const rs = -90, os = 1;
class Dm extends yt {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new ai(rs, os, e, t);
    n.layers = this.layers, this.add(n);
    const r = new ai(rs, os, e, t);
    r.layers = this.layers, this.add(r);
    const o = new ai(rs, os, e, t);
    o.layers = this.layers, this.add(o);
    const a = new ai(rs, os, e, t);
    a.layers = this.layers, this.add(a);
    const l = new ai(rs, os, e, t);
    l.layers = this.layers, this.add(l);
    const c = new ai(rs, os, e, t);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, n, r, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === ki) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === Vo) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, o, a, l, c, h] = this.children, d = e.getRenderTarget(), u = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = false;
    const _ = i.texture.generateMipmaps;
    i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, n), e.render(t, r), e.setRenderTarget(i, 1, n), e.render(t, o), e.setRenderTarget(i, 2, n), e.render(t, a), e.setRenderTarget(i, 3, n), e.render(t, l), e.setRenderTarget(i, 4, n), e.render(t, c), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, n), e.render(t, h), e.setRenderTarget(d, u, f), e.xr.enabled = m, i.texture.needsPMREMUpdate = true;
  }
}
class Ou extends Vt {
  constructor(e, t, i, n, r, o, a, l, c, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : As, super(e, t, i, n, r, o, a, l, c, h), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Lm extends Un {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = true;
    const i = { width: e, height: e, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new Ou(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : gi;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, n = new ks(5, 5, 5), r = new pn({ name: "CubemapFromEquirect", uniforms: Ls(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: Kt, blending: an });
    r.uniforms.tEquirect.value = t;
    const o = new Ut(n, r), a = t.minFilter;
    return t.minFilter === Dn && (t.minFilter = gi), new Dm(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, i, n) {
    const r = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, n);
    e.setRenderTarget(r);
  }
}
const Na = new I(), Im = new I(), Nm = new Be();
class en {
  constructor(e = new I(1, 0, 0), t = 0) {
    this.isPlane = true, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const n = Na.subVectors(i, t).cross(Im.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(Na), n = this.normal.dot(i);
    if (n === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / n;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || Nm.getNormalMatrix(e), n = this.coplanarPoint(Na).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const yn = new Mr(), ro = new I();
class xc {
  constructor(e = new en(), t = new en(), i = new en(), n = new en(), r = new en(), o = new en()) {
    this.planes = [e, t, i, n, r, o];
  }
  set(e, t, i, n, r, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = ki) {
    const i = this.planes, n = e.elements, r = n[0], o = n[1], a = n[2], l = n[3], c = n[4], h = n[5], d = n[6], u = n[7], f = n[8], m = n[9], _ = n[10], g = n[11], v = n[12], y = n[13], x = n[14], S = n[15];
    if (i[0].setComponents(l - r, u - c, g - f, S - v).normalize(), i[1].setComponents(l + r, u + c, g + f, S + v).normalize(), i[2].setComponents(l + o, u + h, g + m, S + y).normalize(), i[3].setComponents(l - o, u - h, g - m, S - y).normalize(), i[4].setComponents(l - a, u - d, g - _, S - x).normalize(), t === ki) i[5].setComponents(l + a, u + d, g + _, S + x).normalize();
    else if (t === Vo) i[5].setComponents(a, d, _, x).normalize();
    else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), yn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), yn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(yn);
  }
  intersectsSprite(e) {
    return yn.center.set(0, 0, 0), yn.radius = 0.7071067811865476, yn.applyMatrix4(e.matrixWorld), this.intersectsSphere(yn);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, n = -e.radius;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(i) < n) return false;
    return true;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (ro.x = n.normal.x > 0 ? e.max.x : e.min.x, ro.y = n.normal.y > 0 ? e.max.y : e.min.y, ro.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(ro) < 0) return false;
    }
    return true;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Uu() {
  let s = null, e = false, t = null, i = null;
  function n(r, o) {
    t(r, o), i = s.requestAnimationFrame(n);
  }
  return { start: function() {
    e !== true && t !== null && (i = s.requestAnimationFrame(n), e = true);
  }, stop: function() {
    s.cancelAnimationFrame(i), e = false;
  }, setAnimationLoop: function(r) {
    t = r;
  }, setContext: function(r) {
    s = r;
  } };
}
function km(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(a, l) {
    const c = a.array, h = a.usage, d = c.byteLength, u = s.createBuffer();
    s.bindBuffer(l, u), s.bufferData(l, c, h), a.onUploadCallback();
    let f;
    if (c instanceof Float32Array) f = s.FLOAT;
    else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
    else if (c instanceof Int16Array) f = s.SHORT;
    else if (c instanceof Uint32Array) f = s.UNSIGNED_INT;
    else if (c instanceof Int32Array) f = s.INT;
    else if (c instanceof Int8Array) f = s.BYTE;
    else if (c instanceof Uint8Array) f = s.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) f = s.UNSIGNED_BYTE;
    else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return { buffer: u, type: f, bytesPerElement: c.BYTES_PER_ELEMENT, version: a.version, size: d };
  }
  function i(a, l, c) {
    const h = l.array, d = l.updateRanges;
    if (s.bindBuffer(c, a), d.length === 0) s.bufferSubData(c, 0, h);
    else {
      d.sort((f, m) => f.start - m.start);
      let u = 0;
      for (let f = 1; f < d.length; f++) {
        const m = d[u], _ = d[f];
        _.start <= m.start + m.count + 1 ? m.count = Math.max(m.count, _.start + _.count - m.start) : (++u, d[u] = _);
      }
      d.length = u + 1;
      for (let f = 0, m = d.length; f < m; f++) {
        const _ = d[f];
        s.bufferSubData(c, _.start * h.BYTES_PER_ELEMENT, h, _.start, _.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function n(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function r(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (s.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
      const h = e.get(a);
      (!h || h.version < a.version) && e.set(a, { buffer: a.buffer, type: a.type, bytesPerElement: a.elementSize, version: a.version });
      return;
    }
    const c = e.get(a);
    if (c === void 0) e.set(a, t(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(c.buffer, a, l), c.version = a.version;
    }
  }
  return { get: n, remove: r, update: o };
}
class Tr extends ft {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n };
    const r = e / 2, o = t / 2, a = Math.floor(i), l = Math.floor(n), c = a + 1, h = l + 1, d = e / a, u = t / l, f = [], m = [], _ = [], g = [];
    for (let v = 0; v < h; v++) {
      const y = v * u - o;
      for (let x = 0; x < c; x++) {
        const S = x * d - r;
        m.push(S, -y, 0), _.push(0, 0, 1), g.push(x / a), g.push(1 - v / l);
      }
    }
    for (let v = 0; v < l; v++) for (let y = 0; y < a; y++) {
      const x = y + c * v, S = y + c * (v + 1), A = y + 1 + c * (v + 1), R = y + 1 + c * v;
      f.push(x, S, R), f.push(S, A, R);
    }
    this.setIndex(f), this.setAttribute("position", new lt(m, 3)), this.setAttribute("normal", new lt(_, 3)), this.setAttribute("uv", new lt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Tr(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Om = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Um = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Fm = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, zm = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Bm = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Vm = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Hm = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Gm = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, $m = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, Wm = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, Xm = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, jm = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Ym = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, qm = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Km = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Zm = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Jm = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Qm = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, eg = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, tg = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, ig = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, ng = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, sg = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, rg = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, og = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, ag = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, lg = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, cg = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, hg = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, dg = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, ug = "gl_FragColor = linearToOutputTexel( gl_FragColor );", pg = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, fg = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, mg = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, gg = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, vg = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, _g = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, bg = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, xg = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, wg = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, yg = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Sg = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Eg = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Mg = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Cg = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Tg = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Ag = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Pg = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Rg = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Dg = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Lg = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Ig = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Ng = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, kg = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Og = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Ug = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Fg = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, zg = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Bg = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Vg = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Hg = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Gg = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, $g = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Wg = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Xg = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, jg = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Yg = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, qg = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Kg = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Zg = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Jg = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Qg = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, ev = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, tv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, iv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, nv = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, sv = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, rv = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, ov = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, av = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, lv = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, cv = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, hv = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, dv = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, uv = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, pv = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, fv = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, mv = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, gv = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, vv = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, _v = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, bv = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, xv = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, wv = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, yv = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Sv = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Ev = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Mv = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Cv = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Tv = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Av = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Pv = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Rv = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Dv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Lv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Iv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Nv = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const kv = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Ov = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Uv = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Fv = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, zv = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Bv = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Vv = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Hv = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Gv = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, $v = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Wv = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Xv = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, jv = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Yv = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, qv = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Kv = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Zv = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Jv = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Qv = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, e_ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, t_ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, i_ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, n_ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, s_ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, r_ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, o_ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, a_ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, l_ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, c_ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, h_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, d_ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, u_ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, p_ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, f_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, He = { alphahash_fragment: Om, alphahash_pars_fragment: Um, alphamap_fragment: Fm, alphamap_pars_fragment: zm, alphatest_fragment: Bm, alphatest_pars_fragment: Vm, aomap_fragment: Hm, aomap_pars_fragment: Gm, batching_pars_vertex: $m, batching_vertex: Wm, begin_vertex: Xm, beginnormal_vertex: jm, bsdfs: Ym, iridescence_fragment: qm, bumpmap_pars_fragment: Km, clipping_planes_fragment: Zm, clipping_planes_pars_fragment: Jm, clipping_planes_pars_vertex: Qm, clipping_planes_vertex: eg, color_fragment: tg, color_pars_fragment: ig, color_pars_vertex: ng, color_vertex: sg, common: rg, cube_uv_reflection_fragment: og, defaultnormal_vertex: ag, displacementmap_pars_vertex: lg, displacementmap_vertex: cg, emissivemap_fragment: hg, emissivemap_pars_fragment: dg, colorspace_fragment: ug, colorspace_pars_fragment: pg, envmap_fragment: fg, envmap_common_pars_fragment: mg, envmap_pars_fragment: gg, envmap_pars_vertex: vg, envmap_physical_pars_fragment: Ag, envmap_vertex: _g, fog_vertex: bg, fog_pars_vertex: xg, fog_fragment: wg, fog_pars_fragment: yg, gradientmap_pars_fragment: Sg, lightmap_pars_fragment: Eg, lights_lambert_fragment: Mg, lights_lambert_pars_fragment: Cg, lights_pars_begin: Tg, lights_toon_fragment: Pg, lights_toon_pars_fragment: Rg, lights_phong_fragment: Dg, lights_phong_pars_fragment: Lg, lights_physical_fragment: Ig, lights_physical_pars_fragment: Ng, lights_fragment_begin: kg, lights_fragment_maps: Og, lights_fragment_end: Ug, logdepthbuf_fragment: Fg, logdepthbuf_pars_fragment: zg, logdepthbuf_pars_vertex: Bg, logdepthbuf_vertex: Vg, map_fragment: Hg, map_pars_fragment: Gg, map_particle_fragment: $g, map_particle_pars_fragment: Wg, metalnessmap_fragment: Xg, metalnessmap_pars_fragment: jg, morphinstance_vertex: Yg, morphcolor_vertex: qg, morphnormal_vertex: Kg, morphtarget_pars_vertex: Zg, morphtarget_vertex: Jg, normal_fragment_begin: Qg, normal_fragment_maps: ev, normal_pars_fragment: tv, normal_pars_vertex: iv, normal_vertex: nv, normalmap_pars_fragment: sv, clearcoat_normal_fragment_begin: rv, clearcoat_normal_fragment_maps: ov, clearcoat_pars_fragment: av, iridescence_pars_fragment: lv, opaque_fragment: cv, packing: hv, premultiplied_alpha_fragment: dv, project_vertex: uv, dithering_fragment: pv, dithering_pars_fragment: fv, roughnessmap_fragment: mv, roughnessmap_pars_fragment: gv, shadowmap_pars_fragment: vv, shadowmap_pars_vertex: _v, shadowmap_vertex: bv, shadowmask_pars_fragment: xv, skinbase_vertex: wv, skinning_pars_vertex: yv, skinning_vertex: Sv, skinnormal_vertex: Ev, specularmap_fragment: Mv, specularmap_pars_fragment: Cv, tonemapping_fragment: Tv, tonemapping_pars_fragment: Av, transmission_fragment: Pv, transmission_pars_fragment: Rv, uv_pars_fragment: Dv, uv_pars_vertex: Lv, uv_vertex: Iv, worldpos_vertex: Nv, background_vert: kv, background_frag: Ov, backgroundCube_vert: Uv, backgroundCube_frag: Fv, cube_vert: zv, cube_frag: Bv, depth_vert: Vv, depth_frag: Hv, distanceRGBA_vert: Gv, distanceRGBA_frag: $v, equirect_vert: Wv, equirect_frag: Xv, linedashed_vert: jv, linedashed_frag: Yv, meshbasic_vert: qv, meshbasic_frag: Kv, meshlambert_vert: Zv, meshlambert_frag: Jv, meshmatcap_vert: Qv, meshmatcap_frag: e_, meshnormal_vert: t_, meshnormal_frag: i_, meshphong_vert: n_, meshphong_frag: s_, meshphysical_vert: r_, meshphysical_frag: o_, meshtoon_vert: a_, meshtoon_frag: l_, points_vert: c_, points_frag: h_, shadow_vert: d_, shadow_frag: u_, sprite_vert: p_, sprite_frag: f_ }, fe = { common: { diffuse: { value: new Xe(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Be() }, alphaMap: { value: null }, alphaMapTransform: { value: new Be() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Be() } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Be() }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Be() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Be() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Be() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Be() }, normalScale: { value: new re(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Be() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Be() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Be() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Be() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Xe(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Xe(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Be() }, alphaTest: { value: 0 }, uvTransform: { value: new Be() } }, sprite: { diffuse: { value: new Xe(16777215) }, opacity: { value: 1 }, center: { value: new re(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Be() }, alphaMap: { value: null }, alphaMapTransform: { value: new Be() }, alphaTest: { value: 0 } } }, xi = { basic: { uniforms: zt([fe.common, fe.specularmap, fe.envmap, fe.aomap, fe.lightmap, fe.fog]), vertexShader: He.meshbasic_vert, fragmentShader: He.meshbasic_frag }, lambert: { uniforms: zt([fe.common, fe.specularmap, fe.envmap, fe.aomap, fe.lightmap, fe.emissivemap, fe.bumpmap, fe.normalmap, fe.displacementmap, fe.fog, fe.lights, { emissive: { value: new Xe(0) } }]), vertexShader: He.meshlambert_vert, fragmentShader: He.meshlambert_frag }, phong: { uniforms: zt([fe.common, fe.specularmap, fe.envmap, fe.aomap, fe.lightmap, fe.emissivemap, fe.bumpmap, fe.normalmap, fe.displacementmap, fe.fog, fe.lights, { emissive: { value: new Xe(0) }, specular: { value: new Xe(1118481) }, shininess: { value: 30 } }]), vertexShader: He.meshphong_vert, fragmentShader: He.meshphong_frag }, standard: { uniforms: zt([fe.common, fe.envmap, fe.aomap, fe.lightmap, fe.emissivemap, fe.bumpmap, fe.normalmap, fe.displacementmap, fe.roughnessmap, fe.metalnessmap, fe.fog, fe.lights, { emissive: { value: new Xe(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: He.meshphysical_vert, fragmentShader: He.meshphysical_frag }, toon: { uniforms: zt([fe.common, fe.aomap, fe.lightmap, fe.emissivemap, fe.bumpmap, fe.normalmap, fe.displacementmap, fe.gradientmap, fe.fog, fe.lights, { emissive: { value: new Xe(0) } }]), vertexShader: He.meshtoon_vert, fragmentShader: He.meshtoon_frag }, matcap: { uniforms: zt([fe.common, fe.bumpmap, fe.normalmap, fe.displacementmap, fe.fog, { matcap: { value: null } }]), vertexShader: He.meshmatcap_vert, fragmentShader: He.meshmatcap_frag }, points: { uniforms: zt([fe.points, fe.fog]), vertexShader: He.points_vert, fragmentShader: He.points_frag }, dashed: { uniforms: zt([fe.common, fe.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: He.linedashed_vert, fragmentShader: He.linedashed_frag }, depth: { uniforms: zt([fe.common, fe.displacementmap]), vertexShader: He.depth_vert, fragmentShader: He.depth_frag }, normal: { uniforms: zt([fe.common, fe.bumpmap, fe.normalmap, fe.displacementmap, { opacity: { value: 1 } }]), vertexShader: He.meshnormal_vert, fragmentShader: He.meshnormal_frag }, sprite: { uniforms: zt([fe.sprite, fe.fog]), vertexShader: He.sprite_vert, fragmentShader: He.sprite_frag }, background: { uniforms: { uvTransform: { value: new Be() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: He.background_vert, fragmentShader: He.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Be() } }, vertexShader: He.backgroundCube_vert, fragmentShader: He.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: He.cube_vert, fragmentShader: He.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: He.equirect_vert, fragmentShader: He.equirect_frag }, distanceRGBA: { uniforms: zt([fe.common, fe.displacementmap, { referencePosition: { value: new I() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: He.distanceRGBA_vert, fragmentShader: He.distanceRGBA_frag }, shadow: { uniforms: zt([fe.lights, fe.fog, { color: { value: new Xe(0) }, opacity: { value: 1 } }]), vertexShader: He.shadow_vert, fragmentShader: He.shadow_frag } };
xi.physical = { uniforms: zt([xi.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Be() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Be() }, clearcoatNormalScale: { value: new re(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Be() }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Be() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Be() }, sheen: { value: 0 }, sheenColor: { value: new Xe(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Be() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Be() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Be() }, transmissionSamplerSize: { value: new re() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Be() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Xe(0) }, specularColor: { value: new Xe(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Be() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Be() }, anisotropyVector: { value: new re() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Be() } }]), vertexShader: He.meshphysical_vert, fragmentShader: He.meshphysical_frag };
const oo = { r: 0, b: 0, g: 0 }, Sn = new di(), m_ = new rt();
function g_(s, e, t, i, n, r, o) {
  const a = new Xe(0);
  let l = r === true ? 0 : 1, c, h, d = null, u = 0, f = null;
  function m(y) {
    let x = y.isScene === true ? y.background : null;
    return x && x.isTexture && (x = (y.backgroundBlurriness > 0 ? t : e).get(x)), x;
  }
  function _(y) {
    let x = false;
    const S = m(y);
    S === null ? v(a, l) : S && S.isColor && (v(S, 1), x = true);
    const A = s.xr.getEnvironmentBlendMode();
    A === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : A === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || x) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function g(y, x) {
    const S = m(x);
    S && (S.isCubeTexture || S.mapping === Qo) ? (h === void 0 && (h = new Ut(new ks(1, 1, 1), new pn({ name: "BackgroundCubeMaterial", uniforms: Ls(xi.backgroundCube.uniforms), vertexShader: xi.backgroundCube.vertexShader, fragmentShader: xi.backgroundCube.fragmentShader, side: Kt, depthTest: false, depthWrite: false, fog: false })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(A, R, C) {
      this.matrixWorld.copyPosition(C.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), n.update(h)), Sn.copy(x.backgroundRotation), Sn.x *= -1, Sn.y *= -1, Sn.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === false && (Sn.y *= -1, Sn.z *= -1), h.material.uniforms.envMap.value = S, h.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(m_.makeRotationFromEuler(Sn)), h.material.toneMapped = it.getTransfer(S.colorSpace) !== pt, (d !== S || u !== S.version || f !== s.toneMapping) && (h.material.needsUpdate = true, d = S, u = S.version, f = s.toneMapping), h.layers.enableAll(), y.unshift(h, h.geometry, h.material, 0, 0, null)) : S && S.isTexture && (c === void 0 && (c = new Ut(new Tr(2, 2), new pn({ name: "BackgroundMaterial", uniforms: Ls(xi.background.uniforms), vertexShader: xi.background.vertexShader, fragmentShader: xi.background.fragmentShader, side: dn, depthTest: false, depthWrite: false, fog: false })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), n.update(c)), c.material.uniforms.t2D.value = S, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = it.getTransfer(S.colorSpace) !== pt, S.matrixAutoUpdate === true && S.updateMatrix(), c.material.uniforms.uvTransform.value.copy(S.matrix), (d !== S || u !== S.version || f !== s.toneMapping) && (c.material.needsUpdate = true, d = S, u = S.version, f = s.toneMapping), c.layers.enableAll(), y.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function v(y, x) {
    y.getRGB(oo, Nu(s)), i.buffers.color.setClear(oo.r, oo.g, oo.b, x, o);
  }
  return { getClearColor: function() {
    return a;
  }, setClearColor: function(y, x = 1) {
    a.set(y), l = x, v(a, l);
  }, getClearAlpha: function() {
    return l;
  }, setClearAlpha: function(y) {
    l = y, v(a, l);
  }, render: _, addToRenderList: g };
}
function v_(s, e) {
  const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, n = u(null);
  let r = n, o = false;
  function a(w, E, N, k, V) {
    let q = false;
    const G = d(k, N, E);
    r !== G && (r = G, c(r.object)), q = f(w, k, N, V), q && m(w, k, N, V), V !== null && e.update(V, s.ELEMENT_ARRAY_BUFFER), (q || o) && (o = false, S(w, E, N, k), V !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(V).buffer));
  }
  function l() {
    return s.createVertexArray();
  }
  function c(w) {
    return s.bindVertexArray(w);
  }
  function h(w) {
    return s.deleteVertexArray(w);
  }
  function d(w, E, N) {
    const k = N.wireframe === true;
    let V = i[w.id];
    V === void 0 && (V = {}, i[w.id] = V);
    let q = V[E.id];
    q === void 0 && (q = {}, V[E.id] = q);
    let G = q[k];
    return G === void 0 && (G = u(l()), q[k] = G), G;
  }
  function u(w) {
    const E = [], N = [], k = [];
    for (let V = 0; V < t; V++) E[V] = 0, N[V] = 0, k[V] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: E, enabledAttributes: N, attributeDivisors: k, object: w, attributes: {}, index: null };
  }
  function f(w, E, N, k) {
    const V = r.attributes, q = E.attributes;
    let G = 0;
    const ee = N.getAttributes();
    for (const O in ee) if (ee[O].location >= 0) {
      const X = V[O];
      let K = q[O];
      if (K === void 0 && (O === "instanceMatrix" && w.instanceMatrix && (K = w.instanceMatrix), O === "instanceColor" && w.instanceColor && (K = w.instanceColor)), X === void 0 || X.attribute !== K || K && X.data !== K.data) return true;
      G++;
    }
    return r.attributesNum !== G || r.index !== k;
  }
  function m(w, E, N, k) {
    const V = {}, q = E.attributes;
    let G = 0;
    const ee = N.getAttributes();
    for (const O in ee) if (ee[O].location >= 0) {
      let X = q[O];
      X === void 0 && (O === "instanceMatrix" && w.instanceMatrix && (X = w.instanceMatrix), O === "instanceColor" && w.instanceColor && (X = w.instanceColor));
      const K = {};
      K.attribute = X, X && X.data && (K.data = X.data), V[O] = K, G++;
    }
    r.attributes = V, r.attributesNum = G, r.index = k;
  }
  function _() {
    const w = r.newAttributes;
    for (let E = 0, N = w.length; E < N; E++) w[E] = 0;
  }
  function g(w) {
    v(w, 0);
  }
  function v(w, E) {
    const N = r.newAttributes, k = r.enabledAttributes, V = r.attributeDivisors;
    N[w] = 1, k[w] === 0 && (s.enableVertexAttribArray(w), k[w] = 1), V[w] !== E && (s.vertexAttribDivisor(w, E), V[w] = E);
  }
  function y() {
    const w = r.newAttributes, E = r.enabledAttributes;
    for (let N = 0, k = E.length; N < k; N++) E[N] !== w[N] && (s.disableVertexAttribArray(N), E[N] = 0);
  }
  function x(w, E, N, k, V, q, G) {
    G === true ? s.vertexAttribIPointer(w, E, N, V, q) : s.vertexAttribPointer(w, E, N, k, V, q);
  }
  function S(w, E, N, k) {
    _();
    const V = k.attributes, q = N.getAttributes(), G = E.defaultAttributeValues;
    for (const ee in q) {
      const O = q[ee];
      if (O.location >= 0) {
        let Q = V[ee];
        if (Q === void 0 && (ee === "instanceMatrix" && w.instanceMatrix && (Q = w.instanceMatrix), ee === "instanceColor" && w.instanceColor && (Q = w.instanceColor)), Q !== void 0) {
          const X = Q.normalized, K = Q.itemSize, Le = e.get(Q);
          if (Le === void 0) continue;
          const Re = Le.buffer, Y = Le.type, se = Le.bytesPerElement, me = Y === s.INT || Y === s.UNSIGNED_INT || Q.gpuType === uc;
          if (Q.isInterleavedBufferAttribute) {
            const de = Q.data, Ne = de.stride, Ie = Q.offset;
            if (de.isInstancedInterleavedBuffer) {
              for (let ze = 0; ze < O.locationSize; ze++) v(O.location + ze, de.meshPerAttribute);
              w.isInstancedMesh !== true && k._maxInstanceCount === void 0 && (k._maxInstanceCount = de.meshPerAttribute * de.count);
            } else for (let ze = 0; ze < O.locationSize; ze++) g(O.location + ze);
            s.bindBuffer(s.ARRAY_BUFFER, Re);
            for (let ze = 0; ze < O.locationSize; ze++) x(O.location + ze, K / O.locationSize, Y, X, Ne * se, (Ie + K / O.locationSize * ze) * se, me);
          } else {
            if (Q.isInstancedBufferAttribute) {
              for (let de = 0; de < O.locationSize; de++) v(O.location + de, Q.meshPerAttribute);
              w.isInstancedMesh !== true && k._maxInstanceCount === void 0 && (k._maxInstanceCount = Q.meshPerAttribute * Q.count);
            } else for (let de = 0; de < O.locationSize; de++) g(O.location + de);
            s.bindBuffer(s.ARRAY_BUFFER, Re);
            for (let de = 0; de < O.locationSize; de++) x(O.location + de, K / O.locationSize, Y, X, K * se, K / O.locationSize * de * se, me);
          }
        } else if (G !== void 0) {
          const X = G[ee];
          if (X !== void 0) switch (X.length) {
            case 2:
              s.vertexAttrib2fv(O.location, X);
              break;
            case 3:
              s.vertexAttrib3fv(O.location, X);
              break;
            case 4:
              s.vertexAttrib4fv(O.location, X);
              break;
            default:
              s.vertexAttrib1fv(O.location, X);
          }
        }
      }
    }
    y();
  }
  function A() {
    P();
    for (const w in i) {
      const E = i[w];
      for (const N in E) {
        const k = E[N];
        for (const V in k) h(k[V].object), delete k[V];
        delete E[N];
      }
      delete i[w];
    }
  }
  function R(w) {
    if (i[w.id] === void 0) return;
    const E = i[w.id];
    for (const N in E) {
      const k = E[N];
      for (const V in k) h(k[V].object), delete k[V];
      delete E[N];
    }
    delete i[w.id];
  }
  function C(w) {
    for (const E in i) {
      const N = i[E];
      if (N[w.id] === void 0) continue;
      const k = N[w.id];
      for (const V in k) h(k[V].object), delete k[V];
      delete N[w.id];
    }
  }
  function P() {
    z(), o = true, r !== n && (r = n, c(r.object));
  }
  function z() {
    n.geometry = null, n.program = null, n.wireframe = false;
  }
  return { setup: a, reset: P, resetDefaultState: z, dispose: A, releaseStatesOfGeometry: R, releaseStatesOfProgram: C, initAttributes: _, enableAttribute: g, disableUnusedAttributes: y };
}
function __(s, e, t) {
  let i;
  function n(c) {
    i = c;
  }
  function r(c, h) {
    s.drawArrays(i, c, h), t.update(h, i, 1);
  }
  function o(c, h, d) {
    d !== 0 && (s.drawArraysInstanced(i, c, h, d), t.update(h, i, d));
  }
  function a(c, h, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, h, 0, d);
    let f = 0;
    for (let m = 0; m < d; m++) f += h[m];
    t.update(f, i, 1);
  }
  function l(c, h, d, u) {
    if (d === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null) for (let m = 0; m < c.length; m++) o(c[m], h[m], u[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(i, c, 0, h, 0, u, 0, d);
      let m = 0;
      for (let _ = 0; _ < d; _++) m += h[_];
      for (let _ = 0; _ < u.length; _++) t.update(m, i, u[_]);
    }
  }
  this.setMode = n, this.render = r, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
}
function b_(s, e, t, i) {
  let n;
  function r() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === true) {
      const C = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function o(C) {
    return !(C !== vi && i.convert(C) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function a(C) {
    const P = C === Sr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(C !== Bi && i.convert(C) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && C !== Ni && !P);
  }
  function l(C) {
    if (C === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0) return "highp";
      C = "mediump";
    }
    return C === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const h = l(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const d = t.logarithmicDepthBuffer === true, u = t.reverseDepthBuffer === true && e.has("EXT_clip_control");
  if (u === true) {
    const C = e.get("EXT_clip_control");
    C.clipControlEXT(C.LOWER_LEFT_EXT, C.ZERO_TO_ONE_EXT);
  }
  const f = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = s.getParameter(s.MAX_TEXTURE_SIZE), g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), v = s.getParameter(s.MAX_VERTEX_ATTRIBS), y = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), x = s.getParameter(s.MAX_VARYING_VECTORS), S = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), A = m > 0, R = s.getParameter(s.MAX_SAMPLES);
  return { isWebGL2: true, getMaxAnisotropy: r, getMaxPrecision: l, textureFormatReadable: o, textureTypeReadable: a, precision: c, logarithmicDepthBuffer: d, reverseDepthBuffer: u, maxTextures: f, maxVertexTextures: m, maxTextureSize: _, maxCubemapSize: g, maxAttributes: v, maxVertexUniforms: y, maxVaryings: x, maxFragmentUniforms: S, vertexTextures: A, maxSamples: R };
}
function x_(s) {
  const e = this;
  let t = null, i = 0, n = false, r = false;
  const o = new en(), a = new Be(), l = { value: null, needsUpdate: false };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, u) {
    const f = d.length !== 0 || u || i !== 0 || n;
    return n = u, i = d.length, f;
  }, this.beginShadows = function() {
    r = true, h(null);
  }, this.endShadows = function() {
    r = false;
  }, this.setGlobalState = function(d, u) {
    t = h(d, u, 0);
  }, this.setState = function(d, u, f) {
    const m = d.clippingPlanes, _ = d.clipIntersection, g = d.clipShadows, v = s.get(d);
    if (!n || m === null || m.length === 0 || r && !g) r ? h(null) : c();
    else {
      const y = r ? 0 : i, x = y * 4;
      let S = v.clippingState || null;
      l.value = S, S = h(m, u, x, f);
      for (let A = 0; A !== x; ++A) S[A] = t[A];
      v.clippingState = S, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += y;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(d, u, f, m) {
    const _ = d !== null ? d.length : 0;
    let g = null;
    if (_ !== 0) {
      if (g = l.value, m !== true || g === null) {
        const v = f + _ * 4, y = u.matrixWorldInverse;
        a.getNormalMatrix(y), (g === null || g.length < v) && (g = new Float32Array(v));
        for (let x = 0, S = f; x !== _; ++x, S += 4) o.copy(d[x]).applyMatrix4(y, a), o.normal.toArray(g, S), g[S + 3] = o.constant;
      }
      l.value = g, l.needsUpdate = true;
    }
    return e.numPlanes = _, e.numIntersection = 0, g;
  }
}
function w_(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === gl ? o.mapping = As : a === vl && (o.mapping = Ps), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === gl || a === vl) if (e.has(o)) {
        const l = e.get(o).texture;
        return t(l, o.mapping);
      } else {
        const l = o.image;
        if (l && l.height > 0) {
          const c = new Lm(l.height);
          return c.fromEquirectangularTexture(s, o), e.set(o, c), o.addEventListener("dispose", n), t(c.texture, o.mapping);
        } else return null;
      }
    }
    return o;
  }
  function n(o) {
    const a = o.target;
    a.removeEventListener("dispose", n);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: r };
}
class Fu extends ku {
  constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, n, r, o) {
    this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let r = i - e, o = i + e, a = n + t, l = n - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, o = r + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const ms = 4, Nh = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Pn = 20, ka = new Fu(), kh = new Xe();
let Oa = null, Ua = 0, Fa = 0, za = false;
const Tn = (1 + Math.sqrt(5)) / 2, as = 1 / Tn, Oh = [new I(-Tn, as, 0), new I(Tn, as, 0), new I(-as, 0, Tn), new I(as, 0, Tn), new I(0, Tn, -as), new I(0, Tn, as), new I(-1, 1, -1), new I(1, 1, -1), new I(-1, 1, 1), new I(1, 1, 1)];
class Uh {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, n = 100) {
    Oa = this._renderer.getRenderTarget(), Ua = this._renderer.getActiveCubeFace(), Fa = this._renderer.getActiveMipmapLevel(), za = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = true, this._sceneToCubeUV(e, i, n, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Bh(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = zh(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Oa, Ua, Fa), this._renderer.xr.enabled = za, e.scissorTest = false, ao(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === As || e.mapping === Ps ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Oa = this._renderer.getRenderTarget(), Ua = this._renderer.getActiveCubeFace(), Fa = this._renderer.getActiveMipmapLevel(), za = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: gi, minFilter: gi, generateMipmaps: false, type: Sr, format: vi, colorSpace: gn, depthBuffer: false }, n = Fh(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Fh(e, t, i);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = y_(r)), this._blurMaterial = S_(r, e, t);
    }
    return n;
  }
  _compileMaterial(e) {
    const t = new Ut(this._lodPlanes[0], e);
    this._renderer.compile(t, ka);
  }
  _sceneToCubeUV(e, t, i, n) {
    const a = new ai(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, u = h.toneMapping;
    h.getClearColor(kh), h.toneMapping = ln, h.autoClear = false;
    const f = new Fi({ name: "PMREM.Background", side: Kt, depthWrite: false, depthTest: false }), m = new Ut(new ks(), f);
    let _ = false;
    const g = e.background;
    g ? g.isColor && (f.color.copy(g), e.background = null, _ = true) : (f.color.copy(kh), _ = true);
    for (let v = 0; v < 6; v++) {
      const y = v % 3;
      y === 0 ? (a.up.set(0, l[v], 0), a.lookAt(c[v], 0, 0)) : y === 1 ? (a.up.set(0, 0, l[v]), a.lookAt(0, c[v], 0)) : (a.up.set(0, l[v], 0), a.lookAt(0, 0, c[v]));
      const x = this._cubeSize;
      ao(n, y * x, v > 2 ? x : 0, x, x), h.setRenderTarget(n), _ && h.render(m, a), h.render(e, a);
    }
    m.geometry.dispose(), m.material.dispose(), h.toneMapping = u, h.autoClear = d, e.background = g;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, n = e.mapping === As || e.mapping === Ps;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = Bh()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = zh());
    const r = n ? this._cubemapMaterial : this._equirectMaterial, o = new Ut(this._lodPlanes[0], r), a = r.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    ao(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, ka);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = false;
    const n = this._lodPlanes.length;
    for (let r = 1; r < n; r++) {
      const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = Oh[(n - r - 1) % Oh.length];
      this._blur(e, r - 1, r, o, a);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, n, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, n, "latitudinal", r), this._halfBlur(o, e, i, i, n, "longitudinal", r);
  }
  _halfBlur(e, t, i, n, r, o, a) {
    const l = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = new Ut(this._lodPlanes[n], c), u = c.uniforms, f = this._sizeLods[i] - 1, m = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Pn - 1), _ = r / m, g = isFinite(r) ? 1 + Math.floor(h * _) : Pn;
    g > Pn && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Pn}`);
    const v = [];
    let y = 0;
    for (let C = 0; C < Pn; ++C) {
      const P = C / _, z = Math.exp(-P * P / 2);
      v.push(z), C === 0 ? y += z : C < g && (y += 2 * z);
    }
    for (let C = 0; C < v.length; C++) v[C] = v[C] / y;
    u.envMap.value = e.texture, u.samples.value = g, u.weights.value = v, u.latitudinal.value = o === "latitudinal", a && (u.poleAxis.value = a);
    const { _lodMax: x } = this;
    u.dTheta.value = m, u.mipInt.value = x - i;
    const S = this._sizeLods[n], A = 3 * S * (n > x - ms ? n - x + ms : 0), R = 4 * (this._cubeSize - S);
    ao(t, A, R, 3 * S, 2 * S), l.setRenderTarget(t), l.render(d, ka);
  }
}
function y_(s) {
  const e = [], t = [], i = [];
  let n = s;
  const r = s - ms + 1 + Nh.length;
  for (let o = 0; o < r; o++) {
    const a = Math.pow(2, n);
    t.push(a);
    let l = 1 / a;
    o > s - ms ? l = Nh[o - s + ms - 1] : o === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2), h = -c, d = 1 + c, u = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, m = 6, _ = 3, g = 2, v = 1, y = new Float32Array(_ * m * f), x = new Float32Array(g * m * f), S = new Float32Array(v * m * f);
    for (let R = 0; R < f; R++) {
      const C = R % 3 * 2 / 3 - 1, P = R > 2 ? 0 : -1, z = [C, P, 0, C + 2 / 3, P, 0, C + 2 / 3, P + 1, 0, C, P, 0, C + 2 / 3, P + 1, 0, C, P + 1, 0];
      y.set(z, _ * m * R), x.set(u, g * m * R);
      const w = [R, R, R, R, R, R];
      S.set(w, v * m * R);
    }
    const A = new ft();
    A.setAttribute("position", new _i(y, _)), A.setAttribute("uv", new _i(x, g)), A.setAttribute("faceIndex", new _i(S, v)), e.push(A), n > ms && n--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function Fh(s, e, t) {
  const i = new Un(s, e, t);
  return i.texture.mapping = Qo, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
}
function ao(s, e, t, i, n) {
  s.viewport.set(e, t, i, n), s.scissor.set(e, t, i, n);
}
function S_(s, e, t) {
  const i = new Float32Array(Pn), n = new I(0, 1, 0);
  return new pn({ name: "SphericalGaussianBlur", defines: { n: Pn, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${s}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n } }, vertexShader: wc(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: an, depthTest: false, depthWrite: false });
}
function zh() {
  return new pn({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: wc(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: an, depthTest: false, depthWrite: false });
}
function Bh() {
  return new pn({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: wc(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: an, depthTest: false, depthWrite: false });
}
function wc() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function E_(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping, c = l === gl || l === vl, h = l === As || l === Ps;
      if (c || h) {
        let d = e.get(a);
        const u = d !== void 0 ? d.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== u) return t === null && (t = new Uh(s)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), d.texture.pmremVersion = a.pmremVersion, e.set(a, d), d.texture;
        if (d !== void 0) return d.texture;
        {
          const f = a.image;
          return c && f && f.height > 0 || h && f && n(f) ? (t === null && (t = new Uh(s)), d = c ? t.fromEquirectangular(a) : t.fromCubemap(a), d.texture.pmremVersion = a.pmremVersion, e.set(a, d), a.addEventListener("dispose", r), d.texture) : null;
        }
      }
    }
    return a;
  }
  function n(a) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
    return l === c;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return { get: i, dispose: o };
}
function M_(s) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = s.getExtension(i);
    }
    return e[i] = n, n;
  }
  return { has: function(i) {
    return t(i) !== null;
  }, init: function() {
    t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
  }, get: function(i) {
    const n = t(i);
    return n === null && Do("THREE.WebGLRenderer: " + i + " extension not supported."), n;
  } };
}
function C_(s, e, t, i) {
  const n = {}, r = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const u = d.target;
    u.index !== null && e.remove(u.index);
    for (const m in u.attributes) e.remove(u.attributes[m]);
    for (const m in u.morphAttributes) {
      const _ = u.morphAttributes[m];
      for (let g = 0, v = _.length; g < v; g++) e.remove(_[g]);
    }
    u.removeEventListener("dispose", o), delete n[u.id];
    const f = r.get(u);
    f && (e.remove(f), r.delete(u)), i.releaseStatesOfGeometry(u), u.isInstancedBufferGeometry === true && delete u._maxInstanceCount, t.memory.geometries--;
  }
  function a(d, u) {
    return n[u.id] === true || (u.addEventListener("dispose", o), n[u.id] = true, t.memory.geometries++), u;
  }
  function l(d) {
    const u = d.attributes;
    for (const m in u) e.update(u[m], s.ARRAY_BUFFER);
    const f = d.morphAttributes;
    for (const m in f) {
      const _ = f[m];
      for (let g = 0, v = _.length; g < v; g++) e.update(_[g], s.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const u = [], f = d.index, m = d.attributes.position;
    let _ = 0;
    if (f !== null) {
      const y = f.array;
      _ = f.version;
      for (let x = 0, S = y.length; x < S; x += 3) {
        const A = y[x + 0], R = y[x + 1], C = y[x + 2];
        u.push(A, R, R, C, C, A);
      }
    } else if (m !== void 0) {
      const y = m.array;
      _ = m.version;
      for (let x = 0, S = y.length / 3 - 1; x < S; x += 3) {
        const A = x + 0, R = x + 1, C = x + 2;
        u.push(A, R, R, C, C, A);
      }
    } else return;
    const g = new (Au(u) ? Iu : Lu)(u, 1);
    g.version = _;
    const v = r.get(d);
    v && e.remove(v), r.set(d, g);
  }
  function h(d) {
    const u = r.get(d);
    if (u) {
      const f = d.index;
      f !== null && u.version < f.version && c(d);
    } else c(d);
    return r.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function T_(s, e, t) {
  let i;
  function n(u) {
    i = u;
  }
  let r, o;
  function a(u) {
    r = u.type, o = u.bytesPerElement;
  }
  function l(u, f) {
    s.drawElements(i, f, r, u * o), t.update(f, i, 1);
  }
  function c(u, f, m) {
    m !== 0 && (s.drawElementsInstanced(i, f, r, u * o, m), t.update(f, i, m));
  }
  function h(u, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, r, u, 0, m);
    let g = 0;
    for (let v = 0; v < m; v++) g += f[v];
    t.update(g, i, 1);
  }
  function d(u, f, m, _) {
    if (m === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null) for (let v = 0; v < u.length; v++) c(u[v] / o, f[v], _[v]);
    else {
      g.multiDrawElementsInstancedWEBGL(i, f, 0, r, u, 0, _, 0, m);
      let v = 0;
      for (let y = 0; y < m; y++) v += f[y];
      for (let y = 0; y < _.length; y++) t.update(v, i, _[y]);
    }
  }
  this.setMode = n, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
}
function A_(s) {
  const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(r, o, a) {
    switch (t.calls++, o) {
      case s.TRIANGLES:
        t.triangles += a * (r / 3);
        break;
      case s.LINES:
        t.lines += a * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += a * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += a * r;
        break;
      case s.POINTS:
        t.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function n() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return { memory: e, render: t, programs: null, autoReset: true, reset: n, update: i };
}
function P_(s, e, t) {
  const i = /* @__PURE__ */ new WeakMap(), n = new xt();
  function r(o, a, l) {
    const c = o.morphTargetInfluences, h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, d = h !== void 0 ? h.length : 0;
    let u = i.get(a);
    if (u === void 0 || u.count !== d) {
      let f = function() {
        P.dispose(), i.delete(a), a.removeEventListener("dispose", f);
      };
      u !== void 0 && u.texture.dispose();
      const m = a.morphAttributes.position !== void 0, _ = a.morphAttributes.normal !== void 0, g = a.morphAttributes.color !== void 0, v = a.morphAttributes.position || [], y = a.morphAttributes.normal || [], x = a.morphAttributes.color || [];
      let S = 0;
      m === true && (S = 1), _ === true && (S = 2), g === true && (S = 3);
      let A = a.attributes.position.count * S, R = 1;
      A > e.maxTextureSize && (R = Math.ceil(A / e.maxTextureSize), A = e.maxTextureSize);
      const C = new Float32Array(A * R * 4 * d), P = new Ru(C, A, R, d);
      P.type = Ni, P.needsUpdate = true;
      const z = S * 4;
      for (let w = 0; w < d; w++) {
        const E = v[w], N = y[w], k = x[w], V = A * R * 4 * w;
        for (let q = 0; q < E.count; q++) {
          const G = q * z;
          m === true && (n.fromBufferAttribute(E, q), C[V + G + 0] = n.x, C[V + G + 1] = n.y, C[V + G + 2] = n.z, C[V + G + 3] = 0), _ === true && (n.fromBufferAttribute(N, q), C[V + G + 4] = n.x, C[V + G + 5] = n.y, C[V + G + 6] = n.z, C[V + G + 7] = 0), g === true && (n.fromBufferAttribute(k, q), C[V + G + 8] = n.x, C[V + G + 9] = n.y, C[V + G + 10] = n.z, C[V + G + 11] = k.itemSize === 4 ? n.w : 1);
        }
      }
      u = { count: d, texture: P, size: new re(A, R) }, i.set(a, u), a.addEventListener("dispose", f);
    }
    if (o.isInstancedMesh === true && o.morphTexture !== null) l.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
    else {
      let f = 0;
      for (let _ = 0; _ < c.length; _++) f += c[_];
      const m = a.morphTargetsRelative ? 1 : 1 - f;
      l.getUniforms().setValue(s, "morphTargetBaseInfluence", m), l.getUniforms().setValue(s, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(s, "morphTargetsTexture", u.texture, t), l.getUniforms().setValue(s, "morphTargetsTextureSize", u.size);
  }
  return { update: r };
}
function R_(s, e, t, i) {
  let n = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = i.render.frame, h = l.geometry, d = e.get(l, h);
    if (n.get(d) !== c && (e.update(d), n.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === false && l.addEventListener("dispose", a), n.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), n.set(l, c))), l.isSkinnedMesh) {
      const u = l.skeleton;
      n.get(u) !== c && (u.update(), n.set(u, c));
    }
    return d;
  }
  function o() {
    n = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: r, dispose: o };
}
class zu extends Vt {
  constructor(e, t, i, n, r, o, a, l, c, h = xs) {
    if (h !== xs && h !== Ds) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === xs && (i = On), i === void 0 && h === Ds && (i = Rs), super(null, n, r, o, a, l, h, i, c), this.isDepthTexture = true, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : ci, this.minFilter = l !== void 0 ? l : ci, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const Bu = new Vt(), Vh = new zu(1, 1), Vu = new Ru(), Hu = new gm(), Gu = new Ou(), Hh = [], Gh = [], $h = new Float32Array(16), Wh = new Float32Array(9), Xh = new Float32Array(4);
function Os(s, e, t) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const n = e * t;
  let r = Hh[n];
  if (r === void 0 && (r = new Float32Array(n), Hh[n] = r), e !== 0) {
    i.toArray(r, 0);
    for (let o = 1, a = 0; o !== e; ++o) a += t, s[o].toArray(r, a);
  }
  return r;
}
function At(s, e) {
  if (s.length !== e.length) return false;
  for (let t = 0, i = s.length; t < i; t++) if (s[t] !== e[t]) return false;
  return true;
}
function Pt(s, e) {
  for (let t = 0, i = e.length; t < i; t++) s[t] = e[t];
}
function ta(s, e) {
  let t = Gh[e];
  t === void 0 && (t = new Int32Array(e), Gh[e] = t);
  for (let i = 0; i !== e; ++i) t[i] = s.allocateTextureUnit();
  return t;
}
function D_(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function L_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (At(t, e)) return;
    s.uniform2fv(this.addr, e), Pt(t, e);
  }
}
function I_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (At(t, e)) return;
    s.uniform3fv(this.addr, e), Pt(t, e);
  }
}
function N_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (At(t, e)) return;
    s.uniform4fv(this.addr, e), Pt(t, e);
  }
}
function k_(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (At(t, e)) return;
    s.uniformMatrix2fv(this.addr, false, e), Pt(t, e);
  } else {
    if (At(t, i)) return;
    Xh.set(i), s.uniformMatrix2fv(this.addr, false, Xh), Pt(t, i);
  }
}
function O_(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (At(t, e)) return;
    s.uniformMatrix3fv(this.addr, false, e), Pt(t, e);
  } else {
    if (At(t, i)) return;
    Wh.set(i), s.uniformMatrix3fv(this.addr, false, Wh), Pt(t, i);
  }
}
function U_(s, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (At(t, e)) return;
    s.uniformMatrix4fv(this.addr, false, e), Pt(t, e);
  } else {
    if (At(t, i)) return;
    $h.set(i), s.uniformMatrix4fv(this.addr, false, $h), Pt(t, i);
  }
}
function F_(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function z_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (At(t, e)) return;
    s.uniform2iv(this.addr, e), Pt(t, e);
  }
}
function B_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (At(t, e)) return;
    s.uniform3iv(this.addr, e), Pt(t, e);
  }
}
function V_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (At(t, e)) return;
    s.uniform4iv(this.addr, e), Pt(t, e);
  }
}
function H_(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function G_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (At(t, e)) return;
    s.uniform2uiv(this.addr, e), Pt(t, e);
  }
}
function $_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (At(t, e)) return;
    s.uniform3uiv(this.addr, e), Pt(t, e);
  }
}
function W_(s, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (At(t, e)) return;
    s.uniform4uiv(this.addr, e), Pt(t, e);
  }
}
function X_(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n);
  let r;
  this.type === s.SAMPLER_2D_SHADOW ? (Vh.compareFunction = Tu, r = Vh) : r = Bu, t.setTexture2D(e || r, n);
}
function j_(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || Hu, n);
}
function Y_(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTextureCube(e || Gu, n);
}
function q_(s, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || Vu, n);
}
function K_(s) {
  switch (s) {
    case 5126:
      return D_;
    case 35664:
      return L_;
    case 35665:
      return I_;
    case 35666:
      return N_;
    case 35674:
      return k_;
    case 35675:
      return O_;
    case 35676:
      return U_;
    case 5124:
    case 35670:
      return F_;
    case 35667:
    case 35671:
      return z_;
    case 35668:
    case 35672:
      return B_;
    case 35669:
    case 35673:
      return V_;
    case 5125:
      return H_;
    case 36294:
      return G_;
    case 36295:
      return $_;
    case 36296:
      return W_;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return X_;
    case 35679:
    case 36299:
    case 36307:
      return j_;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Y_;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return q_;
  }
}
function Z_(s, e) {
  s.uniform1fv(this.addr, e);
}
function J_(s, e) {
  const t = Os(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function Q_(s, e) {
  const t = Os(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function e0(s, e) {
  const t = Os(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function t0(s, e) {
  const t = Os(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, false, t);
}
function i0(s, e) {
  const t = Os(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, false, t);
}
function n0(s, e) {
  const t = Os(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, false, t);
}
function s0(s, e) {
  s.uniform1iv(this.addr, e);
}
function r0(s, e) {
  s.uniform2iv(this.addr, e);
}
function o0(s, e) {
  s.uniform3iv(this.addr, e);
}
function a0(s, e) {
  s.uniform4iv(this.addr, e);
}
function l0(s, e) {
  s.uniform1uiv(this.addr, e);
}
function c0(s, e) {
  s.uniform2uiv(this.addr, e);
}
function h0(s, e) {
  s.uniform3uiv(this.addr, e);
}
function d0(s, e) {
  s.uniform4uiv(this.addr, e);
}
function u0(s, e, t) {
  const i = this.cache, n = e.length, r = ta(t, n);
  At(i, r) || (s.uniform1iv(this.addr, r), Pt(i, r));
  for (let o = 0; o !== n; ++o) t.setTexture2D(e[o] || Bu, r[o]);
}
function p0(s, e, t) {
  const i = this.cache, n = e.length, r = ta(t, n);
  At(i, r) || (s.uniform1iv(this.addr, r), Pt(i, r));
  for (let o = 0; o !== n; ++o) t.setTexture3D(e[o] || Hu, r[o]);
}
function f0(s, e, t) {
  const i = this.cache, n = e.length, r = ta(t, n);
  At(i, r) || (s.uniform1iv(this.addr, r), Pt(i, r));
  for (let o = 0; o !== n; ++o) t.setTextureCube(e[o] || Gu, r[o]);
}
function m0(s, e, t) {
  const i = this.cache, n = e.length, r = ta(t, n);
  At(i, r) || (s.uniform1iv(this.addr, r), Pt(i, r));
  for (let o = 0; o !== n; ++o) t.setTexture2DArray(e[o] || Vu, r[o]);
}
function g0(s) {
  switch (s) {
    case 5126:
      return Z_;
    case 35664:
      return J_;
    case 35665:
      return Q_;
    case 35666:
      return e0;
    case 35674:
      return t0;
    case 35675:
      return i0;
    case 35676:
      return n0;
    case 5124:
    case 35670:
      return s0;
    case 35667:
    case 35671:
      return r0;
    case 35668:
    case 35672:
      return o0;
    case 35669:
    case 35673:
      return a0;
    case 5125:
      return l0;
    case 36294:
      return c0;
    case 36295:
      return h0;
    case 36296:
      return d0;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return u0;
    case 35679:
    case 36299:
    case 36307:
      return p0;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return f0;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return m0;
  }
}
class v0 {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = K_(t.type);
  }
}
class _0 {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = g0(t.type);
  }
}
class b0 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const n = this.seq;
    for (let r = 0, o = n.length; r !== o; ++r) {
      const a = n[r];
      a.setValue(e, t[a.id], i);
    }
  }
}
const Ba = /(\w+)(\])?(\[|\.)?/g;
function jh(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function x0(s, e, t) {
  const i = s.name, n = i.length;
  for (Ba.lastIndex = 0; ; ) {
    const r = Ba.exec(i), o = Ba.lastIndex;
    let a = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === n) {
      jh(t, c === void 0 ? new v0(a, s, e) : new _0(a, s, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && (d = new b0(a), jh(t, d)), t = d;
    }
  }
}
class Lo {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; ++n) {
      const r = e.getActiveUniform(t, n), o = e.getUniformLocation(t, r.name);
      x0(r, o, this);
    }
  }
  setValue(e, t, i, n) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    const n = t[i];
    n !== void 0 && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let r = 0, o = t.length; r !== o; ++r) {
      const a = t[r], l = i[a.id];
      l.needsUpdate !== false && a.setValue(e, l.value, n);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let n = 0, r = e.length; n !== r; ++n) {
      const o = e[n];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function Yh(s, e, t) {
  const i = s.createShader(e);
  return s.shaderSource(i, t), s.compileShader(i), i;
}
const w0 = 37297;
let y0 = 0;
function S0(s, e) {
  const t = s.split(`
`), i = [], n = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let o = n; o < r; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function E0(s) {
  const e = it.getPrimaries(it.workingColorSpace), t = it.getPrimaries(s);
  let i;
  switch (e === t ? i = "" : e === Bo && t === zo ? i = "LinearDisplayP3ToLinearSRGB" : e === zo && t === Bo && (i = "LinearSRGBToLinearDisplayP3"), s) {
    case gn:
    case ea:
      return [i, "LinearTransferOETF"];
    case bi:
    case _c:
      return [i, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [i, "LinearTransferOETF"];
  }
}
function qh(s, e, t) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), n = s.getShaderInfoLog(e).trim();
  if (i && n === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(n);
  if (r) {
    const o = parseInt(r[1]);
    return t.toUpperCase() + `

` + n + `

` + S0(s.getShaderSource(e), o);
  } else return n;
}
function M0(s, e) {
  const t = E0(e);
  return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function C0(s, e) {
  let t;
  switch (e) {
    case Vf:
      t = "Linear";
      break;
    case Hf:
      t = "Reinhard";
      break;
    case Gf:
      t = "Cineon";
      break;
    case $f:
      t = "ACESFilmic";
      break;
    case Xf:
      t = "AgX";
      break;
    case jf:
      t = "Neutral";
      break;
    case Wf:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const lo = new I();
function T0() {
  it.getLuminanceCoefficients(lo);
  const s = lo.x.toFixed(4), e = lo.y.toFixed(4), t = lo.z.toFixed(4);
  return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`);
}
function A0(s) {
  return [s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(nr).join(`
`);
}
function P0(s) {
  const e = [];
  for (const t in s) {
    const i = s[t];
    i !== false && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function R0(s, e) {
  const t = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let n = 0; n < i; n++) {
    const r = s.getActiveAttrib(e, n), o = r.name;
    let a = 1;
    r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = { type: r.type, location: s.getAttribLocation(e, o), locationSize: a };
  }
  return t;
}
function nr(s) {
  return s !== "";
}
function Kh(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Zh(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const D0 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Yl(s) {
  return s.replace(D0, I0);
}
const L0 = /* @__PURE__ */ new Map();
function I0(s, e) {
  let t = He[e];
  if (t === void 0) {
    const i = L0.get(e);
    if (i !== void 0) t = He[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return Yl(t);
}
const N0 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Jh(s) {
  return s.replace(N0, k0);
}
function k0(s, e, t, i) {
  let n = "";
  for (let r = parseInt(e); r < parseInt(t); r++) n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return n;
}
function Qh(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function O0(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === fu ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === xf ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Ii && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function U0(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap) switch (s.envMapMode) {
    case As:
    case Ps:
      e = "ENVMAP_TYPE_CUBE";
      break;
    case Qo:
      e = "ENVMAP_TYPE_CUBE_UV";
      break;
  }
  return e;
}
function F0(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap) switch (s.envMapMode) {
    case Ps:
      e = "ENVMAP_MODE_REFRACTION";
      break;
  }
  return e;
}
function z0(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap) switch (s.combine) {
    case dc:
      e = "ENVMAP_BLENDING_MULTIPLY";
      break;
    case zf:
      e = "ENVMAP_BLENDING_MIX";
      break;
    case Bf:
      e = "ENVMAP_BLENDING_ADD";
      break;
  }
  return e;
}
function B0(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function V0(s, e, t, i) {
  const n = s.getContext(), r = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const l = O0(t), c = U0(t), h = F0(t), d = z0(t), u = B0(t), f = A0(t), m = P0(r), _ = n.createProgram();
  let g, v, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(nr).join(`
`), g.length > 0 && (g += `
`), v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(nr).join(`
`), v.length > 0 && (v += `
`)) : (g = [Qh(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(nr).join(`
`), v = [Qh(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== ln ? "#define TONE_MAPPING" : "", t.toneMapping !== ln ? He.tonemapping_pars_fragment : "", t.toneMapping !== ln ? C0("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", He.colorspace_pars_fragment, M0("linearToOutputTexel", t.outputColorSpace), T0(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(nr).join(`
`)), o = Yl(o), o = Kh(o, t), o = Zh(o, t), a = Yl(a), a = Kh(a, t), a = Zh(a, t), o = Jh(o), a = Jh(a), t.isRawShaderMaterial !== true && (y = `#version 300 es
`, g = [f, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g, v = ["#define varying in", t.glslVersion === gh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === gh ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + v);
  const x = y + g + o, S = y + v + a, A = Yh(n, n.VERTEX_SHADER, x), R = Yh(n, n.FRAGMENT_SHADER, S);
  n.attachShader(_, A), n.attachShader(_, R), t.index0AttributeName !== void 0 ? n.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === true && n.bindAttribLocation(_, 0, "position"), n.linkProgram(_);
  function C(E) {
    if (s.debug.checkShaderErrors) {
      const N = n.getProgramInfoLog(_).trim(), k = n.getShaderInfoLog(A).trim(), V = n.getShaderInfoLog(R).trim();
      let q = true, G = true;
      if (n.getProgramParameter(_, n.LINK_STATUS) === false) if (q = false, typeof s.debug.onShaderError == "function") s.debug.onShaderError(n, _, A, R);
      else {
        const ee = qh(n, A, "vertex"), O = qh(n, R, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(_, n.VALIDATE_STATUS) + `

Material Name: ` + E.name + `
Material Type: ` + E.type + `

Program Info Log: ` + N + `
` + ee + `
` + O);
      }
      else N !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", N) : (k === "" || V === "") && (G = false);
      G && (E.diagnostics = { runnable: q, programLog: N, vertexShader: { log: k, prefix: g }, fragmentShader: { log: V, prefix: v } });
    }
    n.deleteShader(A), n.deleteShader(R), P = new Lo(n, _), z = R0(n, _);
  }
  let P;
  this.getUniforms = function() {
    return P === void 0 && C(this), P;
  };
  let z;
  this.getAttributes = function() {
    return z === void 0 && C(this), z;
  };
  let w = t.rendererExtensionParallelShaderCompile === false;
  return this.isReady = function() {
    return w === false && (w = n.getProgramParameter(_, w0)), w;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), n.deleteProgram(_), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = y0++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = A, this.fragmentShader = R, this;
}
let H0 = 0;
class G0 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), r = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e);
    return o.has(n) === false && (o.add(n), n.usedTimes++), o.has(r) === false && (o.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new $0(e), t.set(e, i)), i;
  }
}
class $0 {
  constructor(e) {
    this.id = H0++, this.code = e, this.usedTimes = 0;
  }
}
function W0(s, e, t, i, n, r, o) {
  const a = new bc(), l = new G0(), c = /* @__PURE__ */ new Set(), h = [], d = n.logarithmicDepthBuffer, u = n.reverseDepthBuffer, f = n.vertexTextures;
  let m = n.precision;
  const _ = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function g(w) {
    return c.add(w), w === 0 ? "uv" : `uv${w}`;
  }
  function v(w, E, N, k, V) {
    const q = k.fog, G = V.geometry, ee = w.isMeshStandardMaterial ? k.environment : null, O = (w.isMeshStandardMaterial ? t : e).get(w.envMap || ee), Q = O && O.mapping === Qo ? O.image.height : null, X = _[w.type];
    w.precision !== null && (m = n.getMaxPrecision(w.precision), m !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", m, "instead."));
    const K = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color, Le = K !== void 0 ? K.length : 0;
    let Re = 0;
    G.morphAttributes.position !== void 0 && (Re = 1), G.morphAttributes.normal !== void 0 && (Re = 2), G.morphAttributes.color !== void 0 && (Re = 3);
    let Y, se, me, de;
    if (X) {
      const Wt = xi[X];
      Y = Wt.vertexShader, se = Wt.fragmentShader;
    } else Y = w.vertexShader, se = w.fragmentShader, l.update(w), me = l.getVertexShaderID(w), de = l.getFragmentShaderID(w);
    const Ne = s.getRenderTarget(), Ie = V.isInstancedMesh === true, ze = V.isBatchedMesh === true, We = !!w.map, te = !!w.matcap, L = !!O, he = !!w.aoMap, ce = !!w.lightMap, oe = !!w.bumpMap, ue = !!w.normalMap, Ae = !!w.displacementMap, _e = !!w.emissiveMap, D = !!w.metalnessMap, M = !!w.roughnessMap, H = w.anisotropy > 0, Z = w.clearcoat > 0, ie = w.dispersion > 0, J = w.iridescence > 0, Me = w.sheen > 0, pe = w.transmission > 0, we = H && !!w.anisotropyMap, je = Z && !!w.clearcoatMap, ae = Z && !!w.clearcoatNormalMap, ye = Z && !!w.clearcoatRoughnessMap, Ue = J && !!w.iridescenceMap, Fe = J && !!w.iridescenceThicknessMap, Se = Me && !!w.sheenColorMap, Ye = Me && !!w.sheenRoughnessMap, Ve = !!w.specularMap, ct = !!w.specularColorMap, U = !!w.specularIntensityMap, be = pe && !!w.transmissionMap, j = pe && !!w.thicknessMap, ne = !!w.gradientMap, ge = !!w.alphaMap, xe = w.alphaTest > 0, Ke = !!w.alphaHash, St = !!w.extensions;
    let $t = ln;
    w.toneMapped && (Ne === null || Ne.isXRRenderTarget === true) && ($t = s.toneMapping);
    const Qe = { shaderID: X, shaderType: w.type, shaderName: w.name, vertexShader: Y, fragmentShader: se, defines: w.defines, customVertexShaderID: me, customFragmentShaderID: de, isRawShaderMaterial: w.isRawShaderMaterial === true, glslVersion: w.glslVersion, precision: m, batching: ze, batchingColor: ze && V._colorsTexture !== null, instancing: Ie, instancingColor: Ie && V.instanceColor !== null, instancingMorph: Ie && V.morphTexture !== null, supportsVertexTextures: f, outputColorSpace: Ne === null ? s.outputColorSpace : Ne.isXRRenderTarget === true ? Ne.texture.colorSpace : gn, alphaToCoverage: !!w.alphaToCoverage, map: We, matcap: te, envMap: L, envMapMode: L && O.mapping, envMapCubeUVHeight: Q, aoMap: he, lightMap: ce, bumpMap: oe, normalMap: ue, displacementMap: f && Ae, emissiveMap: _e, normalMapObjectSpace: ue && w.normalMapType === Zf, normalMapTangentSpace: ue && w.normalMapType === Cu, metalnessMap: D, roughnessMap: M, anisotropy: H, anisotropyMap: we, clearcoat: Z, clearcoatMap: je, clearcoatNormalMap: ae, clearcoatRoughnessMap: ye, dispersion: ie, iridescence: J, iridescenceMap: Ue, iridescenceThicknessMap: Fe, sheen: Me, sheenColorMap: Se, sheenRoughnessMap: Ye, specularMap: Ve, specularColorMap: ct, specularIntensityMap: U, transmission: pe, transmissionMap: be, thicknessMap: j, gradientMap: ne, opaque: w.transparent === false && w.blending === bs && w.alphaToCoverage === false, alphaMap: ge, alphaTest: xe, alphaHash: Ke, combine: w.combine, mapUv: We && g(w.map.channel), aoMapUv: he && g(w.aoMap.channel), lightMapUv: ce && g(w.lightMap.channel), bumpMapUv: oe && g(w.bumpMap.channel), normalMapUv: ue && g(w.normalMap.channel), displacementMapUv: Ae && g(w.displacementMap.channel), emissiveMapUv: _e && g(w.emissiveMap.channel), metalnessMapUv: D && g(w.metalnessMap.channel), roughnessMapUv: M && g(w.roughnessMap.channel), anisotropyMapUv: we && g(w.anisotropyMap.channel), clearcoatMapUv: je && g(w.clearcoatMap.channel), clearcoatNormalMapUv: ae && g(w.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ye && g(w.clearcoatRoughnessMap.channel), iridescenceMapUv: Ue && g(w.iridescenceMap.channel), iridescenceThicknessMapUv: Fe && g(w.iridescenceThicknessMap.channel), sheenColorMapUv: Se && g(w.sheenColorMap.channel), sheenRoughnessMapUv: Ye && g(w.sheenRoughnessMap.channel), specularMapUv: Ve && g(w.specularMap.channel), specularColorMapUv: ct && g(w.specularColorMap.channel), specularIntensityMapUv: U && g(w.specularIntensityMap.channel), transmissionMapUv: be && g(w.transmissionMap.channel), thicknessMapUv: j && g(w.thicknessMap.channel), alphaMapUv: ge && g(w.alphaMap.channel), vertexTangents: !!G.attributes.tangent && (ue || H), vertexColors: w.vertexColors, vertexAlphas: w.vertexColors === true && !!G.attributes.color && G.attributes.color.itemSize === 4, pointsUvs: V.isPoints === true && !!G.attributes.uv && (We || ge), fog: !!q, useFog: w.fog === true, fogExp2: !!q && q.isFogExp2, flatShading: w.flatShading === true, sizeAttenuation: w.sizeAttenuation === true, logarithmicDepthBuffer: d, reverseDepthBuffer: u, skinning: V.isSkinnedMesh === true, morphTargets: G.morphAttributes.position !== void 0, morphNormals: G.morphAttributes.normal !== void 0, morphColors: G.morphAttributes.color !== void 0, morphTargetsCount: Le, morphTextureStride: Re, numDirLights: E.directional.length, numPointLights: E.point.length, numSpotLights: E.spot.length, numSpotLightMaps: E.spotLightMap.length, numRectAreaLights: E.rectArea.length, numHemiLights: E.hemi.length, numDirLightShadows: E.directionalShadowMap.length, numPointLightShadows: E.pointShadowMap.length, numSpotLightShadows: E.spotShadowMap.length, numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps, numLightProbes: E.numLightProbes, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: w.dithering, shadowMapEnabled: s.shadowMap.enabled && N.length > 0, shadowMapType: s.shadowMap.type, toneMapping: $t, decodeVideoTexture: We && w.map.isVideoTexture === true && it.getTransfer(w.map.colorSpace) === pt, premultipliedAlpha: w.premultipliedAlpha, doubleSided: w.side === Yt, flipSided: w.side === Kt, useDepthPacking: w.depthPacking >= 0, depthPacking: w.depthPacking || 0, index0AttributeName: w.index0AttributeName, extensionClipCullDistance: St && w.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (St && w.extensions.multiDraw === true || ze) && i.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"), customProgramCacheKey: w.customProgramCacheKey() };
    return Qe.vertexUv1s = c.has(1), Qe.vertexUv2s = c.has(2), Qe.vertexUv3s = c.has(3), c.clear(), Qe;
  }
  function y(w) {
    const E = [];
    if (w.shaderID ? E.push(w.shaderID) : (E.push(w.customVertexShaderID), E.push(w.customFragmentShaderID)), w.defines !== void 0) for (const N in w.defines) E.push(N), E.push(w.defines[N]);
    return w.isRawShaderMaterial === false && (x(E, w), S(E, w), E.push(s.outputColorSpace)), E.push(w.customProgramCacheKey), E.join();
  }
  function x(w, E) {
    w.push(E.precision), w.push(E.outputColorSpace), w.push(E.envMapMode), w.push(E.envMapCubeUVHeight), w.push(E.mapUv), w.push(E.alphaMapUv), w.push(E.lightMapUv), w.push(E.aoMapUv), w.push(E.bumpMapUv), w.push(E.normalMapUv), w.push(E.displacementMapUv), w.push(E.emissiveMapUv), w.push(E.metalnessMapUv), w.push(E.roughnessMapUv), w.push(E.anisotropyMapUv), w.push(E.clearcoatMapUv), w.push(E.clearcoatNormalMapUv), w.push(E.clearcoatRoughnessMapUv), w.push(E.iridescenceMapUv), w.push(E.iridescenceThicknessMapUv), w.push(E.sheenColorMapUv), w.push(E.sheenRoughnessMapUv), w.push(E.specularMapUv), w.push(E.specularColorMapUv), w.push(E.specularIntensityMapUv), w.push(E.transmissionMapUv), w.push(E.thicknessMapUv), w.push(E.combine), w.push(E.fogExp2), w.push(E.sizeAttenuation), w.push(E.morphTargetsCount), w.push(E.morphAttributeCount), w.push(E.numDirLights), w.push(E.numPointLights), w.push(E.numSpotLights), w.push(E.numSpotLightMaps), w.push(E.numHemiLights), w.push(E.numRectAreaLights), w.push(E.numDirLightShadows), w.push(E.numPointLightShadows), w.push(E.numSpotLightShadows), w.push(E.numSpotLightShadowsWithMaps), w.push(E.numLightProbes), w.push(E.shadowMapType), w.push(E.toneMapping), w.push(E.numClippingPlanes), w.push(E.numClipIntersection), w.push(E.depthPacking);
  }
  function S(w, E) {
    a.disableAll(), E.supportsVertexTextures && a.enable(0), E.instancing && a.enable(1), E.instancingColor && a.enable(2), E.instancingMorph && a.enable(3), E.matcap && a.enable(4), E.envMap && a.enable(5), E.normalMapObjectSpace && a.enable(6), E.normalMapTangentSpace && a.enable(7), E.clearcoat && a.enable(8), E.iridescence && a.enable(9), E.alphaTest && a.enable(10), E.vertexColors && a.enable(11), E.vertexAlphas && a.enable(12), E.vertexUv1s && a.enable(13), E.vertexUv2s && a.enable(14), E.vertexUv3s && a.enable(15), E.vertexTangents && a.enable(16), E.anisotropy && a.enable(17), E.alphaHash && a.enable(18), E.batching && a.enable(19), E.dispersion && a.enable(20), E.batchingColor && a.enable(21), w.push(a.mask), a.disableAll(), E.fog && a.enable(0), E.useFog && a.enable(1), E.flatShading && a.enable(2), E.logarithmicDepthBuffer && a.enable(3), E.reverseDepthBuffer && a.enable(4), E.skinning && a.enable(5), E.morphTargets && a.enable(6), E.morphNormals && a.enable(7), E.morphColors && a.enable(8), E.premultipliedAlpha && a.enable(9), E.shadowMapEnabled && a.enable(10), E.doubleSided && a.enable(11), E.flipSided && a.enable(12), E.useDepthPacking && a.enable(13), E.dithering && a.enable(14), E.transmission && a.enable(15), E.sheen && a.enable(16), E.opaque && a.enable(17), E.pointsUvs && a.enable(18), E.decodeVideoTexture && a.enable(19), E.alphaToCoverage && a.enable(20), w.push(a.mask);
  }
  function A(w) {
    const E = _[w.type];
    let N;
    if (E) {
      const k = xi[E];
      N = Am.clone(k.uniforms);
    } else N = w.uniforms;
    return N;
  }
  function R(w, E) {
    let N;
    for (let k = 0, V = h.length; k < V; k++) {
      const q = h[k];
      if (q.cacheKey === E) {
        N = q, ++N.usedTimes;
        break;
      }
    }
    return N === void 0 && (N = new V0(s, E, w, r), h.push(N)), N;
  }
  function C(w) {
    if (--w.usedTimes === 0) {
      const E = h.indexOf(w);
      h[E] = h[h.length - 1], h.pop(), w.destroy();
    }
  }
  function P(w) {
    l.remove(w);
  }
  function z() {
    l.dispose();
  }
  return { getParameters: v, getProgramCacheKey: y, getUniforms: A, acquireProgram: R, releaseProgram: C, releaseShaderCache: P, programs: h, dispose: z };
}
function X0() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return s.has(o);
  }
  function t(o) {
    let a = s.get(o);
    return a === void 0 && (a = {}, s.set(o, a)), a;
  }
  function i(o) {
    s.delete(o);
  }
  function n(o, a, l) {
    s.get(o)[a] = l;
  }
  function r() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return { has: e, get: t, remove: i, update: n, dispose: r };
}
function j0(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function ed(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function td() {
  const s = [];
  let e = 0;
  const t = [], i = [], n = [];
  function r() {
    e = 0, t.length = 0, i.length = 0, n.length = 0;
  }
  function o(d, u, f, m, _, g) {
    let v = s[e];
    return v === void 0 ? (v = { id: d.id, object: d, geometry: u, material: f, groupOrder: m, renderOrder: d.renderOrder, z: _, group: g }, s[e] = v) : (v.id = d.id, v.object = d, v.geometry = u, v.material = f, v.groupOrder = m, v.renderOrder = d.renderOrder, v.z = _, v.group = g), e++, v;
  }
  function a(d, u, f, m, _, g) {
    const v = o(d, u, f, m, _, g);
    f.transmission > 0 ? i.push(v) : f.transparent === true ? n.push(v) : t.push(v);
  }
  function l(d, u, f, m, _, g) {
    const v = o(d, u, f, m, _, g);
    f.transmission > 0 ? i.unshift(v) : f.transparent === true ? n.unshift(v) : t.unshift(v);
  }
  function c(d, u) {
    t.length > 1 && t.sort(d || j0), i.length > 1 && i.sort(u || ed), n.length > 1 && n.sort(u || ed);
  }
  function h() {
    for (let d = e, u = s.length; d < u; d++) {
      const f = s[d];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return { opaque: t, transmissive: i, transparent: n, init: r, push: a, unshift: l, finish: h, sort: c };
}
function Y0() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, n) {
    const r = s.get(i);
    let o;
    return r === void 0 ? (o = new td(), s.set(i, [o])) : n >= r.length ? (o = new td(), r.push(o)) : o = r[n], o;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, dispose: t };
}
function q0() {
  const s = {};
  return { get: function(e) {
    if (s[e.id] !== void 0) return s[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { direction: new I(), color: new Xe() };
        break;
      case "SpotLight":
        t = { position: new I(), direction: new I(), color: new Xe(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        t = { position: new I(), color: new Xe(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        t = { direction: new I(), skyColor: new Xe(), groundColor: new Xe() };
        break;
      case "RectAreaLight":
        t = { color: new Xe(), position: new I(), halfWidth: new I(), halfHeight: new I() };
        break;
    }
    return s[e.id] = t, t;
  } };
}
function K0() {
  const s = {};
  return { get: function(e) {
    if (s[e.id] !== void 0) return s[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new re() };
        break;
      case "SpotLight":
        t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new re() };
        break;
      case "PointLight":
        t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new re(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        break;
    }
    return s[e.id] = t, t;
  } };
}
let Z0 = 0;
function J0(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function Q0(s) {
  const e = new q0(), t = K0(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
  for (let c = 0; c < 9; c++) i.probe.push(new I());
  const n = new I(), r = new rt(), o = new rt();
  function a(c) {
    let h = 0, d = 0, u = 0;
    for (let z = 0; z < 9; z++) i.probe[z].set(0, 0, 0);
    let f = 0, m = 0, _ = 0, g = 0, v = 0, y = 0, x = 0, S = 0, A = 0, R = 0, C = 0;
    c.sort(J0);
    for (let z = 0, w = c.length; z < w; z++) {
      const E = c[z], N = E.color, k = E.intensity, V = E.distance, q = E.shadow && E.shadow.map ? E.shadow.map.texture : null;
      if (E.isAmbientLight) h += N.r * k, d += N.g * k, u += N.b * k;
      else if (E.isLightProbe) {
        for (let G = 0; G < 9; G++) i.probe[G].addScaledVector(E.sh.coefficients[G], k);
        C++;
      } else if (E.isDirectionalLight) {
        const G = e.get(E);
        if (G.color.copy(E.color).multiplyScalar(E.intensity), E.castShadow) {
          const ee = E.shadow, O = t.get(E);
          O.shadowIntensity = ee.intensity, O.shadowBias = ee.bias, O.shadowNormalBias = ee.normalBias, O.shadowRadius = ee.radius, O.shadowMapSize = ee.mapSize, i.directionalShadow[f] = O, i.directionalShadowMap[f] = q, i.directionalShadowMatrix[f] = E.shadow.matrix, y++;
        }
        i.directional[f] = G, f++;
      } else if (E.isSpotLight) {
        const G = e.get(E);
        G.position.setFromMatrixPosition(E.matrixWorld), G.color.copy(N).multiplyScalar(k), G.distance = V, G.coneCos = Math.cos(E.angle), G.penumbraCos = Math.cos(E.angle * (1 - E.penumbra)), G.decay = E.decay, i.spot[_] = G;
        const ee = E.shadow;
        if (E.map && (i.spotLightMap[A] = E.map, A++, ee.updateMatrices(E), E.castShadow && R++), i.spotLightMatrix[_] = ee.matrix, E.castShadow) {
          const O = t.get(E);
          O.shadowIntensity = ee.intensity, O.shadowBias = ee.bias, O.shadowNormalBias = ee.normalBias, O.shadowRadius = ee.radius, O.shadowMapSize = ee.mapSize, i.spotShadow[_] = O, i.spotShadowMap[_] = q, S++;
        }
        _++;
      } else if (E.isRectAreaLight) {
        const G = e.get(E);
        G.color.copy(N).multiplyScalar(k), G.halfWidth.set(E.width * 0.5, 0, 0), G.halfHeight.set(0, E.height * 0.5, 0), i.rectArea[g] = G, g++;
      } else if (E.isPointLight) {
        const G = e.get(E);
        if (G.color.copy(E.color).multiplyScalar(E.intensity), G.distance = E.distance, G.decay = E.decay, E.castShadow) {
          const ee = E.shadow, O = t.get(E);
          O.shadowIntensity = ee.intensity, O.shadowBias = ee.bias, O.shadowNormalBias = ee.normalBias, O.shadowRadius = ee.radius, O.shadowMapSize = ee.mapSize, O.shadowCameraNear = ee.camera.near, O.shadowCameraFar = ee.camera.far, i.pointShadow[m] = O, i.pointShadowMap[m] = q, i.pointShadowMatrix[m] = E.shadow.matrix, x++;
        }
        i.point[m] = G, m++;
      } else if (E.isHemisphereLight) {
        const G = e.get(E);
        G.skyColor.copy(E.color).multiplyScalar(k), G.groundColor.copy(E.groundColor).multiplyScalar(k), i.hemi[v] = G, v++;
      }
    }
    g > 0 && (s.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = fe.LTC_FLOAT_1, i.rectAreaLTC2 = fe.LTC_FLOAT_2) : (i.rectAreaLTC1 = fe.LTC_HALF_1, i.rectAreaLTC2 = fe.LTC_HALF_2)), i.ambient[0] = h, i.ambient[1] = d, i.ambient[2] = u;
    const P = i.hash;
    (P.directionalLength !== f || P.pointLength !== m || P.spotLength !== _ || P.rectAreaLength !== g || P.hemiLength !== v || P.numDirectionalShadows !== y || P.numPointShadows !== x || P.numSpotShadows !== S || P.numSpotMaps !== A || P.numLightProbes !== C) && (i.directional.length = f, i.spot.length = _, i.rectArea.length = g, i.point.length = m, i.hemi.length = v, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = x, i.pointShadowMap.length = x, i.spotShadow.length = S, i.spotShadowMap.length = S, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = x, i.spotLightMatrix.length = S + A - R, i.spotLightMap.length = A, i.numSpotLightShadowsWithMaps = R, i.numLightProbes = C, P.directionalLength = f, P.pointLength = m, P.spotLength = _, P.rectAreaLength = g, P.hemiLength = v, P.numDirectionalShadows = y, P.numPointShadows = x, P.numSpotShadows = S, P.numSpotMaps = A, P.numLightProbes = C, i.version = Z0++);
  }
  function l(c, h) {
    let d = 0, u = 0, f = 0, m = 0, _ = 0;
    const g = h.matrixWorldInverse;
    for (let v = 0, y = c.length; v < y; v++) {
      const x = c[v];
      if (x.isDirectionalLight) {
        const S = i.directional[d];
        S.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(g), d++;
      } else if (x.isSpotLight) {
        const S = i.spot[f];
        S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(g), S.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(g), f++;
      } else if (x.isRectAreaLight) {
        const S = i.rectArea[m];
        S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(g), o.identity(), r.copy(x.matrixWorld), r.premultiply(g), o.extractRotation(r), S.halfWidth.set(x.width * 0.5, 0, 0), S.halfHeight.set(0, x.height * 0.5, 0), S.halfWidth.applyMatrix4(o), S.halfHeight.applyMatrix4(o), m++;
      } else if (x.isPointLight) {
        const S = i.point[u];
        S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(g), u++;
      } else if (x.isHemisphereLight) {
        const S = i.hemi[_];
        S.direction.setFromMatrixPosition(x.matrixWorld), S.direction.transformDirection(g), _++;
      }
    }
  }
  return { setup: a, setupView: l, state: i };
}
function id(s) {
  const e = new Q0(s), t = [], i = [];
  function n(h) {
    c.camera = h, t.length = 0, i.length = 0;
  }
  function r(h) {
    t.push(h);
  }
  function o(h) {
    i.push(h);
  }
  function a() {
    e.setup(t);
  }
  function l(h) {
    e.setupView(t, h);
  }
  const c = { lightsArray: t, shadowsArray: i, camera: null, lights: e, transmissionRenderTarget: {} };
  return { init: n, state: c, setupLights: a, setupLightsView: l, pushLight: r, pushShadow: o };
}
function eb(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(n, r = 0) {
    const o = e.get(n);
    let a;
    return o === void 0 ? (a = new id(s), e.set(n, [a])) : r >= o.length ? (a = new id(s), o.push(a)) : a = o[r], a;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return { get: t, dispose: i };
}
class tb extends vn {
  constructor(e) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = qf, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class ib extends vn {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const nb = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, sb = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function rb(s, e, t) {
  let i = new xc();
  const n = new re(), r = new re(), o = new xt(), a = new tb({ depthPacking: Kf }), l = new ib(), c = {}, h = t.maxTextureSize, d = { [dn]: Kt, [Kt]: dn, [Yt]: Yt }, u = new pn({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new re() }, radius: { value: 4 } }, vertexShader: nb, fragmentShader: sb }), f = u.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new ft();
  m.setAttribute("position", new _i(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const _ = new Ut(m, u), g = this;
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = fu;
  let v = this.type;
  this.render = function(R, C, P) {
    if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || R.length === 0) return;
    const z = s.getRenderTarget(), w = s.getActiveCubeFace(), E = s.getActiveMipmapLevel(), N = s.state;
    N.setBlending(an), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(true), N.setScissorTest(false);
    const k = v !== Ii && this.type === Ii, V = v === Ii && this.type !== Ii;
    for (let q = 0, G = R.length; q < G; q++) {
      const ee = R[q], O = ee.shadow;
      if (O === void 0) {
        console.warn("THREE.WebGLShadowMap:", ee, "has no shadow.");
        continue;
      }
      if (O.autoUpdate === false && O.needsUpdate === false) continue;
      n.copy(O.mapSize);
      const Q = O.getFrameExtents();
      if (n.multiply(Q), r.copy(O.mapSize), (n.x > h || n.y > h) && (n.x > h && (r.x = Math.floor(h / Q.x), n.x = r.x * Q.x, O.mapSize.x = r.x), n.y > h && (r.y = Math.floor(h / Q.y), n.y = r.y * Q.y, O.mapSize.y = r.y)), O.map === null || k === true || V === true) {
        const K = this.type !== Ii ? { minFilter: ci, magFilter: ci } : {};
        O.map !== null && O.map.dispose(), O.map = new Un(n.x, n.y, K), O.map.texture.name = ee.name + ".shadowMap", O.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(O.map), s.clear();
      const X = O.getViewportCount();
      for (let K = 0; K < X; K++) {
        const Le = O.getViewport(K);
        o.set(r.x * Le.x, r.y * Le.y, r.x * Le.z, r.y * Le.w), N.viewport(o), O.updateMatrices(ee, K), i = O.getFrustum(), S(C, P, O.camera, ee, this.type);
      }
      O.isPointLightShadow !== true && this.type === Ii && y(O, P), O.needsUpdate = false;
    }
    v = this.type, g.needsUpdate = false, s.setRenderTarget(z, w, E);
  };
  function y(R, C) {
    const P = e.update(_);
    u.defines.VSM_SAMPLES !== R.blurSamples && (u.defines.VSM_SAMPLES = R.blurSamples, f.defines.VSM_SAMPLES = R.blurSamples, u.needsUpdate = true, f.needsUpdate = true), R.mapPass === null && (R.mapPass = new Un(n.x, n.y)), u.uniforms.shadow_pass.value = R.map.texture, u.uniforms.resolution.value = R.mapSize, u.uniforms.radius.value = R.radius, s.setRenderTarget(R.mapPass), s.clear(), s.renderBufferDirect(C, null, P, u, _, null), f.uniforms.shadow_pass.value = R.mapPass.texture, f.uniforms.resolution.value = R.mapSize, f.uniforms.radius.value = R.radius, s.setRenderTarget(R.map), s.clear(), s.renderBufferDirect(C, null, P, f, _, null);
  }
  function x(R, C, P, z) {
    let w = null;
    const E = P.isPointLight === true ? R.customDistanceMaterial : R.customDepthMaterial;
    if (E !== void 0) w = E;
    else if (w = P.isPointLight === true ? l : a, s.localClippingEnabled && C.clipShadows === true && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0) {
      const N = w.uuid, k = C.uuid;
      let V = c[N];
      V === void 0 && (V = {}, c[N] = V);
      let q = V[k];
      q === void 0 && (q = w.clone(), V[k] = q, C.addEventListener("dispose", A)), w = q;
    }
    if (w.visible = C.visible, w.wireframe = C.wireframe, z === Ii ? w.side = C.shadowSide !== null ? C.shadowSide : C.side : w.side = C.shadowSide !== null ? C.shadowSide : d[C.side], w.alphaMap = C.alphaMap, w.alphaTest = C.alphaTest, w.map = C.map, w.clipShadows = C.clipShadows, w.clippingPlanes = C.clippingPlanes, w.clipIntersection = C.clipIntersection, w.displacementMap = C.displacementMap, w.displacementScale = C.displacementScale, w.displacementBias = C.displacementBias, w.wireframeLinewidth = C.wireframeLinewidth, w.linewidth = C.linewidth, P.isPointLight === true && w.isMeshDistanceMaterial === true) {
      const N = s.properties.get(w);
      N.light = P;
    }
    return w;
  }
  function S(R, C, P, z, w) {
    if (R.visible === false) return;
    if (R.layers.test(C.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && w === Ii) && (!R.frustumCulled || i.intersectsObject(R))) {
      R.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, R.matrixWorld);
      const k = e.update(R), V = R.material;
      if (Array.isArray(V)) {
        const q = k.groups;
        for (let G = 0, ee = q.length; G < ee; G++) {
          const O = q[G], Q = V[O.materialIndex];
          if (Q && Q.visible) {
            const X = x(R, Q, z, w);
            R.onBeforeShadow(s, R, C, P, k, X, O), s.renderBufferDirect(P, null, k, X, R, O), R.onAfterShadow(s, R, C, P, k, X, O);
          }
        }
      } else if (V.visible) {
        const q = x(R, V, z, w);
        R.onBeforeShadow(s, R, C, P, k, q, null), s.renderBufferDirect(P, null, k, q, R, null), R.onAfterShadow(s, R, C, P, k, q, null);
      }
    }
    const N = R.children;
    for (let k = 0, V = N.length; k < V; k++) S(N[k], C, P, z, w);
  }
  function A(R) {
    R.target.removeEventListener("dispose", A);
    for (const P in c) {
      const z = c[P], w = R.target.uuid;
      w in z && (z[w].dispose(), delete z[w]);
    }
  }
}
const ob = { [cl]: hl, [dl]: fl, [ul]: ml, [Ts]: pl, [hl]: cl, [fl]: dl, [ml]: ul, [pl]: Ts };
function ab(s) {
  function e() {
    let U = false;
    const be = new xt();
    let j = null;
    const ne = new xt(0, 0, 0, 0);
    return { setMask: function(ge) {
      j !== ge && !U && (s.colorMask(ge, ge, ge, ge), j = ge);
    }, setLocked: function(ge) {
      U = ge;
    }, setClear: function(ge, xe, Ke, St, $t) {
      $t === true && (ge *= St, xe *= St, Ke *= St), be.set(ge, xe, Ke, St), ne.equals(be) === false && (s.clearColor(ge, xe, Ke, St), ne.copy(be));
    }, reset: function() {
      U = false, j = null, ne.set(-1, 0, 0, 0);
    } };
  }
  function t() {
    let U = false, be = false, j = null, ne = null, ge = null;
    return { setReversed: function(xe) {
      be = xe;
    }, setTest: function(xe) {
      xe ? me(s.DEPTH_TEST) : de(s.DEPTH_TEST);
    }, setMask: function(xe) {
      j !== xe && !U && (s.depthMask(xe), j = xe);
    }, setFunc: function(xe) {
      if (be && (xe = ob[xe]), ne !== xe) {
        switch (xe) {
          case cl:
            s.depthFunc(s.NEVER);
            break;
          case hl:
            s.depthFunc(s.ALWAYS);
            break;
          case dl:
            s.depthFunc(s.LESS);
            break;
          case Ts:
            s.depthFunc(s.LEQUAL);
            break;
          case ul:
            s.depthFunc(s.EQUAL);
            break;
          case pl:
            s.depthFunc(s.GEQUAL);
            break;
          case fl:
            s.depthFunc(s.GREATER);
            break;
          case ml:
            s.depthFunc(s.NOTEQUAL);
            break;
          default:
            s.depthFunc(s.LEQUAL);
        }
        ne = xe;
      }
    }, setLocked: function(xe) {
      U = xe;
    }, setClear: function(xe) {
      ge !== xe && (s.clearDepth(xe), ge = xe);
    }, reset: function() {
      U = false, j = null, ne = null, ge = null;
    } };
  }
  function i() {
    let U = false, be = null, j = null, ne = null, ge = null, xe = null, Ke = null, St = null, $t = null;
    return { setTest: function(Qe) {
      U || (Qe ? me(s.STENCIL_TEST) : de(s.STENCIL_TEST));
    }, setMask: function(Qe) {
      be !== Qe && !U && (s.stencilMask(Qe), be = Qe);
    }, setFunc: function(Qe, Wt, Ci) {
      (j !== Qe || ne !== Wt || ge !== Ci) && (s.stencilFunc(Qe, Wt, Ci), j = Qe, ne = Wt, ge = Ci);
    }, setOp: function(Qe, Wt, Ci) {
      (xe !== Qe || Ke !== Wt || St !== Ci) && (s.stencilOp(Qe, Wt, Ci), xe = Qe, Ke = Wt, St = Ci);
    }, setLocked: function(Qe) {
      U = Qe;
    }, setClear: function(Qe) {
      $t !== Qe && (s.clearStencil(Qe), $t = Qe);
    }, reset: function() {
      U = false, be = null, j = null, ne = null, ge = null, xe = null, Ke = null, St = null, $t = null;
    } };
  }
  const n = new e(), r = new t(), o = new i(), a = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
  let c = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), u = [], f = null, m = false, _ = null, g = null, v = null, y = null, x = null, S = null, A = null, R = new Xe(0, 0, 0), C = 0, P = false, z = null, w = null, E = null, N = null, k = null;
  const V = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let q = false, G = 0;
  const ee = s.getParameter(s.VERSION);
  ee.indexOf("WebGL") !== -1 ? (G = parseFloat(/^WebGL (\d)/.exec(ee)[1]), q = G >= 1) : ee.indexOf("OpenGL ES") !== -1 && (G = parseFloat(/^OpenGL ES (\d)/.exec(ee)[1]), q = G >= 2);
  let O = null, Q = {};
  const X = s.getParameter(s.SCISSOR_BOX), K = s.getParameter(s.VIEWPORT), Le = new xt().fromArray(X), Re = new xt().fromArray(K);
  function Y(U, be, j, ne) {
    const ge = new Uint8Array(4), xe = s.createTexture();
    s.bindTexture(U, xe), s.texParameteri(U, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(U, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let Ke = 0; Ke < j; Ke++) U === s.TEXTURE_3D || U === s.TEXTURE_2D_ARRAY ? s.texImage3D(be, 0, s.RGBA, 1, 1, ne, 0, s.RGBA, s.UNSIGNED_BYTE, ge) : s.texImage2D(be + Ke, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, ge);
    return xe;
  }
  const se = {};
  se[s.TEXTURE_2D] = Y(s.TEXTURE_2D, s.TEXTURE_2D, 1), se[s.TEXTURE_CUBE_MAP] = Y(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), se[s.TEXTURE_2D_ARRAY] = Y(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), se[s.TEXTURE_3D] = Y(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), n.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), me(s.DEPTH_TEST), r.setFunc(Ts), ce(false), oe(dh), me(s.CULL_FACE), L(an);
  function me(U) {
    c[U] !== true && (s.enable(U), c[U] = true);
  }
  function de(U) {
    c[U] !== false && (s.disable(U), c[U] = false);
  }
  function Ne(U, be) {
    return h[U] !== be ? (s.bindFramebuffer(U, be), h[U] = be, U === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = be), U === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = be), true) : false;
  }
  function Ie(U, be) {
    let j = u, ne = false;
    if (U) {
      j = d.get(be), j === void 0 && (j = [], d.set(be, j));
      const ge = U.textures;
      if (j.length !== ge.length || j[0] !== s.COLOR_ATTACHMENT0) {
        for (let xe = 0, Ke = ge.length; xe < Ke; xe++) j[xe] = s.COLOR_ATTACHMENT0 + xe;
        j.length = ge.length, ne = true;
      }
    } else j[0] !== s.BACK && (j[0] = s.BACK, ne = true);
    ne && s.drawBuffers(j);
  }
  function ze(U) {
    return f !== U ? (s.useProgram(U), f = U, true) : false;
  }
  const We = { [An]: s.FUNC_ADD, [yf]: s.FUNC_SUBTRACT, [Sf]: s.FUNC_REVERSE_SUBTRACT };
  We[Ef] = s.MIN, We[Mf] = s.MAX;
  const te = { [Cf]: s.ZERO, [Tf]: s.ONE, [Af]: s.SRC_COLOR, [al]: s.SRC_ALPHA, [Nf]: s.SRC_ALPHA_SATURATE, [Lf]: s.DST_COLOR, [Rf]: s.DST_ALPHA, [Pf]: s.ONE_MINUS_SRC_COLOR, [ll]: s.ONE_MINUS_SRC_ALPHA, [If]: s.ONE_MINUS_DST_COLOR, [Df]: s.ONE_MINUS_DST_ALPHA, [kf]: s.CONSTANT_COLOR, [Of]: s.ONE_MINUS_CONSTANT_COLOR, [Uf]: s.CONSTANT_ALPHA, [Ff]: s.ONE_MINUS_CONSTANT_ALPHA };
  function L(U, be, j, ne, ge, xe, Ke, St, $t, Qe) {
    if (U === an) {
      m === true && (de(s.BLEND), m = false);
      return;
    }
    if (m === false && (me(s.BLEND), m = true), U !== wf) {
      if (U !== _ || Qe !== P) {
        if ((g !== An || x !== An) && (s.blendEquation(s.FUNC_ADD), g = An, x = An), Qe) switch (U) {
          case bs:
            s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
            break;
          case uh:
            s.blendFunc(s.ONE, s.ONE);
            break;
          case ph:
            s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
            break;
          case fh:
            s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", U);
            break;
        }
        else switch (U) {
          case bs:
            s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
            break;
          case uh:
            s.blendFunc(s.SRC_ALPHA, s.ONE);
            break;
          case ph:
            s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
            break;
          case fh:
            s.blendFunc(s.ZERO, s.SRC_COLOR);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", U);
            break;
        }
        v = null, y = null, S = null, A = null, R.set(0, 0, 0), C = 0, _ = U, P = Qe;
      }
      return;
    }
    ge = ge || be, xe = xe || j, Ke = Ke || ne, (be !== g || ge !== x) && (s.blendEquationSeparate(We[be], We[ge]), g = be, x = ge), (j !== v || ne !== y || xe !== S || Ke !== A) && (s.blendFuncSeparate(te[j], te[ne], te[xe], te[Ke]), v = j, y = ne, S = xe, A = Ke), (St.equals(R) === false || $t !== C) && (s.blendColor(St.r, St.g, St.b, $t), R.copy(St), C = $t), _ = U, P = false;
  }
  function he(U, be) {
    U.side === Yt ? de(s.CULL_FACE) : me(s.CULL_FACE);
    let j = U.side === Kt;
    be && (j = !j), ce(j), U.blending === bs && U.transparent === false ? L(an) : L(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.blendColor, U.blendAlpha, U.premultipliedAlpha), r.setFunc(U.depthFunc), r.setTest(U.depthTest), r.setMask(U.depthWrite), n.setMask(U.colorWrite);
    const ne = U.stencilWrite;
    o.setTest(ne), ne && (o.setMask(U.stencilWriteMask), o.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), o.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), Ae(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === true ? me(s.SAMPLE_ALPHA_TO_COVERAGE) : de(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ce(U) {
    z !== U && (U ? s.frontFace(s.CW) : s.frontFace(s.CCW), z = U);
  }
  function oe(U) {
    U !== _f ? (me(s.CULL_FACE), U !== w && (U === dh ? s.cullFace(s.BACK) : U === bf ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : de(s.CULL_FACE), w = U;
  }
  function ue(U) {
    U !== E && (q && s.lineWidth(U), E = U);
  }
  function Ae(U, be, j) {
    U ? (me(s.POLYGON_OFFSET_FILL), (N !== be || k !== j) && (s.polygonOffset(be, j), N = be, k = j)) : de(s.POLYGON_OFFSET_FILL);
  }
  function _e(U) {
    U ? me(s.SCISSOR_TEST) : de(s.SCISSOR_TEST);
  }
  function D(U) {
    U === void 0 && (U = s.TEXTURE0 + V - 1), O !== U && (s.activeTexture(U), O = U);
  }
  function M(U, be, j) {
    j === void 0 && (O === null ? j = s.TEXTURE0 + V - 1 : j = O);
    let ne = Q[j];
    ne === void 0 && (ne = { type: void 0, texture: void 0 }, Q[j] = ne), (ne.type !== U || ne.texture !== be) && (O !== j && (s.activeTexture(j), O = j), s.bindTexture(U, be || se[U]), ne.type = U, ne.texture = be);
  }
  function H() {
    const U = Q[O];
    U !== void 0 && U.type !== void 0 && (s.bindTexture(U.type, null), U.type = void 0, U.texture = void 0);
  }
  function Z() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function ie() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function J() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function Me() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function pe() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function we() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function je() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function ae() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function ye() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function Ue() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (U) {
      console.error("THREE.WebGLState:", U);
    }
  }
  function Fe(U) {
    Le.equals(U) === false && (s.scissor(U.x, U.y, U.z, U.w), Le.copy(U));
  }
  function Se(U) {
    Re.equals(U) === false && (s.viewport(U.x, U.y, U.z, U.w), Re.copy(U));
  }
  function Ye(U, be) {
    let j = l.get(be);
    j === void 0 && (j = /* @__PURE__ */ new WeakMap(), l.set(be, j));
    let ne = j.get(U);
    ne === void 0 && (ne = s.getUniformBlockIndex(be, U.name), j.set(U, ne));
  }
  function Ve(U, be) {
    const ne = l.get(be).get(U);
    a.get(be) !== ne && (s.uniformBlockBinding(be, ne, U.__bindingPointIndex), a.set(be, ne));
  }
  function ct() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(true, true, true, true), s.clearColor(0, 0, 0, 0), s.depthMask(true), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), c = {}, O = null, Q = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), u = [], f = null, m = false, _ = null, g = null, v = null, y = null, x = null, S = null, A = null, R = new Xe(0, 0, 0), C = 0, P = false, z = null, w = null, E = null, N = null, k = null, Le.set(0, 0, s.canvas.width, s.canvas.height), Re.set(0, 0, s.canvas.width, s.canvas.height), n.reset(), r.reset(), o.reset();
  }
  return { buffers: { color: n, depth: r, stencil: o }, enable: me, disable: de, bindFramebuffer: Ne, drawBuffers: Ie, useProgram: ze, setBlending: L, setMaterial: he, setFlipSided: ce, setCullFace: oe, setLineWidth: ue, setPolygonOffset: Ae, setScissorTest: _e, activeTexture: D, bindTexture: M, unbindTexture: H, compressedTexImage2D: Z, compressedTexImage3D: ie, texImage2D: ye, texImage3D: Ue, updateUBOMapping: Ye, uniformBlockBinding: Ve, texStorage2D: je, texStorage3D: ae, texSubImage2D: J, texSubImage3D: Me, compressedTexSubImage2D: pe, compressedTexSubImage3D: we, scissor: Fe, viewport: Se, reset: ct };
}
function nd(s, e, t, i) {
  const n = lb(i);
  switch (t) {
    case bu:
      return s * e;
    case wu:
      return s * e;
    case yu:
      return s * e * 2;
    case Su:
      return s * e / n.components * n.byteLength;
    case mc:
      return s * e / n.components * n.byteLength;
    case Eu:
      return s * e * 2 / n.components * n.byteLength;
    case gc:
      return s * e * 2 / n.components * n.byteLength;
    case xu:
      return s * e * 3 / n.components * n.byteLength;
    case vi:
      return s * e * 4 / n.components * n.byteLength;
    case vc:
      return s * e * 4 / n.components * n.byteLength;
    case Mo:
    case Co:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case To:
    case Ao:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case wl:
    case Sl:
      return Math.max(s, 16) * Math.max(e, 8) / 4;
    case xl:
    case yl:
      return Math.max(s, 8) * Math.max(e, 8) / 2;
    case El:
    case Ml:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Cl:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Tl:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Al:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Pl:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Rl:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Dl:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Ll:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Il:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Nl:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case kl:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Ol:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Ul:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Fl:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case zl:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Bl:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Po:
    case Vl:
    case Hl:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case Mu:
    case Gl:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case $l:
    case Wl:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function lb(s) {
  switch (s) {
    case Bi:
    case gu:
      return { byteLength: 1, components: 1 };
    case cr:
    case vu:
    case Sr:
      return { byteLength: 2, components: 1 };
    case pc:
    case fc:
      return { byteLength: 2, components: 4 };
    case On:
    case uc:
    case Ni:
      return { byteLength: 4, components: 1 };
    case _u:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
function cb(s, e, t, i, n, r, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new re(), h = /* @__PURE__ */ new WeakMap();
  let d;
  const u = /* @__PURE__ */ new WeakMap();
  let f = false;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(D, M) {
    return f ? new OffscreenCanvas(D, M) : Ho("canvas");
  }
  function _(D, M, H) {
    let Z = 1;
    const ie = _e(D);
    if ((ie.width > H || ie.height > H) && (Z = H / Math.max(ie.width, ie.height)), Z < 1) if (typeof HTMLImageElement < "u" && D instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && D instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && D instanceof ImageBitmap || typeof VideoFrame < "u" && D instanceof VideoFrame) {
      const J = Math.floor(Z * ie.width), Me = Math.floor(Z * ie.height);
      d === void 0 && (d = m(J, Me));
      const pe = M ? m(J, Me) : d;
      return pe.width = J, pe.height = Me, pe.getContext("2d").drawImage(D, 0, 0, J, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ie.width + "x" + ie.height + ") to (" + J + "x" + Me + ")."), pe;
    } else return "data" in D && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ie.width + "x" + ie.height + ")."), D;
    return D;
  }
  function g(D) {
    return D.generateMipmaps && D.minFilter !== ci && D.minFilter !== gi;
  }
  function v(D) {
    s.generateMipmap(D);
  }
  function y(D, M, H, Z, ie = false) {
    if (D !== null) {
      if (s[D] !== void 0) return s[D];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + D + "'");
    }
    let J = M;
    if (M === s.RED && (H === s.FLOAT && (J = s.R32F), H === s.HALF_FLOAT && (J = s.R16F), H === s.UNSIGNED_BYTE && (J = s.R8)), M === s.RED_INTEGER && (H === s.UNSIGNED_BYTE && (J = s.R8UI), H === s.UNSIGNED_SHORT && (J = s.R16UI), H === s.UNSIGNED_INT && (J = s.R32UI), H === s.BYTE && (J = s.R8I), H === s.SHORT && (J = s.R16I), H === s.INT && (J = s.R32I)), M === s.RG && (H === s.FLOAT && (J = s.RG32F), H === s.HALF_FLOAT && (J = s.RG16F), H === s.UNSIGNED_BYTE && (J = s.RG8)), M === s.RG_INTEGER && (H === s.UNSIGNED_BYTE && (J = s.RG8UI), H === s.UNSIGNED_SHORT && (J = s.RG16UI), H === s.UNSIGNED_INT && (J = s.RG32UI), H === s.BYTE && (J = s.RG8I), H === s.SHORT && (J = s.RG16I), H === s.INT && (J = s.RG32I)), M === s.RGB_INTEGER && (H === s.UNSIGNED_BYTE && (J = s.RGB8UI), H === s.UNSIGNED_SHORT && (J = s.RGB16UI), H === s.UNSIGNED_INT && (J = s.RGB32UI), H === s.BYTE && (J = s.RGB8I), H === s.SHORT && (J = s.RGB16I), H === s.INT && (J = s.RGB32I)), M === s.RGBA_INTEGER && (H === s.UNSIGNED_BYTE && (J = s.RGBA8UI), H === s.UNSIGNED_SHORT && (J = s.RGBA16UI), H === s.UNSIGNED_INT && (J = s.RGBA32UI), H === s.BYTE && (J = s.RGBA8I), H === s.SHORT && (J = s.RGBA16I), H === s.INT && (J = s.RGBA32I)), M === s.RGB && H === s.UNSIGNED_INT_5_9_9_9_REV && (J = s.RGB9_E5), M === s.RGBA) {
      const Me = ie ? Fo : it.getTransfer(Z);
      H === s.FLOAT && (J = s.RGBA32F), H === s.HALF_FLOAT && (J = s.RGBA16F), H === s.UNSIGNED_BYTE && (J = Me === pt ? s.SRGB8_ALPHA8 : s.RGBA8), H === s.UNSIGNED_SHORT_4_4_4_4 && (J = s.RGBA4), H === s.UNSIGNED_SHORT_5_5_5_1 && (J = s.RGB5_A1);
    }
    return (J === s.R16F || J === s.R32F || J === s.RG16F || J === s.RG32F || J === s.RGBA16F || J === s.RGBA32F) && e.get("EXT_color_buffer_float"), J;
  }
  function x(D, M) {
    let H;
    return D ? M === null || M === On || M === Rs ? H = s.DEPTH24_STENCIL8 : M === Ni ? H = s.DEPTH32F_STENCIL8 : M === cr && (H = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === On || M === Rs ? H = s.DEPTH_COMPONENT24 : M === Ni ? H = s.DEPTH_COMPONENT32F : M === cr && (H = s.DEPTH_COMPONENT16), H;
  }
  function S(D, M) {
    return g(D) === true || D.isFramebufferTexture && D.minFilter !== ci && D.minFilter !== gi ? Math.log2(Math.max(M.width, M.height)) + 1 : D.mipmaps !== void 0 && D.mipmaps.length > 0 ? D.mipmaps.length : D.isCompressedTexture && Array.isArray(D.image) ? M.mipmaps.length : 1;
  }
  function A(D) {
    const M = D.target;
    M.removeEventListener("dispose", A), C(M), M.isVideoTexture && h.delete(M);
  }
  function R(D) {
    const M = D.target;
    M.removeEventListener("dispose", R), z(M);
  }
  function C(D) {
    const M = i.get(D);
    if (M.__webglInit === void 0) return;
    const H = D.source, Z = u.get(H);
    if (Z) {
      const ie = Z[M.__cacheKey];
      ie.usedTimes--, ie.usedTimes === 0 && P(D), Object.keys(Z).length === 0 && u.delete(H);
    }
    i.remove(D);
  }
  function P(D) {
    const M = i.get(D);
    s.deleteTexture(M.__webglTexture);
    const H = D.source, Z = u.get(H);
    delete Z[M.__cacheKey], o.memory.textures--;
  }
  function z(D) {
    const M = i.get(D);
    if (D.depthTexture && D.depthTexture.dispose(), D.isWebGLCubeRenderTarget) for (let Z = 0; Z < 6; Z++) {
      if (Array.isArray(M.__webglFramebuffer[Z])) for (let ie = 0; ie < M.__webglFramebuffer[Z].length; ie++) s.deleteFramebuffer(M.__webglFramebuffer[Z][ie]);
      else s.deleteFramebuffer(M.__webglFramebuffer[Z]);
      M.__webglDepthbuffer && s.deleteRenderbuffer(M.__webglDepthbuffer[Z]);
    }
    else {
      if (Array.isArray(M.__webglFramebuffer)) for (let Z = 0; Z < M.__webglFramebuffer.length; Z++) s.deleteFramebuffer(M.__webglFramebuffer[Z]);
      else s.deleteFramebuffer(M.__webglFramebuffer);
      if (M.__webglDepthbuffer && s.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && s.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for (let Z = 0; Z < M.__webglColorRenderbuffer.length; Z++) M.__webglColorRenderbuffer[Z] && s.deleteRenderbuffer(M.__webglColorRenderbuffer[Z]);
      M.__webglDepthRenderbuffer && s.deleteRenderbuffer(M.__webglDepthRenderbuffer);
    }
    const H = D.textures;
    for (let Z = 0, ie = H.length; Z < ie; Z++) {
      const J = i.get(H[Z]);
      J.__webglTexture && (s.deleteTexture(J.__webglTexture), o.memory.textures--), i.remove(H[Z]);
    }
    i.remove(D);
  }
  let w = 0;
  function E() {
    w = 0;
  }
  function N() {
    const D = w;
    return D >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + D + " texture units while this GPU supports only " + n.maxTextures), w += 1, D;
  }
  function k(D) {
    const M = [];
    return M.push(D.wrapS), M.push(D.wrapT), M.push(D.wrapR || 0), M.push(D.magFilter), M.push(D.minFilter), M.push(D.anisotropy), M.push(D.internalFormat), M.push(D.format), M.push(D.type), M.push(D.generateMipmaps), M.push(D.premultiplyAlpha), M.push(D.flipY), M.push(D.unpackAlignment), M.push(D.colorSpace), M.join();
  }
  function V(D, M) {
    const H = i.get(D);
    if (D.isVideoTexture && ue(D), D.isRenderTargetTexture === false && D.version > 0 && H.__version !== D.version) {
      const Z = D.image;
      if (Z === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Z.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Re(H, D, M);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, H.__webglTexture, s.TEXTURE0 + M);
  }
  function q(D, M) {
    const H = i.get(D);
    if (D.version > 0 && H.__version !== D.version) {
      Re(H, D, M);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, H.__webglTexture, s.TEXTURE0 + M);
  }
  function G(D, M) {
    const H = i.get(D);
    if (D.version > 0 && H.__version !== D.version) {
      Re(H, D, M);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, H.__webglTexture, s.TEXTURE0 + M);
  }
  function ee(D, M) {
    const H = i.get(D);
    if (D.version > 0 && H.__version !== D.version) {
      Y(H, D, M);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, H.__webglTexture, s.TEXTURE0 + M);
  }
  const O = { [_l]: s.REPEAT, [Rn]: s.CLAMP_TO_EDGE, [bl]: s.MIRRORED_REPEAT }, Q = { [ci]: s.NEAREST, [Yf]: s.NEAREST_MIPMAP_NEAREST, [Hr]: s.NEAREST_MIPMAP_LINEAR, [gi]: s.LINEAR, [ua]: s.LINEAR_MIPMAP_NEAREST, [Dn]: s.LINEAR_MIPMAP_LINEAR }, X = { [Jf]: s.NEVER, [sm]: s.ALWAYS, [Qf]: s.LESS, [Tu]: s.LEQUAL, [em]: s.EQUAL, [nm]: s.GEQUAL, [tm]: s.GREATER, [im]: s.NOTEQUAL };
  function K(D, M) {
    if (M.type === Ni && e.has("OES_texture_float_linear") === false && (M.magFilter === gi || M.magFilter === ua || M.magFilter === Hr || M.magFilter === Dn || M.minFilter === gi || M.minFilter === ua || M.minFilter === Hr || M.minFilter === Dn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(D, s.TEXTURE_WRAP_S, O[M.wrapS]), s.texParameteri(D, s.TEXTURE_WRAP_T, O[M.wrapT]), (D === s.TEXTURE_3D || D === s.TEXTURE_2D_ARRAY) && s.texParameteri(D, s.TEXTURE_WRAP_R, O[M.wrapR]), s.texParameteri(D, s.TEXTURE_MAG_FILTER, Q[M.magFilter]), s.texParameteri(D, s.TEXTURE_MIN_FILTER, Q[M.minFilter]), M.compareFunction && (s.texParameteri(D, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(D, s.TEXTURE_COMPARE_FUNC, X[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
      if (M.magFilter === ci || M.minFilter !== Hr && M.minFilter !== Dn || M.type === Ni && e.has("OES_texture_float_linear") === false) return;
      if (M.anisotropy > 1 || i.get(M).__currentAnisotropy) {
        const H = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(D, H.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, n.getMaxAnisotropy())), i.get(M).__currentAnisotropy = M.anisotropy;
      }
    }
  }
  function Le(D, M) {
    let H = false;
    D.__webglInit === void 0 && (D.__webglInit = true, M.addEventListener("dispose", A));
    const Z = M.source;
    let ie = u.get(Z);
    ie === void 0 && (ie = {}, u.set(Z, ie));
    const J = k(M);
    if (J !== D.__cacheKey) {
      ie[J] === void 0 && (ie[J] = { texture: s.createTexture(), usedTimes: 0 }, o.memory.textures++, H = true), ie[J].usedTimes++;
      const Me = ie[D.__cacheKey];
      Me !== void 0 && (ie[D.__cacheKey].usedTimes--, Me.usedTimes === 0 && P(M)), D.__cacheKey = J, D.__webglTexture = ie[J].texture;
    }
    return H;
  }
  function Re(D, M, H) {
    let Z = s.TEXTURE_2D;
    (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Z = s.TEXTURE_2D_ARRAY), M.isData3DTexture && (Z = s.TEXTURE_3D);
    const ie = Le(D, M), J = M.source;
    t.bindTexture(Z, D.__webglTexture, s.TEXTURE0 + H);
    const Me = i.get(J);
    if (J.version !== Me.__version || ie === true) {
      t.activeTexture(s.TEXTURE0 + H);
      const pe = it.getPrimaries(it.workingColorSpace), we = M.colorSpace === tn ? null : it.getPrimaries(M.colorSpace), je = M.colorSpace === tn || pe === we ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, M.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, M.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, je);
      let ae = _(M.image, false, n.maxTextureSize);
      ae = Ae(M, ae);
      const ye = r.convert(M.format, M.colorSpace), Ue = r.convert(M.type);
      let Fe = y(M.internalFormat, ye, Ue, M.colorSpace, M.isVideoTexture);
      K(Z, M);
      let Se;
      const Ye = M.mipmaps, Ve = M.isVideoTexture !== true, ct = Me.__version === void 0 || ie === true, U = J.dataReady, be = S(M, ae);
      if (M.isDepthTexture) Fe = x(M.format === Ds, M.type), ct && (Ve ? t.texStorage2D(s.TEXTURE_2D, 1, Fe, ae.width, ae.height) : t.texImage2D(s.TEXTURE_2D, 0, Fe, ae.width, ae.height, 0, ye, Ue, null));
      else if (M.isDataTexture) if (Ye.length > 0) {
        Ve && ct && t.texStorage2D(s.TEXTURE_2D, be, Fe, Ye[0].width, Ye[0].height);
        for (let j = 0, ne = Ye.length; j < ne; j++) Se = Ye[j], Ve ? U && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, Se.width, Se.height, ye, Ue, Se.data) : t.texImage2D(s.TEXTURE_2D, j, Fe, Se.width, Se.height, 0, ye, Ue, Se.data);
        M.generateMipmaps = false;
      } else Ve ? (ct && t.texStorage2D(s.TEXTURE_2D, be, Fe, ae.width, ae.height), U && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ae.width, ae.height, ye, Ue, ae.data)) : t.texImage2D(s.TEXTURE_2D, 0, Fe, ae.width, ae.height, 0, ye, Ue, ae.data);
      else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
        Ve && ct && t.texStorage3D(s.TEXTURE_2D_ARRAY, be, Fe, Ye[0].width, Ye[0].height, ae.depth);
        for (let j = 0, ne = Ye.length; j < ne; j++) if (Se = Ye[j], M.format !== vi) if (ye !== null) if (Ve) {
          if (U) if (M.layerUpdates.size > 0) {
            const ge = nd(Se.width, Se.height, M.format, M.type);
            for (const xe of M.layerUpdates) {
              const Ke = Se.data.subarray(xe * ge / Se.data.BYTES_PER_ELEMENT, (xe + 1) * ge / Se.data.BYTES_PER_ELEMENT);
              t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, xe, Se.width, Se.height, 1, ye, Ke, 0, 0);
            }
            M.clearLayerUpdates();
          } else t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, 0, Se.width, Se.height, ae.depth, ye, Se.data, 0, 0);
        } else t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, j, Fe, Se.width, Se.height, ae.depth, 0, Se.data, 0, 0);
        else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
        else Ve ? U && t.texSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, 0, Se.width, Se.height, ae.depth, ye, Ue, Se.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, j, Fe, Se.width, Se.height, ae.depth, 0, ye, Ue, Se.data);
      } else {
        Ve && ct && t.texStorage2D(s.TEXTURE_2D, be, Fe, Ye[0].width, Ye[0].height);
        for (let j = 0, ne = Ye.length; j < ne; j++) Se = Ye[j], M.format !== vi ? ye !== null ? Ve ? U && t.compressedTexSubImage2D(s.TEXTURE_2D, j, 0, 0, Se.width, Se.height, ye, Se.data) : t.compressedTexImage2D(s.TEXTURE_2D, j, Fe, Se.width, Se.height, 0, Se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ve ? U && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, Se.width, Se.height, ye, Ue, Se.data) : t.texImage2D(s.TEXTURE_2D, j, Fe, Se.width, Se.height, 0, ye, Ue, Se.data);
      }
      else if (M.isDataArrayTexture) if (Ve) {
        if (ct && t.texStorage3D(s.TEXTURE_2D_ARRAY, be, Fe, ae.width, ae.height, ae.depth), U) if (M.layerUpdates.size > 0) {
          const j = nd(ae.width, ae.height, M.format, M.type);
          for (const ne of M.layerUpdates) {
            const ge = ae.data.subarray(ne * j / ae.data.BYTES_PER_ELEMENT, (ne + 1) * j / ae.data.BYTES_PER_ELEMENT);
            t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, ne, ae.width, ae.height, 1, ye, Ue, ge);
          }
          M.clearLayerUpdates();
        } else t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ae.width, ae.height, ae.depth, ye, Ue, ae.data);
      } else t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Fe, ae.width, ae.height, ae.depth, 0, ye, Ue, ae.data);
      else if (M.isData3DTexture) Ve ? (ct && t.texStorage3D(s.TEXTURE_3D, be, Fe, ae.width, ae.height, ae.depth), U && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, ae.width, ae.height, ae.depth, ye, Ue, ae.data)) : t.texImage3D(s.TEXTURE_3D, 0, Fe, ae.width, ae.height, ae.depth, 0, ye, Ue, ae.data);
      else if (M.isFramebufferTexture) {
        if (ct) if (Ve) t.texStorage2D(s.TEXTURE_2D, be, Fe, ae.width, ae.height);
        else {
          let j = ae.width, ne = ae.height;
          for (let ge = 0; ge < be; ge++) t.texImage2D(s.TEXTURE_2D, ge, Fe, j, ne, 0, ye, Ue, null), j >>= 1, ne >>= 1;
        }
      } else if (Ye.length > 0) {
        if (Ve && ct) {
          const j = _e(Ye[0]);
          t.texStorage2D(s.TEXTURE_2D, be, Fe, j.width, j.height);
        }
        for (let j = 0, ne = Ye.length; j < ne; j++) Se = Ye[j], Ve ? U && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, ye, Ue, Se) : t.texImage2D(s.TEXTURE_2D, j, Fe, ye, Ue, Se);
        M.generateMipmaps = false;
      } else if (Ve) {
        if (ct) {
          const j = _e(ae);
          t.texStorage2D(s.TEXTURE_2D, be, Fe, j.width, j.height);
        }
        U && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ye, Ue, ae);
      } else t.texImage2D(s.TEXTURE_2D, 0, Fe, ye, Ue, ae);
      g(M) && v(Z), Me.__version = J.version, M.onUpdate && M.onUpdate(M);
    }
    D.__version = M.version;
  }
  function Y(D, M, H) {
    if (M.image.length !== 6) return;
    const Z = Le(D, M), ie = M.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, D.__webglTexture, s.TEXTURE0 + H);
    const J = i.get(ie);
    if (ie.version !== J.__version || Z === true) {
      t.activeTexture(s.TEXTURE0 + H);
      const Me = it.getPrimaries(it.workingColorSpace), pe = M.colorSpace === tn ? null : it.getPrimaries(M.colorSpace), we = M.colorSpace === tn || Me === pe ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, M.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, M.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, we);
      const je = M.isCompressedTexture || M.image[0].isCompressedTexture, ae = M.image[0] && M.image[0].isDataTexture, ye = [];
      for (let ne = 0; ne < 6; ne++) !je && !ae ? ye[ne] = _(M.image[ne], true, n.maxCubemapSize) : ye[ne] = ae ? M.image[ne].image : M.image[ne], ye[ne] = Ae(M, ye[ne]);
      const Ue = ye[0], Fe = r.convert(M.format, M.colorSpace), Se = r.convert(M.type), Ye = y(M.internalFormat, Fe, Se, M.colorSpace), Ve = M.isVideoTexture !== true, ct = J.__version === void 0 || Z === true, U = ie.dataReady;
      let be = S(M, Ue);
      K(s.TEXTURE_CUBE_MAP, M);
      let j;
      if (je) {
        Ve && ct && t.texStorage2D(s.TEXTURE_CUBE_MAP, be, Ye, Ue.width, Ue.height);
        for (let ne = 0; ne < 6; ne++) {
          j = ye[ne].mipmaps;
          for (let ge = 0; ge < j.length; ge++) {
            const xe = j[ge];
            M.format !== vi ? Fe !== null ? Ve ? U && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge, 0, 0, xe.width, xe.height, Fe, xe.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge, Ye, xe.width, xe.height, 0, xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ve ? U && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge, 0, 0, xe.width, xe.height, Fe, Se, xe.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge, Ye, xe.width, xe.height, 0, Fe, Se, xe.data);
          }
        }
      } else {
        if (j = M.mipmaps, Ve && ct) {
          j.length > 0 && be++;
          const ne = _e(ye[0]);
          t.texStorage2D(s.TEXTURE_CUBE_MAP, be, Ye, ne.width, ne.height);
        }
        for (let ne = 0; ne < 6; ne++) if (ae) {
          Ve ? U && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, 0, 0, 0, ye[ne].width, ye[ne].height, Fe, Se, ye[ne].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, 0, Ye, ye[ne].width, ye[ne].height, 0, Fe, Se, ye[ne].data);
          for (let ge = 0; ge < j.length; ge++) {
            const Ke = j[ge].image[ne].image;
            Ve ? U && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge + 1, 0, 0, Ke.width, Ke.height, Fe, Se, Ke.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge + 1, Ye, Ke.width, Ke.height, 0, Fe, Se, Ke.data);
          }
        } else {
          Ve ? U && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, 0, 0, 0, Fe, Se, ye[ne]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, 0, Ye, Fe, Se, ye[ne]);
          for (let ge = 0; ge < j.length; ge++) {
            const xe = j[ge];
            Ve ? U && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge + 1, 0, 0, Fe, Se, xe.image[ne]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ne, ge + 1, Ye, Fe, Se, xe.image[ne]);
          }
        }
      }
      g(M) && v(s.TEXTURE_CUBE_MAP), J.__version = ie.version, M.onUpdate && M.onUpdate(M);
    }
    D.__version = M.version;
  }
  function se(D, M, H, Z, ie, J) {
    const Me = r.convert(H.format, H.colorSpace), pe = r.convert(H.type), we = y(H.internalFormat, Me, pe, H.colorSpace);
    if (!i.get(M).__hasExternalTextures) {
      const ae = Math.max(1, M.width >> J), ye = Math.max(1, M.height >> J);
      ie === s.TEXTURE_3D || ie === s.TEXTURE_2D_ARRAY ? t.texImage3D(ie, J, we, ae, ye, M.depth, 0, Me, pe, null) : t.texImage2D(ie, J, we, ae, ye, 0, Me, pe, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, D), oe(M) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, Z, ie, i.get(H).__webglTexture, 0, ce(M)) : (ie === s.TEXTURE_2D || ie >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ie <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, Z, ie, i.get(H).__webglTexture, J), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function me(D, M, H) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, D), M.depthBuffer) {
      const Z = M.depthTexture, ie = Z && Z.isDepthTexture ? Z.type : null, J = x(M.stencilBuffer, ie), Me = M.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, pe = ce(M);
      oe(M) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, pe, J, M.width, M.height) : H ? s.renderbufferStorageMultisample(s.RENDERBUFFER, pe, J, M.width, M.height) : s.renderbufferStorage(s.RENDERBUFFER, J, M.width, M.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, Me, s.RENDERBUFFER, D);
    } else {
      const Z = M.textures;
      for (let ie = 0; ie < Z.length; ie++) {
        const J = Z[ie], Me = r.convert(J.format, J.colorSpace), pe = r.convert(J.type), we = y(J.internalFormat, Me, pe, J.colorSpace), je = ce(M);
        H && oe(M) === false ? s.renderbufferStorageMultisample(s.RENDERBUFFER, je, we, M.width, M.height) : oe(M) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, je, we, M.width, M.height) : s.renderbufferStorage(s.RENDERBUFFER, we, M.width, M.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function de(D, M) {
    if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, D), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(M.depthTexture).__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = true), V(M.depthTexture, 0);
    const Z = i.get(M.depthTexture).__webglTexture, ie = ce(M);
    if (M.depthTexture.format === xs) oe(M) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Z, 0, ie) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Z, 0);
    else if (M.depthTexture.format === Ds) oe(M) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Z, 0, ie) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Z, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function Ne(D) {
    const M = i.get(D), H = D.isWebGLCubeRenderTarget === true;
    if (M.__boundDepthTexture !== D.depthTexture) {
      const Z = D.depthTexture;
      if (M.__depthDisposeCallback && M.__depthDisposeCallback(), Z) {
        const ie = () => {
          delete M.__boundDepthTexture, delete M.__depthDisposeCallback, Z.removeEventListener("dispose", ie);
        };
        Z.addEventListener("dispose", ie), M.__depthDisposeCallback = ie;
      }
      M.__boundDepthTexture = Z;
    }
    if (D.depthTexture && !M.__autoAllocateDepthBuffer) {
      if (H) throw new Error("target.depthTexture not supported in Cube render targets");
      de(M.__webglFramebuffer, D);
    } else if (H) {
      M.__webglDepthbuffer = [];
      for (let Z = 0; Z < 6; Z++) if (t.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer[Z]), M.__webglDepthbuffer[Z] === void 0) M.__webglDepthbuffer[Z] = s.createRenderbuffer(), me(M.__webglDepthbuffer[Z], D, false);
      else {
        const ie = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, J = M.__webglDepthbuffer[Z];
        s.bindRenderbuffer(s.RENDERBUFFER, J), s.framebufferRenderbuffer(s.FRAMEBUFFER, ie, s.RENDERBUFFER, J);
      }
    } else if (t.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = s.createRenderbuffer(), me(M.__webglDepthbuffer, D, false);
    else {
      const Z = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ie = M.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, ie), s.framebufferRenderbuffer(s.FRAMEBUFFER, Z, s.RENDERBUFFER, ie);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Ie(D, M, H) {
    const Z = i.get(D);
    M !== void 0 && se(Z.__webglFramebuffer, D, D.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), H !== void 0 && Ne(D);
  }
  function ze(D) {
    const M = D.texture, H = i.get(D), Z = i.get(M);
    D.addEventListener("dispose", R);
    const ie = D.textures, J = D.isWebGLCubeRenderTarget === true, Me = ie.length > 1;
    if (Me || (Z.__webglTexture === void 0 && (Z.__webglTexture = s.createTexture()), Z.__version = M.version, o.memory.textures++), J) {
      H.__webglFramebuffer = [];
      for (let pe = 0; pe < 6; pe++) if (M.mipmaps && M.mipmaps.length > 0) {
        H.__webglFramebuffer[pe] = [];
        for (let we = 0; we < M.mipmaps.length; we++) H.__webglFramebuffer[pe][we] = s.createFramebuffer();
      } else H.__webglFramebuffer[pe] = s.createFramebuffer();
    } else {
      if (M.mipmaps && M.mipmaps.length > 0) {
        H.__webglFramebuffer = [];
        for (let pe = 0; pe < M.mipmaps.length; pe++) H.__webglFramebuffer[pe] = s.createFramebuffer();
      } else H.__webglFramebuffer = s.createFramebuffer();
      if (Me) for (let pe = 0, we = ie.length; pe < we; pe++) {
        const je = i.get(ie[pe]);
        je.__webglTexture === void 0 && (je.__webglTexture = s.createTexture(), o.memory.textures++);
      }
      if (D.samples > 0 && oe(D) === false) {
        H.__webglMultisampledFramebuffer = s.createFramebuffer(), H.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, H.__webglMultisampledFramebuffer);
        for (let pe = 0; pe < ie.length; pe++) {
          const we = ie[pe];
          H.__webglColorRenderbuffer[pe] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, H.__webglColorRenderbuffer[pe]);
          const je = r.convert(we.format, we.colorSpace), ae = r.convert(we.type), ye = y(we.internalFormat, je, ae, we.colorSpace, D.isXRRenderTarget === true), Ue = ce(D);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Ue, ye, D.width, D.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + pe, s.RENDERBUFFER, H.__webglColorRenderbuffer[pe]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), D.depthBuffer && (H.__webglDepthRenderbuffer = s.createRenderbuffer(), me(H.__webglDepthRenderbuffer, D, true)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (J) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, Z.__webglTexture), K(s.TEXTURE_CUBE_MAP, M);
      for (let pe = 0; pe < 6; pe++) if (M.mipmaps && M.mipmaps.length > 0) for (let we = 0; we < M.mipmaps.length; we++) se(H.__webglFramebuffer[pe][we], D, M, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + pe, we);
      else se(H.__webglFramebuffer[pe], D, M, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0);
      g(M) && v(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Me) {
      for (let pe = 0, we = ie.length; pe < we; pe++) {
        const je = ie[pe], ae = i.get(je);
        t.bindTexture(s.TEXTURE_2D, ae.__webglTexture), K(s.TEXTURE_2D, je), se(H.__webglFramebuffer, D, je, s.COLOR_ATTACHMENT0 + pe, s.TEXTURE_2D, 0), g(je) && v(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let pe = s.TEXTURE_2D;
      if ((D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) && (pe = D.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), t.bindTexture(pe, Z.__webglTexture), K(pe, M), M.mipmaps && M.mipmaps.length > 0) for (let we = 0; we < M.mipmaps.length; we++) se(H.__webglFramebuffer[we], D, M, s.COLOR_ATTACHMENT0, pe, we);
      else se(H.__webglFramebuffer, D, M, s.COLOR_ATTACHMENT0, pe, 0);
      g(M) && v(pe), t.unbindTexture();
    }
    D.depthBuffer && Ne(D);
  }
  function We(D) {
    const M = D.textures;
    for (let H = 0, Z = M.length; H < Z; H++) {
      const ie = M[H];
      if (g(ie)) {
        const J = D.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, Me = i.get(ie).__webglTexture;
        t.bindTexture(J, Me), v(J), t.unbindTexture();
      }
    }
  }
  const te = [], L = [];
  function he(D) {
    if (D.samples > 0) {
      if (oe(D) === false) {
        const M = D.textures, H = D.width, Z = D.height;
        let ie = s.COLOR_BUFFER_BIT;
        const J = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Me = i.get(D), pe = M.length > 1;
        if (pe) for (let we = 0; we < M.length; we++) t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.TEXTURE_2D, null, 0);
        t.bindFramebuffer(s.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
        for (let we = 0; we < M.length; we++) {
          if (D.resolveDepthBuffer && (D.depthBuffer && (ie |= s.DEPTH_BUFFER_BIT), D.stencilBuffer && D.resolveStencilBuffer && (ie |= s.STENCIL_BUFFER_BIT)), pe) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Me.__webglColorRenderbuffer[we]);
            const je = i.get(M[we]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, je, 0);
          }
          s.blitFramebuffer(0, 0, H, Z, 0, 0, H, Z, ie, s.NEAREST), l === true && (te.length = 0, L.length = 0, te.push(s.COLOR_ATTACHMENT0 + we), D.depthBuffer && D.resolveDepthBuffer === false && (te.push(J), L.push(J), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, L)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, te));
        }
        if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), pe) for (let we = 0; we < M.length; we++) {
          t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.RENDERBUFFER, Me.__webglColorRenderbuffer[we]);
          const je = i.get(M[we]).__webglTexture;
          t.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.TEXTURE_2D, je, 0);
        }
        t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
      } else if (D.depthBuffer && D.resolveDepthBuffer === false && l) {
        const M = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [M]);
      }
    }
  }
  function ce(D) {
    return Math.min(n.maxSamples, D.samples);
  }
  function oe(D) {
    const M = i.get(D);
    return D.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && M.__useRenderToTexture !== false;
  }
  function ue(D) {
    const M = o.render.frame;
    h.get(D) !== M && (h.set(D, M), D.update());
  }
  function Ae(D, M) {
    const H = D.colorSpace, Z = D.format, ie = D.type;
    return D.isCompressedTexture === true || D.isVideoTexture === true || H !== gn && H !== tn && (it.getTransfer(H) === pt ? (Z !== vi || ie !== Bi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", H)), M;
  }
  function _e(D) {
    return typeof HTMLImageElement < "u" && D instanceof HTMLImageElement ? (c.width = D.naturalWidth || D.width, c.height = D.naturalHeight || D.height) : typeof VideoFrame < "u" && D instanceof VideoFrame ? (c.width = D.displayWidth, c.height = D.displayHeight) : (c.width = D.width, c.height = D.height), c;
  }
  this.allocateTextureUnit = N, this.resetTextureUnits = E, this.setTexture2D = V, this.setTexture2DArray = q, this.setTexture3D = G, this.setTextureCube = ee, this.rebindTextures = Ie, this.setupRenderTarget = ze, this.updateRenderTargetMipmap = We, this.updateMultisampleRenderTarget = he, this.setupDepthRenderbuffer = Ne, this.setupFrameBufferTexture = se, this.useMultisampledRTT = oe;
}
function hb(s, e) {
  function t(i, n = tn) {
    let r;
    const o = it.getTransfer(n);
    if (i === Bi) return s.UNSIGNED_BYTE;
    if (i === pc) return s.UNSIGNED_SHORT_4_4_4_4;
    if (i === fc) return s.UNSIGNED_SHORT_5_5_5_1;
    if (i === _u) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (i === gu) return s.BYTE;
    if (i === vu) return s.SHORT;
    if (i === cr) return s.UNSIGNED_SHORT;
    if (i === uc) return s.INT;
    if (i === On) return s.UNSIGNED_INT;
    if (i === Ni) return s.FLOAT;
    if (i === Sr) return s.HALF_FLOAT;
    if (i === bu) return s.ALPHA;
    if (i === xu) return s.RGB;
    if (i === vi) return s.RGBA;
    if (i === wu) return s.LUMINANCE;
    if (i === yu) return s.LUMINANCE_ALPHA;
    if (i === xs) return s.DEPTH_COMPONENT;
    if (i === Ds) return s.DEPTH_STENCIL;
    if (i === Su) return s.RED;
    if (i === mc) return s.RED_INTEGER;
    if (i === Eu) return s.RG;
    if (i === gc) return s.RG_INTEGER;
    if (i === vc) return s.RGBA_INTEGER;
    if (i === Mo || i === Co || i === To || i === Ao) if (o === pt) if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
      if (i === Mo) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (i === Co) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (i === To) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (i === Ao) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else return null;
    else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
      if (i === Mo) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (i === Co) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (i === To) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (i === Ao) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    } else return null;
    if (i === xl || i === wl || i === yl || i === Sl) if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
      if (i === xl) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (i === wl) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (i === yl) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (i === Sl) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    } else return null;
    if (i === El || i === Ml || i === Cl) if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
      if (i === El || i === Ml) return o === pt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
      if (i === Cl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
    } else return null;
    if (i === Tl || i === Al || i === Pl || i === Rl || i === Dl || i === Ll || i === Il || i === Nl || i === kl || i === Ol || i === Ul || i === Fl || i === zl || i === Bl) if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
      if (i === Tl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (i === Al) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (i === Pl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (i === Rl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (i === Dl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (i === Ll) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (i === Il) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (i === Nl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (i === kl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (i === Ol) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (i === Ul) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (i === Fl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (i === zl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (i === Bl) return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
    } else return null;
    if (i === Po || i === Vl || i === Hl) if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
      if (i === Po) return o === pt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      if (i === Vl) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
      if (i === Hl) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
    } else return null;
    if (i === Mu || i === Gl || i === $l || i === Wl) if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
      if (i === Po) return r.COMPRESSED_RED_RGTC1_EXT;
      if (i === Gl) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (i === $l) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (i === Wl) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    } else return null;
    return i === Rs ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
  }
  return { convert: t };
}
class db extends ai {
  constructor(e = []) {
    super(), this.isArrayCamera = true, this.cameras = e;
  }
}
class Bt extends yt {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
}
const ub = { type: "move" };
class Va {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Bt(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Bt(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new I(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new I()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Bt(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new I(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new I()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
  }
  update(e, t, i) {
    let n = null, r = null, o = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = true;
        for (const _ of e.hand.values()) {
          const g = t.getJointPose(_, i), v = this._getHandJoint(c, _);
          g !== null && (v.matrix.fromArray(g.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = true, v.jointRadius = g.radius), v.visible = g !== null;
        }
        const h = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], u = h.position.distanceTo(d.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && u > f + m ? (c.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !c.inputState.pinching && u <= f - m && (c.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, r.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = false, r.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = false));
      a !== null && (n = t.getPose(e.targetRaySpace, i), n === null && r !== null && (n = r), n !== null && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = true, n.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = false, n.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(ub)));
    }
    return a !== null && (a.visible = n !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Bt();
      i.matrixAutoUpdate = false, i.visible = false, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
const pb = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, fb = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class mb {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, i) {
    if (this.texture === null) {
      const n = new Vt(), r = e.properties.get(n);
      r.__webglTexture = t.texture, (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = n;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, i = new pn({ vertexShader: pb, fragmentShader: fb, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } });
      this.mesh = new Ut(new Tr(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class gb extends Gn {
  constructor(e, t) {
    super();
    const i = this;
    let n = null, r = 1, o = null, a = "local-floor", l = 1, c = null, h = null, d = null, u = null, f = null, m = null;
    const _ = new mb(), g = t.getContextAttributes();
    let v = null, y = null;
    const x = [], S = [], A = new re();
    let R = null;
    const C = new ai();
    C.layers.enable(1), C.viewport = new xt();
    const P = new ai();
    P.layers.enable(2), P.viewport = new xt();
    const z = [C, P], w = new db();
    w.layers.enable(1), w.layers.enable(2);
    let E = null, N = null;
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(Y) {
      let se = x[Y];
      return se === void 0 && (se = new Va(), x[Y] = se), se.getTargetRaySpace();
    }, this.getControllerGrip = function(Y) {
      let se = x[Y];
      return se === void 0 && (se = new Va(), x[Y] = se), se.getGripSpace();
    }, this.getHand = function(Y) {
      let se = x[Y];
      return se === void 0 && (se = new Va(), x[Y] = se), se.getHandSpace();
    };
    function k(Y) {
      const se = S.indexOf(Y.inputSource);
      if (se === -1) return;
      const me = x[se];
      me !== void 0 && (me.update(Y.inputSource, Y.frame, c || o), me.dispatchEvent({ type: Y.type, data: Y.inputSource }));
    }
    function V() {
      n.removeEventListener("select", k), n.removeEventListener("selectstart", k), n.removeEventListener("selectend", k), n.removeEventListener("squeeze", k), n.removeEventListener("squeezestart", k), n.removeEventListener("squeezeend", k), n.removeEventListener("end", V), n.removeEventListener("inputsourceschange", q);
      for (let Y = 0; Y < x.length; Y++) {
        const se = S[Y];
        se !== null && (S[Y] = null, x[Y].disconnect(se));
      }
      E = null, N = null, _.reset(), e.setRenderTarget(v), f = null, u = null, d = null, n = null, y = null, Re.stop(), i.isPresenting = false, e.setPixelRatio(R), e.setSize(A.width, A.height, false), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(Y) {
      r = Y, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(Y) {
      a = Y, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || o;
    }, this.setReferenceSpace = function(Y) {
      c = Y;
    }, this.getBaseLayer = function() {
      return u !== null ? u : f;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return n;
    }, this.setSession = async function(Y) {
      if (n = Y, n !== null) {
        if (v = e.getRenderTarget(), n.addEventListener("select", k), n.addEventListener("selectstart", k), n.addEventListener("selectend", k), n.addEventListener("squeeze", k), n.addEventListener("squeezestart", k), n.addEventListener("squeezeend", k), n.addEventListener("end", V), n.addEventListener("inputsourceschange", q), g.xrCompatible !== true && await t.makeXRCompatible(), R = e.getPixelRatio(), e.getSize(A), n.renderState.layers === void 0) {
          const se = { antialias: g.antialias, alpha: true, depth: g.depth, stencil: g.stencil, framebufferScaleFactor: r };
          f = new XRWebGLLayer(n, t, se), n.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, false), y = new Un(f.framebufferWidth, f.framebufferHeight, { format: vi, type: Bi, colorSpace: e.outputColorSpace, stencilBuffer: g.stencil });
        } else {
          let se = null, me = null, de = null;
          g.depth && (de = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, se = g.stencil ? Ds : xs, me = g.stencil ? Rs : On);
          const Ne = { colorFormat: t.RGBA8, depthFormat: de, scaleFactor: r };
          d = new XRWebGLBinding(n, t), u = d.createProjectionLayer(Ne), n.updateRenderState({ layers: [u] }), e.setPixelRatio(1), e.setSize(u.textureWidth, u.textureHeight, false), y = new Un(u.textureWidth, u.textureHeight, { format: vi, type: Bi, depthTexture: new zu(u.textureWidth, u.textureHeight, me, void 0, void 0, void 0, void 0, void 0, void 0, se), stencilBuffer: g.stencil, colorSpace: e.outputColorSpace, samples: g.antialias ? 4 : 0, resolveDepthBuffer: u.ignoreDepthValues === false });
        }
        y.isXRRenderTarget = true, this.setFoveation(l), c = null, o = await n.requestReferenceSpace(a), Re.setContext(n), Re.start(), i.isPresenting = true, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (n !== null) return n.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return _.getDepthTexture();
    };
    function q(Y) {
      for (let se = 0; se < Y.removed.length; se++) {
        const me = Y.removed[se], de = S.indexOf(me);
        de >= 0 && (S[de] = null, x[de].disconnect(me));
      }
      for (let se = 0; se < Y.added.length; se++) {
        const me = Y.added[se];
        let de = S.indexOf(me);
        if (de === -1) {
          for (let Ie = 0; Ie < x.length; Ie++) if (Ie >= S.length) {
            S.push(me), de = Ie;
            break;
          } else if (S[Ie] === null) {
            S[Ie] = me, de = Ie;
            break;
          }
          if (de === -1) break;
        }
        const Ne = x[de];
        Ne && Ne.connect(me);
      }
    }
    const G = new I(), ee = new I();
    function O(Y, se, me) {
      G.setFromMatrixPosition(se.matrixWorld), ee.setFromMatrixPosition(me.matrixWorld);
      const de = G.distanceTo(ee), Ne = se.projectionMatrix.elements, Ie = me.projectionMatrix.elements, ze = Ne[14] / (Ne[10] - 1), We = Ne[14] / (Ne[10] + 1), te = (Ne[9] + 1) / Ne[5], L = (Ne[9] - 1) / Ne[5], he = (Ne[8] - 1) / Ne[0], ce = (Ie[8] + 1) / Ie[0], oe = ze * he, ue = ze * ce, Ae = de / (-he + ce), _e = Ae * -he;
      if (se.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale), Y.translateX(_e), Y.translateZ(Ae), Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale), Y.matrixWorldInverse.copy(Y.matrixWorld).invert(), Ne[10] === -1) Y.projectionMatrix.copy(se.projectionMatrix), Y.projectionMatrixInverse.copy(se.projectionMatrixInverse);
      else {
        const D = ze + Ae, M = We + Ae, H = oe - _e, Z = ue + (de - _e), ie = te * We / M * D, J = L * We / M * D;
        Y.projectionMatrix.makePerspective(H, Z, ie, J, D, M), Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert();
      }
    }
    function Q(Y, se) {
      se === null ? Y.matrixWorld.copy(Y.matrix) : Y.matrixWorld.multiplyMatrices(se.matrixWorld, Y.matrix), Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
    }
    this.updateCamera = function(Y) {
      if (n === null) return;
      let se = Y.near, me = Y.far;
      _.texture !== null && (_.depthNear > 0 && (se = _.depthNear), _.depthFar > 0 && (me = _.depthFar)), w.near = P.near = C.near = se, w.far = P.far = C.far = me, (E !== w.near || N !== w.far) && (n.updateRenderState({ depthNear: w.near, depthFar: w.far }), E = w.near, N = w.far);
      const de = Y.parent, Ne = w.cameras;
      Q(w, de);
      for (let Ie = 0; Ie < Ne.length; Ie++) Q(Ne[Ie], de);
      Ne.length === 2 ? O(w, C, P) : w.projectionMatrix.copy(C.projectionMatrix), X(Y, w, de);
    };
    function X(Y, se, me) {
      me === null ? Y.matrix.copy(se.matrixWorld) : (Y.matrix.copy(me.matrixWorld), Y.matrix.invert(), Y.matrix.multiply(se.matrixWorld)), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale), Y.updateMatrixWorld(true), Y.projectionMatrix.copy(se.projectionMatrix), Y.projectionMatrixInverse.copy(se.projectionMatrixInverse), Y.isPerspectiveCamera && (Y.fov = jl * 2 * Math.atan(1 / Y.projectionMatrix.elements[5]), Y.zoom = 1);
    }
    this.getCamera = function() {
      return w;
    }, this.getFoveation = function() {
      if (!(u === null && f === null)) return l;
    }, this.setFoveation = function(Y) {
      l = Y, u !== null && (u.fixedFoveation = Y), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = Y);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return _.getMesh(w);
    };
    let K = null;
    function Le(Y, se) {
      if (h = se.getViewerPose(c || o), m = se, h !== null) {
        const me = h.views;
        f !== null && (e.setRenderTargetFramebuffer(y, f.framebuffer), e.setRenderTarget(y));
        let de = false;
        me.length !== w.cameras.length && (w.cameras.length = 0, de = true);
        for (let Ie = 0; Ie < me.length; Ie++) {
          const ze = me[Ie];
          let We = null;
          if (f !== null) We = f.getViewport(ze);
          else {
            const L = d.getViewSubImage(u, ze);
            We = L.viewport, Ie === 0 && (e.setRenderTargetTextures(y, L.colorTexture, u.ignoreDepthValues ? void 0 : L.depthStencilTexture), e.setRenderTarget(y));
          }
          let te = z[Ie];
          te === void 0 && (te = new ai(), te.layers.enable(Ie), te.viewport = new xt(), z[Ie] = te), te.matrix.fromArray(ze.transform.matrix), te.matrix.decompose(te.position, te.quaternion, te.scale), te.projectionMatrix.fromArray(ze.projectionMatrix), te.projectionMatrixInverse.copy(te.projectionMatrix).invert(), te.viewport.set(We.x, We.y, We.width, We.height), Ie === 0 && (w.matrix.copy(te.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), de === true && w.cameras.push(te);
        }
        const Ne = n.enabledFeatures;
        if (Ne && Ne.includes("depth-sensing")) {
          const Ie = d.getDepthInformation(me[0]);
          Ie && Ie.isValid && Ie.texture && _.init(e, Ie, n.renderState);
        }
      }
      for (let me = 0; me < x.length; me++) {
        const de = S[me], Ne = x[me];
        de !== null && Ne !== void 0 && Ne.update(de, se, c || o);
      }
      K && K(Y, se), se.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: se }), m = null;
    }
    const Re = new Uu();
    Re.setAnimationLoop(Le), this.setAnimationLoop = function(Y) {
      K = Y;
    }, this.dispose = function() {
    };
  }
}
const En = new di(), vb = new rt();
function _b(s, e) {
  function t(g, v) {
    g.matrixAutoUpdate === true && g.updateMatrix(), v.value.copy(g.matrix);
  }
  function i(g, v) {
    v.color.getRGB(g.fogColor.value, Nu(s)), v.isFog ? (g.fogNear.value = v.near, g.fogFar.value = v.far) : v.isFogExp2 && (g.fogDensity.value = v.density);
  }
  function n(g, v, y, x, S) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial ? r(g, v) : v.isMeshToonMaterial ? (r(g, v), d(g, v)) : v.isMeshPhongMaterial ? (r(g, v), h(g, v)) : v.isMeshStandardMaterial ? (r(g, v), u(g, v), v.isMeshPhysicalMaterial && f(g, v, S)) : v.isMeshMatcapMaterial ? (r(g, v), m(g, v)) : v.isMeshDepthMaterial ? r(g, v) : v.isMeshDistanceMaterial ? (r(g, v), _(g, v)) : v.isMeshNormalMaterial ? r(g, v) : v.isLineBasicMaterial ? (o(g, v), v.isLineDashedMaterial && a(g, v)) : v.isPointsMaterial ? l(g, v, y, x) : v.isSpriteMaterial ? c(g, v) : v.isShadowMaterial ? (g.color.value.copy(v.color), g.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = false);
  }
  function r(g, v) {
    g.opacity.value = v.opacity, v.color && g.diffuse.value.copy(v.color), v.emissive && g.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (g.map.value = v.map, t(v.map, g.mapTransform)), v.alphaMap && (g.alphaMap.value = v.alphaMap, t(v.alphaMap, g.alphaMapTransform)), v.bumpMap && (g.bumpMap.value = v.bumpMap, t(v.bumpMap, g.bumpMapTransform), g.bumpScale.value = v.bumpScale, v.side === Kt && (g.bumpScale.value *= -1)), v.normalMap && (g.normalMap.value = v.normalMap, t(v.normalMap, g.normalMapTransform), g.normalScale.value.copy(v.normalScale), v.side === Kt && g.normalScale.value.negate()), v.displacementMap && (g.displacementMap.value = v.displacementMap, t(v.displacementMap, g.displacementMapTransform), g.displacementScale.value = v.displacementScale, g.displacementBias.value = v.displacementBias), v.emissiveMap && (g.emissiveMap.value = v.emissiveMap, t(v.emissiveMap, g.emissiveMapTransform)), v.specularMap && (g.specularMap.value = v.specularMap, t(v.specularMap, g.specularMapTransform)), v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest);
    const y = e.get(v), x = y.envMap, S = y.envMapRotation;
    x && (g.envMap.value = x, En.copy(S), En.x *= -1, En.y *= -1, En.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === false && (En.y *= -1, En.z *= -1), g.envMapRotation.value.setFromMatrix4(vb.makeRotationFromEuler(En)), g.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = v.reflectivity, g.ior.value = v.ior, g.refractionRatio.value = v.refractionRatio), v.lightMap && (g.lightMap.value = v.lightMap, g.lightMapIntensity.value = v.lightMapIntensity, t(v.lightMap, g.lightMapTransform)), v.aoMap && (g.aoMap.value = v.aoMap, g.aoMapIntensity.value = v.aoMapIntensity, t(v.aoMap, g.aoMapTransform));
  }
  function o(g, v) {
    g.diffuse.value.copy(v.color), g.opacity.value = v.opacity, v.map && (g.map.value = v.map, t(v.map, g.mapTransform));
  }
  function a(g, v) {
    g.dashSize.value = v.dashSize, g.totalSize.value = v.dashSize + v.gapSize, g.scale.value = v.scale;
  }
  function l(g, v, y, x) {
    g.diffuse.value.copy(v.color), g.opacity.value = v.opacity, g.size.value = v.size * y, g.scale.value = x * 0.5, v.map && (g.map.value = v.map, t(v.map, g.uvTransform)), v.alphaMap && (g.alphaMap.value = v.alphaMap, t(v.alphaMap, g.alphaMapTransform)), v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest);
  }
  function c(g, v) {
    g.diffuse.value.copy(v.color), g.opacity.value = v.opacity, g.rotation.value = v.rotation, v.map && (g.map.value = v.map, t(v.map, g.mapTransform)), v.alphaMap && (g.alphaMap.value = v.alphaMap, t(v.alphaMap, g.alphaMapTransform)), v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest);
  }
  function h(g, v) {
    g.specular.value.copy(v.specular), g.shininess.value = Math.max(v.shininess, 1e-4);
  }
  function d(g, v) {
    v.gradientMap && (g.gradientMap.value = v.gradientMap);
  }
  function u(g, v) {
    g.metalness.value = v.metalness, v.metalnessMap && (g.metalnessMap.value = v.metalnessMap, t(v.metalnessMap, g.metalnessMapTransform)), g.roughness.value = v.roughness, v.roughnessMap && (g.roughnessMap.value = v.roughnessMap, t(v.roughnessMap, g.roughnessMapTransform)), v.envMap && (g.envMapIntensity.value = v.envMapIntensity);
  }
  function f(g, v, y) {
    g.ior.value = v.ior, v.sheen > 0 && (g.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), g.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (g.sheenColorMap.value = v.sheenColorMap, t(v.sheenColorMap, g.sheenColorMapTransform)), v.sheenRoughnessMap && (g.sheenRoughnessMap.value = v.sheenRoughnessMap, t(v.sheenRoughnessMap, g.sheenRoughnessMapTransform))), v.clearcoat > 0 && (g.clearcoat.value = v.clearcoat, g.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (g.clearcoatMap.value = v.clearcoatMap, t(v.clearcoatMap, g.clearcoatMapTransform)), v.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap, t(v.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), v.clearcoatNormalMap && (g.clearcoatNormalMap.value = v.clearcoatNormalMap, t(v.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), v.side === Kt && g.clearcoatNormalScale.value.negate())), v.dispersion > 0 && (g.dispersion.value = v.dispersion), v.iridescence > 0 && (g.iridescence.value = v.iridescence, g.iridescenceIOR.value = v.iridescenceIOR, g.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (g.iridescenceMap.value = v.iridescenceMap, t(v.iridescenceMap, g.iridescenceMapTransform)), v.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = v.iridescenceThicknessMap, t(v.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), v.transmission > 0 && (g.transmission.value = v.transmission, g.transmissionSamplerMap.value = y.texture, g.transmissionSamplerSize.value.set(y.width, y.height), v.transmissionMap && (g.transmissionMap.value = v.transmissionMap, t(v.transmissionMap, g.transmissionMapTransform)), g.thickness.value = v.thickness, v.thicknessMap && (g.thicknessMap.value = v.thicknessMap, t(v.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = v.attenuationDistance, g.attenuationColor.value.copy(v.attenuationColor)), v.anisotropy > 0 && (g.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)), v.anisotropyMap && (g.anisotropyMap.value = v.anisotropyMap, t(v.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = v.specularIntensity, g.specularColor.value.copy(v.specularColor), v.specularColorMap && (g.specularColorMap.value = v.specularColorMap, t(v.specularColorMap, g.specularColorMapTransform)), v.specularIntensityMap && (g.specularIntensityMap.value = v.specularIntensityMap, t(v.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function m(g, v) {
    v.matcap && (g.matcap.value = v.matcap);
  }
  function _(g, v) {
    const y = e.get(v).light;
    g.referencePosition.value.setFromMatrixPosition(y.matrixWorld), g.nearDistance.value = y.shadow.camera.near, g.farDistance.value = y.shadow.camera.far;
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: n };
}
function bb(s, e, t, i) {
  let n = {}, r = {}, o = [];
  const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(y, x) {
    const S = x.program;
    i.uniformBlockBinding(y, S);
  }
  function c(y, x) {
    let S = n[y.id];
    S === void 0 && (m(y), S = h(y), n[y.id] = S, y.addEventListener("dispose", g));
    const A = x.program;
    i.updateUBOMapping(y, A);
    const R = e.render.frame;
    r[y.id] !== R && (u(y), r[y.id] = R);
  }
  function h(y) {
    const x = d();
    y.__bindingPointIndex = x;
    const S = s.createBuffer(), A = y.__size, R = y.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, S), s.bufferData(s.UNIFORM_BUFFER, A, R), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, x, S), S;
  }
  function d() {
    for (let y = 0; y < a; y++) if (o.indexOf(y) === -1) return o.push(y), y;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function u(y) {
    const x = n[y.id], S = y.uniforms, A = y.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, x);
    for (let R = 0, C = S.length; R < C; R++) {
      const P = Array.isArray(S[R]) ? S[R] : [S[R]];
      for (let z = 0, w = P.length; z < w; z++) {
        const E = P[z];
        if (f(E, R, z, A) === true) {
          const N = E.__offset, k = Array.isArray(E.value) ? E.value : [E.value];
          let V = 0;
          for (let q = 0; q < k.length; q++) {
            const G = k[q], ee = _(G);
            typeof G == "number" || typeof G == "boolean" ? (E.__data[0] = G, s.bufferSubData(s.UNIFORM_BUFFER, N + V, E.__data)) : G.isMatrix3 ? (E.__data[0] = G.elements[0], E.__data[1] = G.elements[1], E.__data[2] = G.elements[2], E.__data[3] = 0, E.__data[4] = G.elements[3], E.__data[5] = G.elements[4], E.__data[6] = G.elements[5], E.__data[7] = 0, E.__data[8] = G.elements[6], E.__data[9] = G.elements[7], E.__data[10] = G.elements[8], E.__data[11] = 0) : (G.toArray(E.__data, V), V += ee.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, N, E.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function f(y, x, S, A) {
    const R = y.value, C = x + "_" + S;
    if (A[C] === void 0) return typeof R == "number" || typeof R == "boolean" ? A[C] = R : A[C] = R.clone(), true;
    {
      const P = A[C];
      if (typeof R == "number" || typeof R == "boolean") {
        if (P !== R) return A[C] = R, true;
      } else if (P.equals(R) === false) return P.copy(R), true;
    }
    return false;
  }
  function m(y) {
    const x = y.uniforms;
    let S = 0;
    const A = 16;
    for (let C = 0, P = x.length; C < P; C++) {
      const z = Array.isArray(x[C]) ? x[C] : [x[C]];
      for (let w = 0, E = z.length; w < E; w++) {
        const N = z[w], k = Array.isArray(N.value) ? N.value : [N.value];
        for (let V = 0, q = k.length; V < q; V++) {
          const G = k[V], ee = _(G), O = S % A, Q = O % ee.boundary, X = O + Q;
          S += Q, X !== 0 && A - X < ee.storage && (S += A - X), N.__data = new Float32Array(ee.storage / Float32Array.BYTES_PER_ELEMENT), N.__offset = S, S += ee.storage;
        }
      }
    }
    const R = S % A;
    return R > 0 && (S += A - R), y.__size = S, y.__cache = {}, this;
  }
  function _(y) {
    const x = { boundary: 0, storage: 0 };
    return typeof y == "number" || typeof y == "boolean" ? (x.boundary = 4, x.storage = 4) : y.isVector2 ? (x.boundary = 8, x.storage = 8) : y.isVector3 || y.isColor ? (x.boundary = 16, x.storage = 12) : y.isVector4 ? (x.boundary = 16, x.storage = 16) : y.isMatrix3 ? (x.boundary = 48, x.storage = 48) : y.isMatrix4 ? (x.boundary = 64, x.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), x;
  }
  function g(y) {
    const x = y.target;
    x.removeEventListener("dispose", g);
    const S = o.indexOf(x.__bindingPointIndex);
    o.splice(S, 1), s.deleteBuffer(n[x.id]), delete n[x.id], delete r[x.id];
  }
  function v() {
    for (const y in n) s.deleteBuffer(n[y]);
    o = [], n = {}, r = {};
  }
  return { bind: l, update: c, dispose: v };
}
class xb {
  constructor(e = {}) {
    const { canvas: t = am(), context: i = null, depth: n = true, stencil: r = false, alpha: o = false, antialias: a = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = false } = e;
    this.isWebGLRenderer = true;
    let u;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      u = i.getContextAttributes().alpha;
    } else u = o;
    const f = new Uint32Array(4), m = new Int32Array(4);
    let _ = null, g = null;
    const v = [], y = [];
    this.domElement = t, this.debug = { checkShaderErrors: true, onShaderError: null }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = bi, this.toneMapping = ln, this.toneMappingExposure = 1;
    const x = this;
    let S = false, A = 0, R = 0, C = null, P = -1, z = null;
    const w = new xt(), E = new xt();
    let N = null;
    const k = new Xe(0);
    let V = 0, q = t.width, G = t.height, ee = 1, O = null, Q = null;
    const X = new xt(0, 0, q, G), K = new xt(0, 0, q, G);
    let Le = false;
    const Re = new xc();
    let Y = false, se = false;
    const me = new rt(), de = new rt(), Ne = new I(), Ie = new xt(), ze = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    let We = false;
    function te() {
      return C === null ? ee : 1;
    }
    let L = i;
    function he(T, F) {
      return t.getContext(T, F);
    }
    try {
      const T = { alpha: true, depth: n, stencil: r, antialias: a, premultipliedAlpha: l, preserveDrawingBuffer: c, powerPreference: h, failIfMajorPerformanceCaveat: d };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${hc}`), t.addEventListener("webglcontextlost", ne, false), t.addEventListener("webglcontextrestored", ge, false), t.addEventListener("webglcontextcreationerror", xe, false), L === null) {
        const F = "webgl2";
        if (L = he(F, T), L === null) throw he(F) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (T) {
      throw console.error("THREE.WebGLRenderer: " + T.message), T;
    }
    let ce, oe, ue, Ae, _e, D, M, H, Z, ie, J, Me, pe, we, je, ae, ye, Ue, Fe, Se, Ye, Ve, ct, U;
    function be() {
      ce = new M_(L), ce.init(), Ve = new hb(L, ce), oe = new b_(L, ce, e, Ve), ue = new ab(L), oe.reverseDepthBuffer && ue.buffers.depth.setReversed(true), Ae = new A_(L), _e = new X0(), D = new cb(L, ce, ue, _e, oe, Ve, Ae), M = new w_(x), H = new E_(x), Z = new km(L), ct = new v_(L, Z), ie = new C_(L, Z, Ae, ct), J = new R_(L, ie, Z, Ae), Fe = new P_(L, oe, D), ae = new x_(_e), Me = new W0(x, M, H, ce, oe, ct, ae), pe = new _b(x, _e), we = new Y0(), je = new eb(ce), Ue = new g_(x, M, H, ue, J, u, l), ye = new rb(x, J, oe), U = new bb(L, Ae, oe, ue), Se = new __(L, ce, Ae), Ye = new T_(L, ce, Ae), Ae.programs = Me.programs, x.capabilities = oe, x.extensions = ce, x.properties = _e, x.renderLists = we, x.shadowMap = ye, x.state = ue, x.info = Ae;
    }
    be();
    const j = new gb(x, L);
    this.xr = j, this.getContext = function() {
      return L;
    }, this.getContextAttributes = function() {
      return L.getContextAttributes();
    }, this.forceContextLoss = function() {
      const T = ce.get("WEBGL_lose_context");
      T && T.loseContext();
    }, this.forceContextRestore = function() {
      const T = ce.get("WEBGL_lose_context");
      T && T.restoreContext();
    }, this.getPixelRatio = function() {
      return ee;
    }, this.setPixelRatio = function(T) {
      T !== void 0 && (ee = T, this.setSize(q, G, false));
    }, this.getSize = function(T) {
      return T.set(q, G);
    }, this.setSize = function(T, F, $ = true) {
      if (j.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      q = T, G = F, t.width = Math.floor(T * ee), t.height = Math.floor(F * ee), $ === true && (t.style.width = T + "px", t.style.height = F + "px"), this.setViewport(0, 0, T, F);
    }, this.getDrawingBufferSize = function(T) {
      return T.set(q * ee, G * ee).floor();
    }, this.setDrawingBufferSize = function(T, F, $) {
      q = T, G = F, ee = $, t.width = Math.floor(T * $), t.height = Math.floor(F * $), this.setViewport(0, 0, T, F);
    }, this.getCurrentViewport = function(T) {
      return T.copy(w);
    }, this.getViewport = function(T) {
      return T.copy(X);
    }, this.setViewport = function(T, F, $, W) {
      T.isVector4 ? X.set(T.x, T.y, T.z, T.w) : X.set(T, F, $, W), ue.viewport(w.copy(X).multiplyScalar(ee).round());
    }, this.getScissor = function(T) {
      return T.copy(K);
    }, this.setScissor = function(T, F, $, W) {
      T.isVector4 ? K.set(T.x, T.y, T.z, T.w) : K.set(T, F, $, W), ue.scissor(E.copy(K).multiplyScalar(ee).round());
    }, this.getScissorTest = function() {
      return Le;
    }, this.setScissorTest = function(T) {
      ue.setScissorTest(Le = T);
    }, this.setOpaqueSort = function(T) {
      O = T;
    }, this.setTransparentSort = function(T) {
      Q = T;
    }, this.getClearColor = function(T) {
      return T.copy(Ue.getClearColor());
    }, this.setClearColor = function() {
      Ue.setClearColor.apply(Ue, arguments);
    }, this.getClearAlpha = function() {
      return Ue.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ue.setClearAlpha.apply(Ue, arguments);
    }, this.clear = function(T = true, F = true, $ = true) {
      let W = 0;
      if (T) {
        let B = false;
        if (C !== null) {
          const le = C.texture.format;
          B = le === vc || le === gc || le === mc;
        }
        if (B) {
          const le = C.texture.type, ve = le === Bi || le === On || le === cr || le === Rs || le === pc || le === fc, Ee = Ue.getClearColor(), Ce = Ue.getClearAlpha(), ke = Ee.r, Oe = Ee.g, Te = Ee.b;
          ve ? (f[0] = ke, f[1] = Oe, f[2] = Te, f[3] = Ce, L.clearBufferuiv(L.COLOR, 0, f)) : (m[0] = ke, m[1] = Oe, m[2] = Te, m[3] = Ce, L.clearBufferiv(L.COLOR, 0, m));
        } else W |= L.COLOR_BUFFER_BIT;
      }
      F && (W |= L.DEPTH_BUFFER_BIT, L.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1)), $ && (W |= L.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), L.clear(W);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", ne, false), t.removeEventListener("webglcontextrestored", ge, false), t.removeEventListener("webglcontextcreationerror", xe, false), we.dispose(), je.dispose(), _e.dispose(), M.dispose(), H.dispose(), J.dispose(), ct.dispose(), U.dispose(), Me.dispose(), j.dispose(), j.removeEventListener("sessionstart", ih), j.removeEventListener("sessionend", nh), _n.stop();
    };
    function ne(T) {
      T.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = true;
    }
    function ge() {
      console.log("THREE.WebGLRenderer: Context Restored."), S = false;
      const T = Ae.autoReset, F = ye.enabled, $ = ye.autoUpdate, W = ye.needsUpdate, B = ye.type;
      be(), Ae.autoReset = T, ye.enabled = F, ye.autoUpdate = $, ye.needsUpdate = W, ye.type = B;
    }
    function xe(T) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", T.statusMessage);
    }
    function Ke(T) {
      const F = T.target;
      F.removeEventListener("dispose", Ke), St(F);
    }
    function St(T) {
      $t(T), _e.remove(T);
    }
    function $t(T) {
      const F = _e.get(T).programs;
      F !== void 0 && (F.forEach(function($) {
        Me.releaseProgram($);
      }), T.isShaderMaterial && Me.releaseShaderCache(T));
    }
    this.renderBufferDirect = function(T, F, $, W, B, le) {
      F === null && (F = ze);
      const ve = B.isMesh && B.matrixWorld.determinant() < 0, Ee = hf(T, F, $, W, B);
      ue.setMaterial(W, ve);
      let Ce = $.index, ke = 1;
      if (W.wireframe === true) {
        if (Ce = ie.getWireframeAttribute($), Ce === void 0) return;
        ke = 2;
      }
      const Oe = $.drawRange, Te = $.attributes.position;
      let st = Oe.start * ke, dt = (Oe.start + Oe.count) * ke;
      le !== null && (st = Math.max(st, le.start * ke), dt = Math.min(dt, (le.start + le.count) * ke)), Ce !== null ? (st = Math.max(st, 0), dt = Math.min(dt, Ce.count)) : Te != null && (st = Math.max(st, 0), dt = Math.min(dt, Te.count));
      const _t = dt - st;
      if (_t < 0 || _t === 1 / 0) return;
      ct.setup(B, W, Ee, $, Ce);
      let Jt, et = Se;
      if (Ce !== null && (Jt = Z.get(Ce), et = Ye, et.setIndex(Jt)), B.isMesh) W.wireframe === true ? (ue.setLineWidth(W.wireframeLinewidth * te()), et.setMode(L.LINES)) : et.setMode(L.TRIANGLES);
      else if (B.isLine) {
        let Pe = W.linewidth;
        Pe === void 0 && (Pe = 1), ue.setLineWidth(Pe * te()), B.isLineSegments ? et.setMode(L.LINES) : B.isLineLoop ? et.setMode(L.LINE_LOOP) : et.setMode(L.LINE_STRIP);
      } else B.isPoints ? et.setMode(L.POINTS) : B.isSprite && et.setMode(L.TRIANGLES);
      if (B.isBatchedMesh) if (B._multiDrawInstances !== null) et.renderMultiDrawInstances(B._multiDrawStarts, B._multiDrawCounts, B._multiDrawCount, B._multiDrawInstances);
      else if (ce.get("WEBGL_multi_draw")) et.renderMultiDraw(B._multiDrawStarts, B._multiDrawCounts, B._multiDrawCount);
      else {
        const Pe = B._multiDrawStarts, Lt = B._multiDrawCounts, tt = B._multiDrawCount, ui = Ce ? Z.get(Ce).bytesPerElement : 1, jn = _e.get(W).currentProgram.getUniforms();
        for (let Qt = 0; Qt < tt; Qt++) jn.setValue(L, "_gl_DrawID", Qt), et.render(Pe[Qt] / ui, Lt[Qt]);
      }
      else if (B.isInstancedMesh) et.renderInstances(st, _t, B.count);
      else if ($.isInstancedBufferGeometry) {
        const Pe = $._maxInstanceCount !== void 0 ? $._maxInstanceCount : 1 / 0, Lt = Math.min($.instanceCount, Pe);
        et.renderInstances(st, _t, Lt);
      } else et.render(st, _t);
    };
    function Qe(T, F, $) {
      T.transparent === true && T.side === Yt && T.forceSinglePass === false ? (T.side = Kt, T.needsUpdate = true, Br(T, F, $), T.side = dn, T.needsUpdate = true, Br(T, F, $), T.side = Yt) : Br(T, F, $);
    }
    this.compile = function(T, F, $ = null) {
      $ === null && ($ = T), g = je.get($), g.init(F), y.push(g), $.traverseVisible(function(B) {
        B.isLight && B.layers.test(F.layers) && (g.pushLight(B), B.castShadow && g.pushShadow(B));
      }), T !== $ && T.traverseVisible(function(B) {
        B.isLight && B.layers.test(F.layers) && (g.pushLight(B), B.castShadow && g.pushShadow(B));
      }), g.setupLights();
      const W = /* @__PURE__ */ new Set();
      return T.traverse(function(B) {
        if (!(B.isMesh || B.isPoints || B.isLine || B.isSprite)) return;
        const le = B.material;
        if (le) if (Array.isArray(le)) for (let ve = 0; ve < le.length; ve++) {
          const Ee = le[ve];
          Qe(Ee, $, B), W.add(Ee);
        }
        else Qe(le, $, B), W.add(le);
      }), y.pop(), g = null, W;
    }, this.compileAsync = function(T, F, $ = null) {
      const W = this.compile(T, F, $);
      return new Promise((B) => {
        function le() {
          if (W.forEach(function(ve) {
            _e.get(ve).currentProgram.isReady() && W.delete(ve);
          }), W.size === 0) {
            B(T);
            return;
          }
          setTimeout(le, 10);
        }
        ce.get("KHR_parallel_shader_compile") !== null ? le() : setTimeout(le, 10);
      });
    };
    let Wt = null;
    function Ci(T) {
      Wt && Wt(T);
    }
    function ih() {
      _n.stop();
    }
    function nh() {
      _n.start();
    }
    const _n = new Uu();
    _n.setAnimationLoop(Ci), typeof self < "u" && _n.setContext(self), this.setAnimationLoop = function(T) {
      Wt = T, j.setAnimationLoop(T), T === null ? _n.stop() : _n.start();
    }, j.addEventListener("sessionstart", ih), j.addEventListener("sessionend", nh), this.render = function(T, F) {
      if (F !== void 0 && F.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (S === true) return;
      if (T.matrixWorldAutoUpdate === true && T.updateMatrixWorld(), F.parent === null && F.matrixWorldAutoUpdate === true && F.updateMatrixWorld(), j.enabled === true && j.isPresenting === true && (j.cameraAutoUpdate === true && j.updateCamera(F), F = j.getCamera()), T.isScene === true && T.onBeforeRender(x, T, F, C), g = je.get(T, y.length), g.init(F), y.push(g), de.multiplyMatrices(F.projectionMatrix, F.matrixWorldInverse), Re.setFromProjectionMatrix(de), se = this.localClippingEnabled, Y = ae.init(this.clippingPlanes, se), _ = we.get(T, v.length), _.init(), v.push(_), j.enabled === true && j.isPresenting === true) {
        const le = x.xr.getDepthSensingMesh();
        le !== null && la(le, F, -1 / 0, x.sortObjects);
      }
      la(T, F, 0, x.sortObjects), _.finish(), x.sortObjects === true && _.sort(O, Q), We = j.enabled === false || j.isPresenting === false || j.hasDepthSensing() === false, We && Ue.addToRenderList(_, T), this.info.render.frame++, Y === true && ae.beginShadows();
      const $ = g.state.shadowsArray;
      ye.render($, T, F), Y === true && ae.endShadows(), this.info.autoReset === true && this.info.reset();
      const W = _.opaque, B = _.transmissive;
      if (g.setupLights(), F.isArrayCamera) {
        const le = F.cameras;
        if (B.length > 0) for (let ve = 0, Ee = le.length; ve < Ee; ve++) {
          const Ce = le[ve];
          rh(W, B, T, Ce);
        }
        We && Ue.render(T);
        for (let ve = 0, Ee = le.length; ve < Ee; ve++) {
          const Ce = le[ve];
          sh(_, T, Ce, Ce.viewport);
        }
      } else B.length > 0 && rh(W, B, T, F), We && Ue.render(T), sh(_, T, F);
      C !== null && (D.updateMultisampleRenderTarget(C), D.updateRenderTargetMipmap(C)), T.isScene === true && T.onAfterRender(x, T, F), ct.resetDefaultState(), P = -1, z = null, y.pop(), y.length > 0 ? (g = y[y.length - 1], Y === true && ae.setGlobalState(x.clippingPlanes, g.state.camera)) : g = null, v.pop(), v.length > 0 ? _ = v[v.length - 1] : _ = null;
    };
    function la(T, F, $, W) {
      if (T.visible === false) return;
      if (T.layers.test(F.layers)) {
        if (T.isGroup) $ = T.renderOrder;
        else if (T.isLOD) T.autoUpdate === true && T.update(F);
        else if (T.isLight) g.pushLight(T), T.castShadow && g.pushShadow(T);
        else if (T.isSprite) {
          if (!T.frustumCulled || Re.intersectsSprite(T)) {
            W && Ie.setFromMatrixPosition(T.matrixWorld).applyMatrix4(de);
            const ve = J.update(T), Ee = T.material;
            Ee.visible && _.push(T, ve, Ee, $, Ie.z, null);
          }
        } else if ((T.isMesh || T.isLine || T.isPoints) && (!T.frustumCulled || Re.intersectsObject(T))) {
          const ve = J.update(T), Ee = T.material;
          if (W && (T.boundingSphere !== void 0 ? (T.boundingSphere === null && T.computeBoundingSphere(), Ie.copy(T.boundingSphere.center)) : (ve.boundingSphere === null && ve.computeBoundingSphere(), Ie.copy(ve.boundingSphere.center)), Ie.applyMatrix4(T.matrixWorld).applyMatrix4(de)), Array.isArray(Ee)) {
            const Ce = ve.groups;
            for (let ke = 0, Oe = Ce.length; ke < Oe; ke++) {
              const Te = Ce[ke], st = Ee[Te.materialIndex];
              st && st.visible && _.push(T, ve, st, $, Ie.z, Te);
            }
          } else Ee.visible && _.push(T, ve, Ee, $, Ie.z, null);
        }
      }
      const le = T.children;
      for (let ve = 0, Ee = le.length; ve < Ee; ve++) la(le[ve], F, $, W);
    }
    function sh(T, F, $, W) {
      const B = T.opaque, le = T.transmissive, ve = T.transparent;
      g.setupLightsView($), Y === true && ae.setGlobalState(x.clippingPlanes, $), W && ue.viewport(w.copy(W)), B.length > 0 && zr(B, F, $), le.length > 0 && zr(le, F, $), ve.length > 0 && zr(ve, F, $), ue.buffers.depth.setTest(true), ue.buffers.depth.setMask(true), ue.buffers.color.setMask(true), ue.setPolygonOffset(false);
    }
    function rh(T, F, $, W) {
      if (($.isScene === true ? $.overrideMaterial : null) !== null) return;
      g.state.transmissionRenderTarget[W.id] === void 0 && (g.state.transmissionRenderTarget[W.id] = new Un(1, 1, { generateMipmaps: true, type: ce.has("EXT_color_buffer_half_float") || ce.has("EXT_color_buffer_float") ? Sr : Bi, minFilter: Dn, samples: 4, stencilBuffer: r, resolveDepthBuffer: false, resolveStencilBuffer: false, colorSpace: it.workingColorSpace }));
      const le = g.state.transmissionRenderTarget[W.id], ve = W.viewport || w;
      le.setSize(ve.z, ve.w);
      const Ee = x.getRenderTarget();
      x.setRenderTarget(le), x.getClearColor(k), V = x.getClearAlpha(), V < 1 && x.setClearColor(16777215, 0.5), x.clear(), We && Ue.render($);
      const Ce = x.toneMapping;
      x.toneMapping = ln;
      const ke = W.viewport;
      if (W.viewport !== void 0 && (W.viewport = void 0), g.setupLightsView(W), Y === true && ae.setGlobalState(x.clippingPlanes, W), zr(T, $, W), D.updateMultisampleRenderTarget(le), D.updateRenderTargetMipmap(le), ce.has("WEBGL_multisampled_render_to_texture") === false) {
        let Oe = false;
        for (let Te = 0, st = F.length; Te < st; Te++) {
          const dt = F[Te], _t = dt.object, Jt = dt.geometry, et = dt.material, Pe = dt.group;
          if (et.side === Yt && _t.layers.test(W.layers)) {
            const Lt = et.side;
            et.side = Kt, et.needsUpdate = true, oh(_t, $, W, Jt, et, Pe), et.side = Lt, et.needsUpdate = true, Oe = true;
          }
        }
        Oe === true && (D.updateMultisampleRenderTarget(le), D.updateRenderTargetMipmap(le));
      }
      x.setRenderTarget(Ee), x.setClearColor(k, V), ke !== void 0 && (W.viewport = ke), x.toneMapping = Ce;
    }
    function zr(T, F, $) {
      const W = F.isScene === true ? F.overrideMaterial : null;
      for (let B = 0, le = T.length; B < le; B++) {
        const ve = T[B], Ee = ve.object, Ce = ve.geometry, ke = W === null ? ve.material : W, Oe = ve.group;
        Ee.layers.test($.layers) && oh(Ee, F, $, Ce, ke, Oe);
      }
    }
    function oh(T, F, $, W, B, le) {
      T.onBeforeRender(x, F, $, W, B, le), T.modelViewMatrix.multiplyMatrices($.matrixWorldInverse, T.matrixWorld), T.normalMatrix.getNormalMatrix(T.modelViewMatrix), B.onBeforeRender(x, F, $, W, T, le), B.transparent === true && B.side === Yt && B.forceSinglePass === false ? (B.side = Kt, B.needsUpdate = true, x.renderBufferDirect($, F, W, B, T, le), B.side = dn, B.needsUpdate = true, x.renderBufferDirect($, F, W, B, T, le), B.side = Yt) : x.renderBufferDirect($, F, W, B, T, le), T.onAfterRender(x, F, $, W, B, le);
    }
    function Br(T, F, $) {
      F.isScene !== true && (F = ze);
      const W = _e.get(T), B = g.state.lights, le = g.state.shadowsArray, ve = B.state.version, Ee = Me.getParameters(T, B.state, le, F, $), Ce = Me.getProgramCacheKey(Ee);
      let ke = W.programs;
      W.environment = T.isMeshStandardMaterial ? F.environment : null, W.fog = F.fog, W.envMap = (T.isMeshStandardMaterial ? H : M).get(T.envMap || W.environment), W.envMapRotation = W.environment !== null && T.envMap === null ? F.environmentRotation : T.envMapRotation, ke === void 0 && (T.addEventListener("dispose", Ke), ke = /* @__PURE__ */ new Map(), W.programs = ke);
      let Oe = ke.get(Ce);
      if (Oe !== void 0) {
        if (W.currentProgram === Oe && W.lightsStateVersion === ve) return lh(T, Ee), Oe;
      } else Ee.uniforms = Me.getUniforms(T), T.onBeforeCompile(Ee, x), Oe = Me.acquireProgram(Ee, Ce), ke.set(Ce, Oe), W.uniforms = Ee.uniforms;
      const Te = W.uniforms;
      return (!T.isShaderMaterial && !T.isRawShaderMaterial || T.clipping === true) && (Te.clippingPlanes = ae.uniform), lh(T, Ee), W.needsLights = uf(T), W.lightsStateVersion = ve, W.needsLights && (Te.ambientLightColor.value = B.state.ambient, Te.lightProbe.value = B.state.probe, Te.directionalLights.value = B.state.directional, Te.directionalLightShadows.value = B.state.directionalShadow, Te.spotLights.value = B.state.spot, Te.spotLightShadows.value = B.state.spotShadow, Te.rectAreaLights.value = B.state.rectArea, Te.ltc_1.value = B.state.rectAreaLTC1, Te.ltc_2.value = B.state.rectAreaLTC2, Te.pointLights.value = B.state.point, Te.pointLightShadows.value = B.state.pointShadow, Te.hemisphereLights.value = B.state.hemi, Te.directionalShadowMap.value = B.state.directionalShadowMap, Te.directionalShadowMatrix.value = B.state.directionalShadowMatrix, Te.spotShadowMap.value = B.state.spotShadowMap, Te.spotLightMatrix.value = B.state.spotLightMatrix, Te.spotLightMap.value = B.state.spotLightMap, Te.pointShadowMap.value = B.state.pointShadowMap, Te.pointShadowMatrix.value = B.state.pointShadowMatrix), W.currentProgram = Oe, W.uniformsList = null, Oe;
    }
    function ah(T) {
      if (T.uniformsList === null) {
        const F = T.currentProgram.getUniforms();
        T.uniformsList = Lo.seqWithValue(F.seq, T.uniforms);
      }
      return T.uniformsList;
    }
    function lh(T, F) {
      const $ = _e.get(T);
      $.outputColorSpace = F.outputColorSpace, $.batching = F.batching, $.batchingColor = F.batchingColor, $.instancing = F.instancing, $.instancingColor = F.instancingColor, $.instancingMorph = F.instancingMorph, $.skinning = F.skinning, $.morphTargets = F.morphTargets, $.morphNormals = F.morphNormals, $.morphColors = F.morphColors, $.morphTargetsCount = F.morphTargetsCount, $.numClippingPlanes = F.numClippingPlanes, $.numIntersection = F.numClipIntersection, $.vertexAlphas = F.vertexAlphas, $.vertexTangents = F.vertexTangents, $.toneMapping = F.toneMapping;
    }
    function hf(T, F, $, W, B) {
      F.isScene !== true && (F = ze), D.resetTextureUnits();
      const le = F.fog, ve = W.isMeshStandardMaterial ? F.environment : null, Ee = C === null ? x.outputColorSpace : C.isXRRenderTarget === true ? C.texture.colorSpace : gn, Ce = (W.isMeshStandardMaterial ? H : M).get(W.envMap || ve), ke = W.vertexColors === true && !!$.attributes.color && $.attributes.color.itemSize === 4, Oe = !!$.attributes.tangent && (!!W.normalMap || W.anisotropy > 0), Te = !!$.morphAttributes.position, st = !!$.morphAttributes.normal, dt = !!$.morphAttributes.color;
      let _t = ln;
      W.toneMapped && (C === null || C.isXRRenderTarget === true) && (_t = x.toneMapping);
      const Jt = $.morphAttributes.position || $.morphAttributes.normal || $.morphAttributes.color, et = Jt !== void 0 ? Jt.length : 0, Pe = _e.get(W), Lt = g.state.lights;
      if (Y === true && (se === true || T !== z)) {
        const si = T === z && W.id === P;
        ae.setState(W, T, si);
      }
      let tt = false;
      W.version === Pe.__version ? (Pe.needsLights && Pe.lightsStateVersion !== Lt.state.version || Pe.outputColorSpace !== Ee || B.isBatchedMesh && Pe.batching === false || !B.isBatchedMesh && Pe.batching === true || B.isBatchedMesh && Pe.batchingColor === true && B.colorTexture === null || B.isBatchedMesh && Pe.batchingColor === false && B.colorTexture !== null || B.isInstancedMesh && Pe.instancing === false || !B.isInstancedMesh && Pe.instancing === true || B.isSkinnedMesh && Pe.skinning === false || !B.isSkinnedMesh && Pe.skinning === true || B.isInstancedMesh && Pe.instancingColor === true && B.instanceColor === null || B.isInstancedMesh && Pe.instancingColor === false && B.instanceColor !== null || B.isInstancedMesh && Pe.instancingMorph === true && B.morphTexture === null || B.isInstancedMesh && Pe.instancingMorph === false && B.morphTexture !== null || Pe.envMap !== Ce || W.fog === true && Pe.fog !== le || Pe.numClippingPlanes !== void 0 && (Pe.numClippingPlanes !== ae.numPlanes || Pe.numIntersection !== ae.numIntersection) || Pe.vertexAlphas !== ke || Pe.vertexTangents !== Oe || Pe.morphTargets !== Te || Pe.morphNormals !== st || Pe.morphColors !== dt || Pe.toneMapping !== _t || Pe.morphTargetsCount !== et) && (tt = true) : (tt = true, Pe.__version = W.version);
      let ui = Pe.currentProgram;
      tt === true && (ui = Br(W, F, B));
      let jn = false, Qt = false, ca = false;
      const wt = ui.getUniforms(), $i = Pe.uniforms;
      if (ue.useProgram(ui.program) && (jn = true, Qt = true, ca = true), W.id !== P && (P = W.id, Qt = true), jn || z !== T) {
        oe.reverseDepthBuffer ? (me.copy(T.projectionMatrix), cm(me), hm(me), wt.setValue(L, "projectionMatrix", me)) : wt.setValue(L, "projectionMatrix", T.projectionMatrix), wt.setValue(L, "viewMatrix", T.matrixWorldInverse);
        const si = wt.map.cameraPosition;
        si !== void 0 && si.setValue(L, Ne.setFromMatrixPosition(T.matrixWorld)), oe.logarithmicDepthBuffer && wt.setValue(L, "logDepthBufFC", 2 / (Math.log(T.far + 1) / Math.LN2)), (W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshLambertMaterial || W.isMeshBasicMaterial || W.isMeshStandardMaterial || W.isShaderMaterial) && wt.setValue(L, "isOrthographic", T.isOrthographicCamera === true), z !== T && (z = T, Qt = true, ca = true);
      }
      if (B.isSkinnedMesh) {
        wt.setOptional(L, B, "bindMatrix"), wt.setOptional(L, B, "bindMatrixInverse");
        const si = B.skeleton;
        si && (si.boneTexture === null && si.computeBoneTexture(), wt.setValue(L, "boneTexture", si.boneTexture, D));
      }
      B.isBatchedMesh && (wt.setOptional(L, B, "batchingTexture"), wt.setValue(L, "batchingTexture", B._matricesTexture, D), wt.setOptional(L, B, "batchingIdTexture"), wt.setValue(L, "batchingIdTexture", B._indirectTexture, D), wt.setOptional(L, B, "batchingColorTexture"), B._colorsTexture !== null && wt.setValue(L, "batchingColorTexture", B._colorsTexture, D));
      const ha = $.morphAttributes;
      if ((ha.position !== void 0 || ha.normal !== void 0 || ha.color !== void 0) && Fe.update(B, $, ui), (Qt || Pe.receiveShadow !== B.receiveShadow) && (Pe.receiveShadow = B.receiveShadow, wt.setValue(L, "receiveShadow", B.receiveShadow)), W.isMeshGouraudMaterial && W.envMap !== null && ($i.envMap.value = Ce, $i.flipEnvMap.value = Ce.isCubeTexture && Ce.isRenderTargetTexture === false ? -1 : 1), W.isMeshStandardMaterial && W.envMap === null && F.environment !== null && ($i.envMapIntensity.value = F.environmentIntensity), Qt && (wt.setValue(L, "toneMappingExposure", x.toneMappingExposure), Pe.needsLights && df($i, ca), le && W.fog === true && pe.refreshFogUniforms($i, le), pe.refreshMaterialUniforms($i, W, ee, G, g.state.transmissionRenderTarget[T.id]), Lo.upload(L, ah(Pe), $i, D)), W.isShaderMaterial && W.uniformsNeedUpdate === true && (Lo.upload(L, ah(Pe), $i, D), W.uniformsNeedUpdate = false), W.isSpriteMaterial && wt.setValue(L, "center", B.center), wt.setValue(L, "modelViewMatrix", B.modelViewMatrix), wt.setValue(L, "normalMatrix", B.normalMatrix), wt.setValue(L, "modelMatrix", B.matrixWorld), W.isShaderMaterial || W.isRawShaderMaterial) {
        const si = W.uniformsGroups;
        for (let da = 0, pf = si.length; da < pf; da++) {
          const ch = si[da];
          U.update(ch, ui), U.bind(ch, ui);
        }
      }
      return ui;
    }
    function df(T, F) {
      T.ambientLightColor.needsUpdate = F, T.lightProbe.needsUpdate = F, T.directionalLights.needsUpdate = F, T.directionalLightShadows.needsUpdate = F, T.pointLights.needsUpdate = F, T.pointLightShadows.needsUpdate = F, T.spotLights.needsUpdate = F, T.spotLightShadows.needsUpdate = F, T.rectAreaLights.needsUpdate = F, T.hemisphereLights.needsUpdate = F;
    }
    function uf(T) {
      return T.isMeshLambertMaterial || T.isMeshToonMaterial || T.isMeshPhongMaterial || T.isMeshStandardMaterial || T.isShadowMaterial || T.isShaderMaterial && T.lights === true;
    }
    this.getActiveCubeFace = function() {
      return A;
    }, this.getActiveMipmapLevel = function() {
      return R;
    }, this.getRenderTarget = function() {
      return C;
    }, this.setRenderTargetTextures = function(T, F, $) {
      _e.get(T.texture).__webglTexture = F, _e.get(T.depthTexture).__webglTexture = $;
      const W = _e.get(T);
      W.__hasExternalTextures = true, W.__autoAllocateDepthBuffer = $ === void 0, W.__autoAllocateDepthBuffer || ce.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), W.__useRenderToTexture = false);
    }, this.setRenderTargetFramebuffer = function(T, F) {
      const $ = _e.get(T);
      $.__webglFramebuffer = F, $.__useDefaultFramebuffer = F === void 0;
    }, this.setRenderTarget = function(T, F = 0, $ = 0) {
      C = T, A = F, R = $;
      let W = true, B = null, le = false, ve = false;
      if (T) {
        const Ce = _e.get(T);
        if (Ce.__useDefaultFramebuffer !== void 0) ue.bindFramebuffer(L.FRAMEBUFFER, null), W = false;
        else if (Ce.__webglFramebuffer === void 0) D.setupRenderTarget(T);
        else if (Ce.__hasExternalTextures) D.rebindTextures(T, _e.get(T.texture).__webglTexture, _e.get(T.depthTexture).__webglTexture);
        else if (T.depthBuffer) {
          const Te = T.depthTexture;
          if (Ce.__boundDepthTexture !== Te) {
            if (Te !== null && _e.has(Te) && (T.width !== Te.image.width || T.height !== Te.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            D.setupDepthRenderbuffer(T);
          }
        }
        const ke = T.texture;
        (ke.isData3DTexture || ke.isDataArrayTexture || ke.isCompressedArrayTexture) && (ve = true);
        const Oe = _e.get(T).__webglFramebuffer;
        T.isWebGLCubeRenderTarget ? (Array.isArray(Oe[F]) ? B = Oe[F][$] : B = Oe[F], le = true) : T.samples > 0 && D.useMultisampledRTT(T) === false ? B = _e.get(T).__webglMultisampledFramebuffer : Array.isArray(Oe) ? B = Oe[$] : B = Oe, w.copy(T.viewport), E.copy(T.scissor), N = T.scissorTest;
      } else w.copy(X).multiplyScalar(ee).floor(), E.copy(K).multiplyScalar(ee).floor(), N = Le;
      if (ue.bindFramebuffer(L.FRAMEBUFFER, B) && W && ue.drawBuffers(T, B), ue.viewport(w), ue.scissor(E), ue.setScissorTest(N), le) {
        const Ce = _e.get(T.texture);
        L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + F, Ce.__webglTexture, $);
      } else if (ve) {
        const Ce = _e.get(T.texture), ke = F || 0;
        L.framebufferTextureLayer(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ce.__webglTexture, $ || 0, ke);
      }
      P = -1;
    }, this.readRenderTargetPixels = function(T, F, $, W, B, le, ve) {
      if (!(T && T.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ee = _e.get(T).__webglFramebuffer;
      if (T.isWebGLCubeRenderTarget && ve !== void 0 && (Ee = Ee[ve]), Ee) {
        ue.bindFramebuffer(L.FRAMEBUFFER, Ee);
        try {
          const Ce = T.texture, ke = Ce.format, Oe = Ce.type;
          if (!oe.textureFormatReadable(ke)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!oe.textureTypeReadable(Oe)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          F >= 0 && F <= T.width - W && $ >= 0 && $ <= T.height - B && L.readPixels(F, $, W, B, Ve.convert(ke), Ve.convert(Oe), le);
        } finally {
          const Ce = C !== null ? _e.get(C).__webglFramebuffer : null;
          ue.bindFramebuffer(L.FRAMEBUFFER, Ce);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(T, F, $, W, B, le, ve) {
      if (!(T && T.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ee = _e.get(T).__webglFramebuffer;
      if (T.isWebGLCubeRenderTarget && ve !== void 0 && (Ee = Ee[ve]), Ee) {
        const Ce = T.texture, ke = Ce.format, Oe = Ce.type;
        if (!oe.textureFormatReadable(ke)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!oe.textureTypeReadable(Oe)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (F >= 0 && F <= T.width - W && $ >= 0 && $ <= T.height - B) {
          ue.bindFramebuffer(L.FRAMEBUFFER, Ee);
          const Te = L.createBuffer();
          L.bindBuffer(L.PIXEL_PACK_BUFFER, Te), L.bufferData(L.PIXEL_PACK_BUFFER, le.byteLength, L.STREAM_READ), L.readPixels(F, $, W, B, Ve.convert(ke), Ve.convert(Oe), 0);
          const st = C !== null ? _e.get(C).__webglFramebuffer : null;
          ue.bindFramebuffer(L.FRAMEBUFFER, st);
          const dt = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return L.flush(), await lm(L, dt, 4), L.bindBuffer(L.PIXEL_PACK_BUFFER, Te), L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, le), L.deleteBuffer(Te), L.deleteSync(dt), le;
        } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(T, F = null, $ = 0) {
      T.isTexture !== true && (Do("WebGLRenderer: copyFramebufferToTexture function signature has changed."), F = arguments[0] || null, T = arguments[1]);
      const W = Math.pow(2, -$), B = Math.floor(T.image.width * W), le = Math.floor(T.image.height * W), ve = F !== null ? F.x : 0, Ee = F !== null ? F.y : 0;
      D.setTexture2D(T, 0), L.copyTexSubImage2D(L.TEXTURE_2D, $, 0, 0, ve, Ee, B, le), ue.unbindTexture();
    }, this.copyTextureToTexture = function(T, F, $ = null, W = null, B = 0) {
      T.isTexture !== true && (Do("WebGLRenderer: copyTextureToTexture function signature has changed."), W = arguments[0] || null, T = arguments[1], F = arguments[2], B = arguments[3] || 0, $ = null);
      let le, ve, Ee, Ce, ke, Oe;
      $ !== null ? (le = $.max.x - $.min.x, ve = $.max.y - $.min.y, Ee = $.min.x, Ce = $.min.y) : (le = T.image.width, ve = T.image.height, Ee = 0, Ce = 0), W !== null ? (ke = W.x, Oe = W.y) : (ke = 0, Oe = 0);
      const Te = Ve.convert(F.format), st = Ve.convert(F.type);
      D.setTexture2D(F, 0), L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, F.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, F.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, F.unpackAlignment);
      const dt = L.getParameter(L.UNPACK_ROW_LENGTH), _t = L.getParameter(L.UNPACK_IMAGE_HEIGHT), Jt = L.getParameter(L.UNPACK_SKIP_PIXELS), et = L.getParameter(L.UNPACK_SKIP_ROWS), Pe = L.getParameter(L.UNPACK_SKIP_IMAGES), Lt = T.isCompressedTexture ? T.mipmaps[B] : T.image;
      L.pixelStorei(L.UNPACK_ROW_LENGTH, Lt.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, Lt.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Ee), L.pixelStorei(L.UNPACK_SKIP_ROWS, Ce), T.isDataTexture ? L.texSubImage2D(L.TEXTURE_2D, B, ke, Oe, le, ve, Te, st, Lt.data) : T.isCompressedTexture ? L.compressedTexSubImage2D(L.TEXTURE_2D, B, ke, Oe, Lt.width, Lt.height, Te, Lt.data) : L.texSubImage2D(L.TEXTURE_2D, B, ke, Oe, le, ve, Te, st, Lt), L.pixelStorei(L.UNPACK_ROW_LENGTH, dt), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, _t), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Jt), L.pixelStorei(L.UNPACK_SKIP_ROWS, et), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Pe), B === 0 && F.generateMipmaps && L.generateMipmap(L.TEXTURE_2D), ue.unbindTexture();
    }, this.copyTextureToTexture3D = function(T, F, $ = null, W = null, B = 0) {
      T.isTexture !== true && (Do("WebGLRenderer: copyTextureToTexture3D function signature has changed."), $ = arguments[0] || null, W = arguments[1] || null, T = arguments[2], F = arguments[3], B = arguments[4] || 0);
      let le, ve, Ee, Ce, ke, Oe, Te, st, dt;
      const _t = T.isCompressedTexture ? T.mipmaps[B] : T.image;
      $ !== null ? (le = $.max.x - $.min.x, ve = $.max.y - $.min.y, Ee = $.max.z - $.min.z, Ce = $.min.x, ke = $.min.y, Oe = $.min.z) : (le = _t.width, ve = _t.height, Ee = _t.depth, Ce = 0, ke = 0, Oe = 0), W !== null ? (Te = W.x, st = W.y, dt = W.z) : (Te = 0, st = 0, dt = 0);
      const Jt = Ve.convert(F.format), et = Ve.convert(F.type);
      let Pe;
      if (F.isData3DTexture) D.setTexture3D(F, 0), Pe = L.TEXTURE_3D;
      else if (F.isDataArrayTexture || F.isCompressedArrayTexture) D.setTexture2DArray(F, 0), Pe = L.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, F.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, F.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, F.unpackAlignment);
      const Lt = L.getParameter(L.UNPACK_ROW_LENGTH), tt = L.getParameter(L.UNPACK_IMAGE_HEIGHT), ui = L.getParameter(L.UNPACK_SKIP_PIXELS), jn = L.getParameter(L.UNPACK_SKIP_ROWS), Qt = L.getParameter(L.UNPACK_SKIP_IMAGES);
      L.pixelStorei(L.UNPACK_ROW_LENGTH, _t.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, _t.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Ce), L.pixelStorei(L.UNPACK_SKIP_ROWS, ke), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Oe), T.isDataTexture || T.isData3DTexture ? L.texSubImage3D(Pe, B, Te, st, dt, le, ve, Ee, Jt, et, _t.data) : F.isCompressedArrayTexture ? L.compressedTexSubImage3D(Pe, B, Te, st, dt, le, ve, Ee, Jt, _t.data) : L.texSubImage3D(Pe, B, Te, st, dt, le, ve, Ee, Jt, et, _t), L.pixelStorei(L.UNPACK_ROW_LENGTH, Lt), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, tt), L.pixelStorei(L.UNPACK_SKIP_PIXELS, ui), L.pixelStorei(L.UNPACK_SKIP_ROWS, jn), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Qt), B === 0 && F.generateMipmaps && L.generateMipmap(Pe), ue.unbindTexture();
    }, this.initRenderTarget = function(T) {
      _e.get(T).__webglFramebuffer === void 0 && D.setupRenderTarget(T);
    }, this.initTexture = function(T) {
      T.isCubeTexture ? D.setTextureCube(T, 0) : T.isData3DTexture ? D.setTexture3D(T, 0) : T.isDataArrayTexture || T.isCompressedArrayTexture ? D.setTexture2DArray(T, 0) : D.setTexture2D(T, 0), ue.unbindTexture();
    }, this.resetState = function() {
      A = 0, R = 0, C = null, ue.reset(), ct.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return ki;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === _c ? "display-p3" : "srgb", t.unpackColorSpace = it.workingColorSpace === ea ? "display-p3" : "srgb";
  }
}
class wb extends yt {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new di(), this.environmentIntensity = 1, this.environmentRotation = new di(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class yb {
  constructor(e, t) {
    this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Xl, this.updateRanges = [], this.version = 0, this.uuid = Ui();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ui()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ui()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
const Ft = new I();
class Go {
  constructor(e, t, i, n = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.applyMatrix4(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.applyNormalMatrix(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.transformDirection(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = wi(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = ot(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
  }
  setX(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = ot(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = wi(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), i = ot(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ot(t, this.array), i = ot(i, this.array), n = ot(n, this.array), r = ot(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r]);
      }
      return new _i(new this.array.constructor(t), this.itemSize, this.normalized);
    } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Go(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
    } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class Sb extends vn {
  constructor(e) {
    super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Xe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let ls;
const Xs = new I(), cs = new I(), hs = new I(), ds = new re(), js = new re(), $u = new rt(), co = new I(), Ys = new I(), ho = new I(), sd = new re(), Ha = new re(), rd = new re();
class Eb extends yt {
  constructor(e = new Sb()) {
    if (super(), this.isSprite = true, this.type = "Sprite", ls === void 0) {
      ls = new ft();
      const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), i = new yb(t, 5);
      ls.setIndex([0, 1, 2, 0, 2, 3]), ls.setAttribute("position", new Go(i, 3, 0, false)), ls.setAttribute("uv", new Go(i, 2, 3, false));
    }
    this.geometry = ls, this.material = e, this.center = new re(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), cs.setFromMatrixScale(this.matrixWorld), $u.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), hs.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && cs.multiplyScalar(-hs.z);
    const i = this.material.rotation;
    let n, r;
    i !== 0 && (r = Math.cos(i), n = Math.sin(i));
    const o = this.center;
    uo(co.set(-0.5, -0.5, 0), hs, o, cs, n, r), uo(Ys.set(0.5, -0.5, 0), hs, o, cs, n, r), uo(ho.set(0.5, 0.5, 0), hs, o, cs, n, r), sd.set(0, 0), Ha.set(1, 0), rd.set(1, 1);
    let a = e.ray.intersectTriangle(co, Ys, ho, false, Xs);
    if (a === null && (uo(Ys.set(-0.5, 0.5, 0), hs, o, cs, n, r), Ha.set(0, 1), a = e.ray.intersectTriangle(co, ho, Ys, false, Xs), a === null)) return;
    const l = e.ray.origin.distanceTo(Xs);
    l < e.near || l > e.far || t.push({ distance: l, point: Xs.clone(), uv: li.getInterpolation(Xs, co, Ys, ho, sd, Ha, rd, new re()), face: null, object: this });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function uo(s, e, t, i, n, r) {
  ds.subVectors(s, t).addScalar(0.5).multiply(i), n !== void 0 ? (js.x = r * ds.x - n * ds.y, js.y = n * ds.x + r * ds.y) : js.copy(ds), s.copy(e), s.x += js.x, s.y += js.y, s.applyMatrix4($u);
}
class fn extends vn {
  constructor(e) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Xe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const $o = new I(), Wo = new I(), od = new rt(), qs = new Cr(), po = new Mr(), Ga = new I(), ad = new I();
class ys extends yt {
  constructor(e = new ft(), t = new fn()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let n = 1, r = t.count; n < r; n++) $o.fromBufferAttribute(t, n - 1), Wo.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += $o.distanceTo(Wo);
      e.setAttribute("lineDistance", new lt(i, 1));
    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), po.copy(i.boundingSphere), po.applyMatrix4(n), po.radius += r, e.ray.intersectsSphere(po) === false) return;
    od.copy(n).invert(), qs.copy(e.ray).applyMatrix4(od);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = this.isLineSegments ? 2 : 1, h = i.index, u = i.attributes.position;
    if (h !== null) {
      const f = Math.max(0, o.start), m = Math.min(h.count, o.start + o.count);
      for (let _ = f, g = m - 1; _ < g; _ += c) {
        const v = h.getX(_), y = h.getX(_ + 1), x = fo(this, e, qs, l, v, y);
        x && t.push(x);
      }
      if (this.isLineLoop) {
        const _ = h.getX(m - 1), g = h.getX(f), v = fo(this, e, qs, l, _, g);
        v && t.push(v);
      }
    } else {
      const f = Math.max(0, o.start), m = Math.min(u.count, o.start + o.count);
      for (let _ = f, g = m - 1; _ < g; _ += c) {
        const v = fo(this, e, qs, l, _, _ + 1);
        v && t.push(v);
      }
      if (this.isLineLoop) {
        const _ = fo(this, e, qs, l, m - 1, f);
        _ && t.push(_);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function fo(s, e, t, i, n, r) {
  const o = s.geometry.attributes.position;
  if ($o.fromBufferAttribute(o, n), Wo.fromBufferAttribute(o, r), t.distanceSqToSegment($o, Wo, Ga, ad) > i) return;
  Ga.applyMatrix4(s.matrixWorld);
  const l = e.ray.origin.distanceTo(Ga);
  if (!(l < e.near || l > e.far)) return { distance: l, point: ad.clone().applyMatrix4(s.matrixWorld), index: n, face: null, faceIndex: null, barycoord: null, object: s };
}
const ld = new I(), cd = new I();
class yc extends ys {
  constructor(e, t) {
    super(e, t), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let n = 0, r = t.count; n < r; n += 2) ld.fromBufferAttribute(t, n), cd.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + ld.distanceTo(cd);
      e.setAttribute("lineDistance", new lt(i, 1));
    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Xo extends vn {
  constructor(e) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Xe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const hd = new rt(), ql = new Cr(), mo = new Mr(), go = new I();
class Kl extends yt {
  constructor(e = new ft(), t = new Xo()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Points.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), mo.copy(i.boundingSphere), mo.applyMatrix4(n), mo.radius += r, e.ray.intersectsSphere(mo) === false) return;
    hd.copy(n).invert(), ql.copy(e.ray).applyMatrix4(hd);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = i.index, d = i.attributes.position;
    if (c !== null) {
      const u = Math.max(0, o.start), f = Math.min(c.count, o.start + o.count);
      for (let m = u, _ = f; m < _; m++) {
        const g = c.getX(m);
        go.fromBufferAttribute(d, g), dd(go, g, l, n, e, t, this);
      }
    } else {
      const u = Math.max(0, o.start), f = Math.min(d.count, o.start + o.count);
      for (let m = u, _ = f; m < _; m++) go.fromBufferAttribute(d, m), dd(go, m, l, n, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const n = t[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function dd(s, e, t, i, n, r, o) {
  const a = ql.distanceSqToPoint(s);
  if (a < t) {
    const l = new I();
    ql.closestPointToPoint(s, l), l.applyMatrix4(i);
    const c = n.ray.origin.distanceTo(l);
    if (c < n.near || c > n.far) return;
    r.push({ distance: c, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, faceIndex: null, barycoord: null, object: o });
  }
}
class Mi {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    const t = [];
    let i, n = this.getPoint(0), r = 0;
    t.push(0);
    for (let o = 1; o <= e; o++) i = this.getPoint(o / e), r += i.distanceTo(n), t.push(r), n = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let n = 0;
    const r = i.length;
    let o;
    t ? o = t : o = e * i[r - 1];
    let a = 0, l = r - 1, c;
    for (; a <= l; ) if (n = Math.floor(a + (l - a) / 2), c = i[n] - o, c < 0) a = n + 1;
    else if (c > 0) l = n - 1;
    else {
      l = n;
      break;
    }
    if (n = l, i[n] === o) return n / (r - 1);
    const h = i[n], u = i[n + 1] - h, f = (o - h) / u;
    return (n + f) / (r - 1);
  }
  getTangent(e, t) {
    let n = e - 1e-4, r = e + 1e-4;
    n < 0 && (n = 0), r > 1 && (r = 1);
    const o = this.getPoint(n), a = this.getPoint(r), l = t || (o.isVector2 ? new re() : new I());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new I(), n = [], r = [], o = [], a = new I(), l = new rt();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      n[f] = this.getTangentAt(m, new I());
    }
    r[0] = new I(), o[0] = new I();
    let c = Number.MAX_VALUE;
    const h = Math.abs(n[0].x), d = Math.abs(n[0].y), u = Math.abs(n[0].z);
    h <= c && (c = h, i.set(1, 0, 0)), d <= c && (c = d, i.set(0, 1, 0)), u <= c && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), o[0].crossVectors(n[0], r[0]);
    for (let f = 1; f <= e; f++) {
      if (r[f] = r[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(n[f - 1], n[f]), a.length() > Number.EPSILON) {
        a.normalize();
        const m = Math.acos(It(n[f - 1].dot(n[f]), -1, 1));
        r[f].applyMatrix4(l.makeRotationAxis(a, m));
      }
      o[f].crossVectors(n[f], r[f]);
    }
    if (t === true) {
      let f = Math.acos(It(r[0].dot(r[e]), -1, 1));
      f /= e, n[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++) r[m].applyMatrix4(l.makeRotationAxis(n[m], f * m)), o[m].crossVectors(n[m], r[m]);
    }
    return { tangents: n, normals: r, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Sc extends Mi {
  constructor(e = 0, t = 0, i = 1, n = 1, r = 0, o = Math.PI * 2, a = false, l = 0) {
    super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
  }
  getPoint(e, t = new re()) {
    const i = t, n = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += n;
    for (; r > n; ) r -= n;
    r < Number.EPSILON && (o ? r = 0 : r = n), this.aClockwise === true && !o && (r === n ? r = -n : r = r - n);
    const a = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), u = l - this.aX, f = c - this.aY;
      l = u * h - f * d + this.aX, c = u * d + f * h + this.aY;
    }
    return i.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Mb extends Sc {
  constructor(e, t, i, n, r, o) {
    super(e, t, i, i, n, r, o), this.isArcCurve = true, this.type = "ArcCurve";
  }
}
function Ec() {
  let s = 0, e = 0, t = 0, i = 0;
  function n(r, o, a, l) {
    s = r, e = a, t = -3 * r + 3 * o - 2 * a - l, i = 2 * r - 2 * o + a + l;
  }
  return { initCatmullRom: function(r, o, a, l, c) {
    n(o, a, c * (a - r), c * (l - o));
  }, initNonuniformCatmullRom: function(r, o, a, l, c, h, d) {
    let u = (o - r) / c - (a - r) / (c + h) + (a - o) / h, f = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
    u *= h, f *= h, n(o, a, u, f);
  }, calc: function(r) {
    const o = r * r, a = o * r;
    return s + e * r + t * o + i * a;
  } };
}
const vo = new I(), $a = new Ec(), Wa = new Ec(), Xa = new Ec();
class Cb extends Mi {
  constructor(e = [], t = false, i = "centripetal", n = 0.5) {
    super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
  }
  getPoint(e, t = new I()) {
    const i = t, n = this.points, r = n.length, o = (r - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), l = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
    let c, h;
    this.closed || a > 0 ? c = n[(a - 1) % r] : (vo.subVectors(n[0], n[1]).add(n[0]), c = vo);
    const d = n[a % r], u = n[(a + 1) % r];
    if (this.closed || a + 2 < r ? h = n[(a + 2) % r] : (vo.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), h = vo), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(d), f), _ = Math.pow(d.distanceToSquared(u), f), g = Math.pow(u.distanceToSquared(h), f);
      _ < 1e-4 && (_ = 1), m < 1e-4 && (m = _), g < 1e-4 && (g = _), $a.initNonuniformCatmullRom(c.x, d.x, u.x, h.x, m, _, g), Wa.initNonuniformCatmullRom(c.y, d.y, u.y, h.y, m, _, g), Xa.initNonuniformCatmullRom(c.z, d.z, u.z, h.z, m, _, g);
    } else this.curveType === "catmullrom" && ($a.initCatmullRom(c.x, d.x, u.x, h.x, this.tension), Wa.initCatmullRom(c.y, d.y, u.y, h.y, this.tension), Xa.initCatmullRom(c.z, d.z, u.z, h.z, this.tension));
    return i.set($a.calc(l), Wa.calc(l), Xa.calc(l)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new I().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function ud(s, e, t, i, n) {
  const r = (i - e) * 0.5, o = (n - t) * 0.5, a = s * s, l = s * a;
  return (2 * t - 2 * i + r + o) * l + (-3 * t + 3 * i - 2 * r - o) * a + r * s + t;
}
function Tb(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function Ab(s, e) {
  return 2 * (1 - s) * s * e;
}
function Pb(s, e) {
  return s * s * e;
}
function rr(s, e, t, i) {
  return Tb(s, e) + Ab(s, t) + Pb(s, i);
}
function Rb(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function Db(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function Lb(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function Ib(s, e) {
  return s * s * s * e;
}
function or(s, e, t, i, n) {
  return Rb(s, e) + Db(s, t) + Lb(s, i) + Ib(s, n);
}
class Wu extends Mi {
  constructor(e = new re(), t = new re(), i = new re(), n = new re()) {
    super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new re()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2, a = this.v3;
    return i.set(or(e, n.x, r.x, o.x, a.x), or(e, n.y, r.y, o.y, a.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Nb extends Mi {
  constructor(e = new I(), t = new I(), i = new I(), n = new I()) {
    super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new I()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2, a = this.v3;
    return i.set(or(e, n.x, r.x, o.x, a.x), or(e, n.y, r.y, o.y, a.y), or(e, n.z, r.z, o.z, a.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Xu extends Mi {
  constructor(e = new re(), t = new re()) {
    super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new re()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new re()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class kb extends Mi {
  constructor(e = new I(), t = new I()) {
    super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new I()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new I()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class ju extends Mi {
  constructor(e = new re(), t = new re(), i = new re()) {
    super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new re()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2;
    return i.set(rr(e, n.x, r.x, o.x), rr(e, n.y, r.y, o.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Ob extends Mi {
  constructor(e = new I(), t = new I(), i = new I()) {
    super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new I()) {
    const i = t, n = this.v0, r = this.v1, o = this.v2;
    return i.set(rr(e, n.x, r.x, o.x), rr(e, n.y, r.y, o.y), rr(e, n.z, r.z, o.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Yu extends Mi {
  constructor(e = []) {
    super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new re()) {
    const i = t, n = this.points, r = (n.length - 1) * e, o = Math.floor(r), a = r - o, l = n[o === 0 ? o : o - 1], c = n[o], h = n[o > n.length - 2 ? n.length - 1 : o + 1], d = n[o > n.length - 3 ? n.length - 1 : o + 2];
    return i.set(ud(a, l.x, c.x, h.x, d.x), ud(a, l.y, c.y, h.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new re().fromArray(n));
    }
    return this;
  }
}
var Zl = Object.freeze({ __proto__: null, ArcCurve: Mb, CatmullRomCurve3: Cb, CubicBezierCurve: Wu, CubicBezierCurve3: Nb, EllipseCurve: Sc, LineCurve: Xu, LineCurve3: kb, QuadraticBezierCurve: ju, QuadraticBezierCurve3: Ob, SplineCurve: Yu });
class Ub extends Mi {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Zl[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(), n = this.getCurveLengths();
    let r = 0;
    for (; r < n.length; ) {
      if (n[r] >= i) {
        const o = n[r] - i, a = this.curves[r], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let n = 0, r = this.curves; n < r.length; n++) {
      const o = r[n], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        i && i.equals(h) || (t.push(h), i = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(new Zl[n.type]().fromJSON(n));
    }
    return this;
  }
}
class pd extends Ub {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new re(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Xu(this.currentPoint.clone(), new re(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    const r = new ju(this.currentPoint.clone(), new re(e, t), new re(i, n));
    return this.curves.push(r), this.currentPoint.set(i, n), this;
  }
  bezierCurveTo(e, t, i, n, r, o) {
    const a = new Wu(this.currentPoint.clone(), new re(e, t), new re(i, n), new re(r, o));
    return this.curves.push(a), this.currentPoint.set(r, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new Yu(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, n, r, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(e + a, t + l, i, n, r, o), this;
  }
  absarc(e, t, i, n, r, o) {
    return this.absellipse(e, t, i, i, n, r, o), this;
  }
  ellipse(e, t, i, n, r, o, a, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, i, n, r, o, a, l), this;
  }
  absellipse(e, t, i, n, r, o, a, l) {
    const c = new Sc(e, t, i, n, r, o, a, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Mc extends ft {
  constructor(e = 1, t = 1, i = 1, n = 32, r = 1, o = false, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: n, heightSegments: r, openEnded: o, thetaStart: a, thetaLength: l };
    const c = this;
    n = Math.floor(n), r = Math.floor(r);
    const h = [], d = [], u = [], f = [];
    let m = 0;
    const _ = [], g = i / 2;
    let v = 0;
    y(), o === false && (e > 0 && x(true), t > 0 && x(false)), this.setIndex(h), this.setAttribute("position", new lt(d, 3)), this.setAttribute("normal", new lt(u, 3)), this.setAttribute("uv", new lt(f, 2));
    function y() {
      const S = new I(), A = new I();
      let R = 0;
      const C = (t - e) / i;
      for (let P = 0; P <= r; P++) {
        const z = [], w = P / r, E = w * (t - e) + e;
        for (let N = 0; N <= n; N++) {
          const k = N / n, V = k * l + a, q = Math.sin(V), G = Math.cos(V);
          A.x = E * q, A.y = -w * i + g, A.z = E * G, d.push(A.x, A.y, A.z), S.set(q, C, G).normalize(), u.push(S.x, S.y, S.z), f.push(k, 1 - w), z.push(m++);
        }
        _.push(z);
      }
      for (let P = 0; P < n; P++) for (let z = 0; z < r; z++) {
        const w = _[z][P], E = _[z + 1][P], N = _[z + 1][P + 1], k = _[z][P + 1];
        e > 0 && (h.push(w, E, k), R += 3), t > 0 && (h.push(E, N, k), R += 3);
      }
      c.addGroup(v, R, 0), v += R;
    }
    function x(S) {
      const A = m, R = new re(), C = new I();
      let P = 0;
      const z = S === true ? e : t, w = S === true ? 1 : -1;
      for (let N = 1; N <= n; N++) d.push(0, g * w, 0), u.push(0, w, 0), f.push(0.5, 0.5), m++;
      const E = m;
      for (let N = 0; N <= n; N++) {
        const V = N / n * l + a, q = Math.cos(V), G = Math.sin(V);
        C.x = z * G, C.y = g * w, C.z = z * q, d.push(C.x, C.y, C.z), u.push(0, w, 0), R.x = q * 0.5 + 0.5, R.y = G * 0.5 * w + 0.5, f.push(R.x, R.y), m++;
      }
      for (let N = 0; N < n; N++) {
        const k = A + N, V = E + N;
        S === true ? h.push(V, V + 1, k) : h.push(V + 1, V, k), P += 3;
      }
      c.addGroup(v, P, S === true ? 1 : 2), v += P;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Ss extends pd {
  constructor(e) {
    super(e), this.uuid = Ui(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(new pd().fromJSON(n));
    }
    return this;
  }
}
const Fb = { triangulate: function(s, e, t = 2) {
  const i = e && e.length, n = i ? e[0] * t : s.length;
  let r = qu(s, 0, n, t, true);
  const o = [];
  if (!r || r.next === r.prev) return o;
  let a, l, c, h, d, u, f;
  if (i && (r = Gb(s, e, r, t)), s.length > 80 * t) {
    a = c = s[0], l = h = s[1];
    for (let m = t; m < n; m += t) d = s[m], u = s[m + 1], d < a && (a = d), u < l && (l = u), d > c && (c = d), u > h && (h = u);
    f = Math.max(c - a, h - l), f = f !== 0 ? 32767 / f : 0;
  }
  return hr(r, o, t, a, l, f, 0), o;
} };
function qu(s, e, t, i, n) {
  let r, o;
  if (n === ex(s, e, t, i) > 0) for (r = e; r < t; r += i) o = fd(r, s[r], s[r + 1], o);
  else for (r = t - i; r >= e; r -= i) o = fd(r, s[r], s[r + 1], o);
  return o && ia(o, o.next) && (ur(o), o = o.next), o;
}
function Fn(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s, i;
  do
    if (i = false, !t.steiner && (ia(t, t.next) || gt(t.prev, t, t.next) === 0)) {
      if (ur(t), t = e = t.prev, t === t.next) break;
      i = true;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function hr(s, e, t, i, n, r, o) {
  if (!s) return;
  !o && r && Yb(s, i, n, r);
  let a = s, l, c;
  for (; s.prev !== s.next; ) {
    if (l = s.prev, c = s.next, r ? Bb(s, i, n, r) : zb(s)) {
      e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), ur(s), s = c.next, a = c.next;
      continue;
    }
    if (s = c, s === a) {
      o ? o === 1 ? (s = Vb(Fn(s), e, t), hr(s, e, t, i, n, r, 2)) : o === 2 && Hb(s, e, t, i, n, r) : hr(Fn(s), e, t, i, n, r, 1);
      break;
    }
  }
}
function zb(s) {
  const e = s.prev, t = s, i = s.next;
  if (gt(e, t, i) >= 0) return false;
  const n = e.x, r = t.x, o = i.x, a = e.y, l = t.y, c = i.y, h = n < r ? n < o ? n : o : r < o ? r : o, d = a < l ? a < c ? a : c : l < c ? l : c, u = n > r ? n > o ? n : o : r > o ? r : o, f = a > l ? a > c ? a : c : l > c ? l : c;
  let m = i.next;
  for (; m !== e; ) {
    if (m.x >= h && m.x <= u && m.y >= d && m.y <= f && gs(n, a, r, l, o, c, m.x, m.y) && gt(m.prev, m, m.next) >= 0) return false;
    m = m.next;
  }
  return true;
}
function Bb(s, e, t, i) {
  const n = s.prev, r = s, o = s.next;
  if (gt(n, r, o) >= 0) return false;
  const a = n.x, l = r.x, c = o.x, h = n.y, d = r.y, u = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, m = h < d ? h < u ? h : u : d < u ? d : u, _ = a > l ? a > c ? a : c : l > c ? l : c, g = h > d ? h > u ? h : u : d > u ? d : u, v = Jl(f, m, e, t, i), y = Jl(_, g, e, t, i);
  let x = s.prevZ, S = s.nextZ;
  for (; x && x.z >= v && S && S.z <= y; ) {
    if (x.x >= f && x.x <= _ && x.y >= m && x.y <= g && x !== n && x !== o && gs(a, h, l, d, c, u, x.x, x.y) && gt(x.prev, x, x.next) >= 0 || (x = x.prevZ, S.x >= f && S.x <= _ && S.y >= m && S.y <= g && S !== n && S !== o && gs(a, h, l, d, c, u, S.x, S.y) && gt(S.prev, S, S.next) >= 0)) return false;
    S = S.nextZ;
  }
  for (; x && x.z >= v; ) {
    if (x.x >= f && x.x <= _ && x.y >= m && x.y <= g && x !== n && x !== o && gs(a, h, l, d, c, u, x.x, x.y) && gt(x.prev, x, x.next) >= 0) return false;
    x = x.prevZ;
  }
  for (; S && S.z <= y; ) {
    if (S.x >= f && S.x <= _ && S.y >= m && S.y <= g && S !== n && S !== o && gs(a, h, l, d, c, u, S.x, S.y) && gt(S.prev, S, S.next) >= 0) return false;
    S = S.nextZ;
  }
  return true;
}
function Vb(s, e, t) {
  let i = s;
  do {
    const n = i.prev, r = i.next.next;
    !ia(n, r) && Ku(n, i, i.next, r) && dr(n, r) && dr(r, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(r.i / t | 0), ur(i), ur(i.next), i = s = r), i = i.next;
  } while (i !== s);
  return Fn(i);
}
function Hb(s, e, t, i, n, r) {
  let o = s;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && Zb(o, a)) {
        let l = Zu(o, a);
        o = Fn(o, o.next), l = Fn(l, l.next), hr(o, e, t, i, n, r, 0), hr(l, e, t, i, n, r, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== s);
}
function Gb(s, e, t, i) {
  const n = [];
  let r, o, a, l, c;
  for (r = 0, o = e.length; r < o; r++) a = e[r] * i, l = r < o - 1 ? e[r + 1] * i : s.length, c = qu(s, a, l, i, false), c === c.next && (c.steiner = true), n.push(Kb(c));
  for (n.sort($b), r = 0; r < n.length; r++) t = Wb(n[r], t);
  return t;
}
function $b(s, e) {
  return s.x - e.x;
}
function Wb(s, e) {
  const t = Xb(s, e);
  if (!t) return e;
  const i = Zu(t, s);
  return Fn(i, i.next), Fn(t, t.next);
}
function Xb(s, e) {
  let t = e, i = -1 / 0, n;
  const r = s.x, o = s.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const u = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (u <= r && u > i && (i = u, n = t.x < t.next.x ? t : t.next, u === r)) return n;
    }
    t = t.next;
  } while (t !== e);
  if (!n) return null;
  const a = n, l = n.x, c = n.y;
  let h = 1 / 0, d;
  t = n;
  do
    r >= t.x && t.x >= l && r !== t.x && gs(o < c ? r : i, o, l, c, o < c ? i : r, o, t.x, t.y) && (d = Math.abs(o - t.y) / (r - t.x), dr(t, s) && (d < h || d === h && (t.x > n.x || t.x === n.x && jb(n, t))) && (n = t, h = d)), t = t.next;
  while (t !== a);
  return n;
}
function jb(s, e) {
  return gt(s.prev, s, e.prev) < 0 && gt(e.next, s, s.next) < 0;
}
function Yb(s, e, t, i) {
  let n = s;
  do
    n.z === 0 && (n.z = Jl(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== s);
  n.prevZ.nextZ = null, n.prevZ = null, qb(n);
}
function qb(s) {
  let e, t, i, n, r, o, a, l, c = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++) ;
      for (l = c; a > 0 || l > 0 && i; ) a !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, l--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
      t = i;
    }
    r.nextZ = null, c *= 2;
  } while (o > 1);
  return s;
}
function Jl(s, e, t, i, n) {
  return s = (s - t) * n | 0, e = (e - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function Kb(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function gs(s, e, t, i, n, r, o, a) {
  return (n - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (n - o) * (i - a);
}
function Zb(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !Jb(s, e) && (dr(s, e) && dr(e, s) && Qb(s, e) && (gt(s.prev, s, e.prev) || gt(s, e.prev, e)) || ia(s, e) && gt(s.prev, s, s.next) > 0 && gt(e.prev, e, e.next) > 0);
}
function gt(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function ia(s, e) {
  return s.x === e.x && s.y === e.y;
}
function Ku(s, e, t, i) {
  const n = bo(gt(s, e, t)), r = bo(gt(s, e, i)), o = bo(gt(t, i, s)), a = bo(gt(t, i, e));
  return !!(n !== r && o !== a || n === 0 && _o(s, t, e) || r === 0 && _o(s, i, e) || o === 0 && _o(t, s, i) || a === 0 && _o(t, e, i));
}
function _o(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function bo(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function Jb(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && Ku(t, t.next, s, e)) return true;
    t = t.next;
  } while (t !== s);
  return false;
}
function dr(s, e) {
  return gt(s.prev, s, s.next) < 0 ? gt(s, e, s.next) >= 0 && gt(s, s.prev, e) >= 0 : gt(s, e, s.prev) < 0 || gt(s, s.next, e) < 0;
}
function Qb(s, e) {
  let t = s, i = false;
  const n = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== s);
  return i;
}
function Zu(s, e) {
  const t = new Ql(s.i, s.x, s.y), i = new Ql(e.i, e.x, e.y), n = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
}
function fd(s, e, t, i) {
  const n = new Ql(s, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function ur(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Ql(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
function ex(s, e, t, i) {
  let n = 0;
  for (let r = e, o = t - i; r < t; r += i) n += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
  return n;
}
class cn {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return cn.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], n = [], r = [];
    md(e), gd(i, e);
    let o = e.length;
    t.forEach(md);
    for (let l = 0; l < t.length; l++) n.push(o), o += t[l].length, gd(i, t[l]);
    const a = Fb.triangulate(i, n);
    for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
    return r;
  }
}
function md(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function gd(s, e) {
  for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
}
class Ju extends ft {
  constructor(e = new Ss([new re(0.5, 0.5), new re(-0.5, 0.5), new re(-0.5, -0.5), new re(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
    const i = this, n = [], r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new lt(n, 3)), this.setAttribute("uv", new lt(r, 2)), this.computeVertexNormals();
    function o(a) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1;
      let u = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : tx;
      let x, S = false, A, R, C, P;
      v && (x = v.getSpacedPoints(h), S = true, u = false, A = v.computeFrenetFrames(h, false), R = new I(), C = new I(), P = new I()), u || (g = 0, f = 0, m = 0, _ = 0);
      const z = a.extractPoints(c);
      let w = z.shape;
      const E = z.holes;
      if (!cn.isClockWise(w)) {
        w = w.reverse();
        for (let te = 0, L = E.length; te < L; te++) {
          const he = E[te];
          cn.isClockWise(he) && (E[te] = he.reverse());
        }
      }
      const k = cn.triangulateShape(w, E), V = w;
      for (let te = 0, L = E.length; te < L; te++) {
        const he = E[te];
        w = w.concat(he);
      }
      function q(te, L, he) {
        return L || console.error("THREE.ExtrudeGeometry: vec does not exist"), te.clone().addScaledVector(L, he);
      }
      const G = w.length, ee = k.length;
      function O(te, L, he) {
        let ce, oe, ue;
        const Ae = te.x - L.x, _e = te.y - L.y, D = he.x - te.x, M = he.y - te.y, H = Ae * Ae + _e * _e, Z = Ae * M - _e * D;
        if (Math.abs(Z) > Number.EPSILON) {
          const ie = Math.sqrt(H), J = Math.sqrt(D * D + M * M), Me = L.x - _e / ie, pe = L.y + Ae / ie, we = he.x - M / J, je = he.y + D / J, ae = ((we - Me) * M - (je - pe) * D) / (Ae * M - _e * D);
          ce = Me + Ae * ae - te.x, oe = pe + _e * ae - te.y;
          const ye = ce * ce + oe * oe;
          if (ye <= 2) return new re(ce, oe);
          ue = Math.sqrt(ye / 2);
        } else {
          let ie = false;
          Ae > Number.EPSILON ? D > Number.EPSILON && (ie = true) : Ae < -Number.EPSILON ? D < -Number.EPSILON && (ie = true) : Math.sign(_e) === Math.sign(M) && (ie = true), ie ? (ce = -_e, oe = Ae, ue = Math.sqrt(H)) : (ce = Ae, oe = _e, ue = Math.sqrt(H / 2));
        }
        return new re(ce / ue, oe / ue);
      }
      const Q = [];
      for (let te = 0, L = V.length, he = L - 1, ce = te + 1; te < L; te++, he++, ce++) he === L && (he = 0), ce === L && (ce = 0), Q[te] = O(V[te], V[he], V[ce]);
      const X = [];
      let K, Le = Q.concat();
      for (let te = 0, L = E.length; te < L; te++) {
        const he = E[te];
        K = [];
        for (let ce = 0, oe = he.length, ue = oe - 1, Ae = ce + 1; ce < oe; ce++, ue++, Ae++) ue === oe && (ue = 0), Ae === oe && (Ae = 0), K[ce] = O(he[ce], he[ue], he[Ae]);
        X.push(K), Le = Le.concat(K);
      }
      for (let te = 0; te < g; te++) {
        const L = te / g, he = f * Math.cos(L * Math.PI / 2), ce = m * Math.sin(L * Math.PI / 2) + _;
        for (let oe = 0, ue = V.length; oe < ue; oe++) {
          const Ae = q(V[oe], Q[oe], ce);
          de(Ae.x, Ae.y, -he);
        }
        for (let oe = 0, ue = E.length; oe < ue; oe++) {
          const Ae = E[oe];
          K = X[oe];
          for (let _e = 0, D = Ae.length; _e < D; _e++) {
            const M = q(Ae[_e], K[_e], ce);
            de(M.x, M.y, -he);
          }
        }
      }
      const Re = m + _;
      for (let te = 0; te < G; te++) {
        const L = u ? q(w[te], Le[te], Re) : w[te];
        S ? (C.copy(A.normals[0]).multiplyScalar(L.x), R.copy(A.binormals[0]).multiplyScalar(L.y), P.copy(x[0]).add(C).add(R), de(P.x, P.y, P.z)) : de(L.x, L.y, 0);
      }
      for (let te = 1; te <= h; te++) for (let L = 0; L < G; L++) {
        const he = u ? q(w[L], Le[L], Re) : w[L];
        S ? (C.copy(A.normals[te]).multiplyScalar(he.x), R.copy(A.binormals[te]).multiplyScalar(he.y), P.copy(x[te]).add(C).add(R), de(P.x, P.y, P.z)) : de(he.x, he.y, d / h * te);
      }
      for (let te = g - 1; te >= 0; te--) {
        const L = te / g, he = f * Math.cos(L * Math.PI / 2), ce = m * Math.sin(L * Math.PI / 2) + _;
        for (let oe = 0, ue = V.length; oe < ue; oe++) {
          const Ae = q(V[oe], Q[oe], ce);
          de(Ae.x, Ae.y, d + he);
        }
        for (let oe = 0, ue = E.length; oe < ue; oe++) {
          const Ae = E[oe];
          K = X[oe];
          for (let _e = 0, D = Ae.length; _e < D; _e++) {
            const M = q(Ae[_e], K[_e], ce);
            S ? de(M.x, M.y + x[h - 1].y, x[h - 1].x + he) : de(M.x, M.y, d + he);
          }
        }
      }
      Y(), se();
      function Y() {
        const te = n.length / 3;
        if (u) {
          let L = 0, he = G * L;
          for (let ce = 0; ce < ee; ce++) {
            const oe = k[ce];
            Ne(oe[2] + he, oe[1] + he, oe[0] + he);
          }
          L = h + g * 2, he = G * L;
          for (let ce = 0; ce < ee; ce++) {
            const oe = k[ce];
            Ne(oe[0] + he, oe[1] + he, oe[2] + he);
          }
        } else {
          for (let L = 0; L < ee; L++) {
            const he = k[L];
            Ne(he[2], he[1], he[0]);
          }
          for (let L = 0; L < ee; L++) {
            const he = k[L];
            Ne(he[0] + G * h, he[1] + G * h, he[2] + G * h);
          }
        }
        i.addGroup(te, n.length / 3 - te, 0);
      }
      function se() {
        const te = n.length / 3;
        let L = 0;
        me(V, L), L += V.length;
        for (let he = 0, ce = E.length; he < ce; he++) {
          const oe = E[he];
          me(oe, L), L += oe.length;
        }
        i.addGroup(te, n.length / 3 - te, 1);
      }
      function me(te, L) {
        let he = te.length;
        for (; --he >= 0; ) {
          const ce = he;
          let oe = he - 1;
          oe < 0 && (oe = te.length - 1);
          for (let ue = 0, Ae = h + g * 2; ue < Ae; ue++) {
            const _e = G * ue, D = G * (ue + 1), M = L + ce + _e, H = L + oe + _e, Z = L + oe + D, ie = L + ce + D;
            Ie(M, H, Z, ie);
          }
        }
      }
      function de(te, L, he) {
        l.push(te), l.push(L), l.push(he);
      }
      function Ne(te, L, he) {
        ze(te), ze(L), ze(he);
        const ce = n.length / 3, oe = y.generateTopUV(i, n, ce - 3, ce - 2, ce - 1);
        We(oe[0]), We(oe[1]), We(oe[2]);
      }
      function Ie(te, L, he, ce) {
        ze(te), ze(L), ze(ce), ze(L), ze(he), ze(ce);
        const oe = n.length / 3, ue = y.generateSideWallUV(i, n, oe - 6, oe - 3, oe - 2, oe - 1);
        We(ue[0]), We(ue[1]), We(ue[3]), We(ue[1]), We(ue[2]), We(ue[3]);
      }
      function ze(te) {
        n.push(l[te * 3 + 0]), n.push(l[te * 3 + 1]), n.push(l[te * 3 + 2]);
      }
      function We(te) {
        r.push(te.x), r.push(te.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return ix(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = t[e.shapes[r]];
      i.push(a);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new Zl[n.type]().fromJSON(n)), new Ju(i, e.options);
  }
}
const tx = { generateTopUV: function(s, e, t, i, n) {
  const r = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], c = e[n * 3], h = e[n * 3 + 1];
  return [new re(r, o), new re(a, l), new re(c, h)];
}, generateSideWallUV: function(s, e, t, i, n, r) {
  const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], h = e[i * 3 + 1], d = e[i * 3 + 2], u = e[n * 3], f = e[n * 3 + 1], m = e[n * 3 + 2], _ = e[r * 3], g = e[r * 3 + 1], v = e[r * 3 + 2];
  return Math.abs(a - h) < Math.abs(o - c) ? [new re(o, 1 - l), new re(c, 1 - d), new re(u, 1 - m), new re(_, 1 - v)] : [new re(a, 1 - l), new re(h, 1 - d), new re(f, 1 - m), new re(g, 1 - v)];
} };
function ix(s, e, t) {
  if (t.shapes = [], Array.isArray(s)) for (let i = 0, n = s.length; i < n; i++) {
    const r = s[i];
    t.shapes.push(r.uuid);
  }
  else t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Es extends ft {
  constructor(e = new Ss([new re(0, 0.5), new re(-0.5, -0.5), new re(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
    const i = [], n = [], r = [], o = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === false) c(e);
    else for (let h = 0; h < e.length; h++) c(e[h]), this.addGroup(a, l, h), a += l, l = 0;
    this.setIndex(i), this.setAttribute("position", new lt(n, 3)), this.setAttribute("normal", new lt(r, 3)), this.setAttribute("uv", new lt(o, 2));
    function c(h) {
      const d = n.length / 3, u = h.extractPoints(t);
      let f = u.shape;
      const m = u.holes;
      cn.isClockWise(f) === false && (f = f.reverse());
      for (let g = 0, v = m.length; g < v; g++) {
        const y = m[g];
        cn.isClockWise(y) === true && (m[g] = y.reverse());
      }
      const _ = cn.triangulateShape(f, m);
      for (let g = 0, v = m.length; g < v; g++) {
        const y = m[g];
        f = f.concat(y);
      }
      for (let g = 0, v = f.length; g < v; g++) {
        const y = f[g];
        n.push(y.x, y.y, 0), r.push(0, 0, 1), o.push(y.x, y.y);
      }
      for (let g = 0, v = _.length; g < v; g++) {
        const y = _[g], x = y[0] + d, S = y[1] + d, A = y[2] + d;
        i.push(x, S, A), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return nx(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let n = 0, r = e.shapes.length; n < r; n++) {
      const o = t[e.shapes[n]];
      i.push(o);
    }
    return new Es(i, e.curveSegments);
  }
}
function nx(s, e) {
  if (e.shapes = [], Array.isArray(s)) for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t];
    e.shapes.push(n.uuid);
  }
  else e.shapes.push(s.uuid);
  return e;
}
class IM extends vn {
  constructor(e) {
    super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new Xe(16777215), this.specular = new Xe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Cu, this.normalScale = new re(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new di(), this.combine = dc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Qu extends yt {
  constructor(e, t = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Xe(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
const ja = new rt(), vd = new I(), _d = new I();
class sx {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new re(512, 512), this.map = null, this.mapPass = null, this.matrix = new rt(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new xc(), this._frameExtents = new re(1, 1), this._viewportCount = 1, this._viewports = [new xt(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    vd.setFromMatrixPosition(e.matrixWorld), t.position.copy(vd), _d.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(_d), t.updateMatrixWorld(), ja.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ja), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(ja);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
  }
}
class rx extends sx {
  constructor() {
    super(new Fu(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
  }
}
class bd extends Qu {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(yt.DEFAULT_UP), this.updateMatrix(), this.target = new yt(), this.shadow = new rx();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class ox extends Qu {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
  }
}
const xd = new rt();
class ax {
  constructor(e, t, i = 0, n = 1 / 0) {
    this.ray = new Cr(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new bc(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return xd.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(xd), this;
  }
  intersectObject(e, t = true, i = []) {
    return ec(e, this, i, t), i.sort(wd), i;
  }
  intersectObjects(e, t = true, i = []) {
    for (let n = 0, r = e.length; n < r; n++) ec(e[n], this, i, t);
    return i.sort(wd), i;
  }
}
function wd(s, e) {
  return s.distance - e.distance;
}
function ec(s, e, t, i) {
  let n = true;
  if (s.layers.test(e.layers) && s.raycast(e, t) === false && (n = false), n === true && i === true) {
    const r = s.children;
    for (let o = 0, a = r.length; o < a; o++) ec(r[o], e, t, true);
  }
}
class yd {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(It(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class lx extends yc {
  constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
    i = new Xe(i), n = new Xe(n);
    const r = t / 2, o = e / t, a = e / 2, l = [], c = [];
    for (let u = 0, f = 0, m = -a; u <= t; u++, m += o) {
      l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
      const _ = u === r ? i : n;
      _.toArray(c, f), f += 3, _.toArray(c, f), f += 3, _.toArray(c, f), f += 3, _.toArray(c, f), f += 3;
    }
    const h = new ft();
    h.setAttribute("position", new lt(l, 3)), h.setAttribute("color", new lt(c, 3));
    const d = new fn({ vertexColors: true, toneMapped: false });
    super(h, d), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Sd = new I();
let xo, Ya;
class Nn extends yt {
  constructor(e = new I(0, 0, 1), t = new I(0, 0, 0), i = 1, n = 16776960, r = i * 0.2, o = r * 0.2) {
    super(), this.type = "ArrowHelper", xo === void 0 && (xo = new ft(), xo.setAttribute("position", new lt([0, 0, 0, 0, 1, 0], 3)), Ya = new Mc(0, 0.5, 1, 5, 1), Ya.translate(0, -0.5, 0)), this.position.copy(t), this.line = new ys(xo, new fn({ color: n, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Ut(Ya, new Fi({ color: n, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(i, r, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      Sd.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(Sd, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class cx extends Gn {
  constructor(e, t = null) {
    super(), this.object = e, this.domElement = t, this.enabled = true, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: hc } }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = hc);
const Ed = { type: "change" }, Cc = { type: "start" }, ep = { type: "end" }, wo = new Cr(), Md = new en(), hx = Math.cos(70 * om.DEG2RAD), Ct = new I(), Xt = 2 * Math.PI, at = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }, qa = 1e-6;
class dx extends cx {
  constructor(e, t = null) {
    super(e, t), this.state = at.NONE, this.enabled = true, this.target = new I(), this.cursor = new I(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: _s.ROTATE, MIDDLE: _s.DOLLY, RIGHT: _s.PAN }, this.touches = { ONE: fs.ROTATE, TWO: fs.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new I(), this._lastQuaternion = new un(), this._lastTargetPosition = new I(), this._quat = new un().setFromUnitVectors(e.up, new I(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new yd(), this._sphericalDelta = new yd(), this._scale = 1, this._panOffset = new I(), this._rotateStart = new re(), this._rotateEnd = new re(), this._rotateDelta = new re(), this._panStart = new re(), this._panEnd = new re(), this._panDelta = new re(), this._dollyStart = new re(), this._dollyEnd = new re(), this._dollyDelta = new re(), this._dollyDirection = new I(), this._mouse = new re(), this._performCursorZoom = false, this._pointers = [], this._pointerPositions = {}, this._controlActive = false, this._onPointerMove = px.bind(this), this._onPointerDown = ux.bind(this), this._onPointerUp = fx.bind(this), this._onContextMenu = wx.bind(this), this._onMouseWheel = vx.bind(this), this._onKeyDown = _x.bind(this), this._onTouchStart = bx.bind(this), this._onTouchMove = xx.bind(this), this._onMouseDown = mx.bind(this), this._onMouseMove = gx.bind(this), this._interceptControlDown = yx.bind(this), this._interceptControlUp = Sx.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: true }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(Ed), this.update(), this.state = at.NONE;
  }
  update(e = null) {
    const t = this.object.position;
    Ct.copy(t).sub(this.target), Ct.applyQuaternion(this._quat), this._spherical.setFromVector3(Ct), this.autoRotate && this.state === at.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let i = this.minAzimuthAngle, n = this.maxAzimuthAngle;
    isFinite(i) && isFinite(n) && (i < -Math.PI ? i += Xt : i > Math.PI && (i -= Xt), n < -Math.PI ? n += Xt : n > Math.PI && (n -= Xt), i <= n ? this._spherical.theta = Math.max(i, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + n) / 2 ? Math.max(i, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === true ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let r = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = o != this._spherical.radius;
    }
    if (Ct.setFromSpherical(this._spherical), Ct.applyQuaternion(this._quatInverse), t.copy(this.target).add(Ct), this.object.lookAt(this.target), this.enableDamping === true ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const a = Ct.length();
        o = this._clampDistance(a * this._scale);
        const l = a - o;
        this.object.position.addScaledVector(this._dollyDirection, l), this.object.updateMatrixWorld(), r = !!l;
      } else if (this.object.isOrthographicCamera) {
        const a = new I(this._mouse.x, this._mouse.y, 0);
        a.unproject(this.object);
        const l = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = l !== this.object.zoom;
        const c = new I(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(a), this.object.updateMatrixWorld(), o = Ct.length();
      } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = false;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (wo.origin.copy(this.object.position), wo.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(wo.direction)) < hx ? this.object.lookAt(this.target) : (Md.setFromNormalAndCoplanarPoint(this.object.up, this.target), wo.intersectPlane(Md, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), r = true);
    }
    return this._scale = 1, this._performCursorZoom = false, r || this._lastPosition.distanceToSquared(this.object.position) > qa || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > qa || this._lastTargetPosition.distanceToSquared(this.target) > qa ? (this.dispatchEvent(Ed), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), true) : false;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Xt / 60 * this.autoRotateSpeed * e : Xt / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    Ct.setFromMatrixColumn(t, 0), Ct.multiplyScalar(-e), this._panOffset.add(Ct);
  }
  _panUp(e, t) {
    this.screenSpacePanning === true ? Ct.setFromMatrixColumn(t, 1) : (Ct.setFromMatrixColumn(t, 0), Ct.crossVectors(this.object.up, Ct)), Ct.multiplyScalar(e), this._panOffset.add(Ct);
  }
  _pan(e, t) {
    const i = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const n = this.object.position;
      Ct.copy(n).sub(this.target);
      let r = Ct.length();
      r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * r / i.clientHeight, this.object.matrix), this._panUp(2 * t * r / i.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = false);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor) return;
    this._performCursorZoom = true;
    const i = this.domElement.getBoundingClientRect(), n = e - i.left, r = t - i.top, o = i.width, a = i.height;
    this._mouse.x = n / o * 2 - 1, this._mouse.y = -(r / a) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Xt * this._rotateDelta.x / t.clientHeight), this._rotateUp(Xt * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let t = false;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Xt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), t = true;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Xt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), t = true;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Xt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), t = true;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Xt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), t = true;
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1) this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(i, n);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1) this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panStart.set(i, n);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
    this._dollyStart.set(0, r);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1) this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), r = 0.5 * (e.pageY + i.y);
      this._rotateEnd.set(n, r);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Xt * this._rotateDelta.x / t.clientHeight), this._rotateUp(Xt * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1) this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
      this._panEnd.set(i, n);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
    this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + t.x) * 0.5, a = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(o, a);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++) if (this._pointers[t] == e.pointerId) {
      this._pointers.splice(t, 1);
      return;
    }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++) if (this._pointers[t] == e.pointerId) return true;
    return false;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new re(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  _customWheelEvent(e) {
    const t = e.deltaMode, i = { clientX: e.clientX, clientY: e.clientY, deltaY: e.deltaY };
    switch (t) {
      case 1:
        i.deltaY *= 16;
        break;
      case 2:
        i.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
  }
}
function ux(s) {
  this.enabled !== false && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(s) && (this._addPointer(s), s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s)));
}
function px(s) {
  this.enabled !== false && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
}
function fx(s) {
  switch (this._removePointer(s), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(ep), this.state = at.NONE;
      break;
    case 1:
      const e = this._pointers[0], t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function mx(s) {
  let e;
  switch (s.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case _s.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(s), this.state = at.DOLLY;
      break;
    case _s.ROTATE:
      if (s.ctrlKey || s.metaKey || s.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(s), this.state = at.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(s), this.state = at.ROTATE;
      }
      break;
    case _s.PAN:
      if (s.ctrlKey || s.metaKey || s.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(s), this.state = at.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(s), this.state = at.PAN;
      }
      break;
    default:
      this.state = at.NONE;
  }
  this.state !== at.NONE && this.dispatchEvent(Cc);
}
function gx(s) {
  switch (this.state) {
    case at.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(s);
      break;
    case at.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(s);
      break;
    case at.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(s);
      break;
  }
}
function vx(s) {
  this.enabled === false || this.enableZoom === false || this.state !== at.NONE || (s.preventDefault(), this.dispatchEvent(Cc), this._handleMouseWheel(this._customWheelEvent(s)), this.dispatchEvent(ep));
}
function _x(s) {
  this.enabled === false || this.enablePan === false || this._handleKeyDown(s);
}
function bx(s) {
  switch (this._trackPointer(s), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case fs.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(s), this.state = at.TOUCH_ROTATE;
          break;
        case fs.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(s), this.state = at.TOUCH_PAN;
          break;
        default:
          this.state = at.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case fs.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(s), this.state = at.TOUCH_DOLLY_PAN;
          break;
        case fs.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(s), this.state = at.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = at.NONE;
      }
      break;
    default:
      this.state = at.NONE;
  }
  this.state !== at.NONE && this.dispatchEvent(Cc);
}
function xx(s) {
  switch (this._trackPointer(s), this.state) {
    case at.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(s), this.update();
      break;
    case at.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(s), this.update();
      break;
    case at.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(s), this.update();
      break;
    case at.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(s), this.update();
      break;
    default:
      this.state = at.NONE;
  }
}
function wx(s) {
  this.enabled !== false && s.preventDefault();
}
function yx(s) {
  s.key === "Control" && (this._controlActive = true, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true }));
}
function Sx(s) {
  s.key === "Control" && (this._controlActive = false, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true }));
}
/*! Tweakpane 4.0.4 (c) 2016 cocopon, licensed under the MIT license. */
function ht(s) {
  return s == null;
}
function Tc(s) {
  return s !== null && typeof s == "object";
}
function tc(s) {
  return s !== null && typeof s == "object";
}
function Ex(s, e) {
  if (s.length !== e.length) return false;
  for (let t = 0; t < s.length; t++) if (s[t] !== e[t]) return false;
  return true;
}
function zn(s, e) {
  return Array.from(/* @__PURE__ */ new Set([...Object.keys(s), ...Object.keys(e)])).reduce((i, n) => {
    const r = s[n], o = e[n];
    return tc(r) && tc(o) ? Object.assign(Object.assign({}, i), { [n]: zn(r, o) }) : Object.assign(Object.assign({}, i), { [n]: n in e ? o : r });
  }, {});
}
function Ac(s) {
  return Tc(s) ? "target" in s : false;
}
const Mx = { alreadydisposed: () => "View has been already disposed", invalidparams: (s) => `Invalid parameters for '${s.name}'`, nomatchingcontroller: (s) => `No matching controller for '${s.key}'`, nomatchingview: (s) => `No matching view for '${JSON.stringify(s.params)}'`, notbindable: () => "Value is not bindable", notcompatible: (s) => `Not compatible with  plugin '${s.id}'`, propertynotfound: (s) => `Property '${s.name}' not found`, shouldneverhappen: () => "This error should never happen" };
class bt {
  static alreadyDisposed() {
    return new bt({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new bt({ type: "notbindable" });
  }
  static notCompatible(e, t) {
    return new bt({ type: "notcompatible", context: { id: `${e}.${t}` } });
  }
  static propertyNotFound(e) {
    return new bt({ type: "propertynotfound", context: { name: e } });
  }
  static shouldNeverHappen() {
    return new bt({ type: "shouldneverhappen" });
  }
  constructor(e) {
    var t;
    this.message = (t = Mx[e.type](e.context)) !== null && t !== void 0 ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type;
  }
  toString() {
    return this.message;
  }
}
class jo {
  constructor(e, t) {
    this.obj_ = e, this.key = t;
  }
  static isBindable(e) {
    return !(e === null || typeof e != "object" && typeof e != "function");
  }
  read() {
    return this.obj_[this.key];
  }
  write(e) {
    this.obj_[this.key] = e;
  }
  writeProperty(e, t) {
    const i = this.read();
    if (!jo.isBindable(i)) throw bt.notBindable();
    if (!(e in i)) throw bt.propertyNotFound(e);
    i[e] = t;
  }
}
class Mt {
  constructor() {
    this.observers_ = {};
  }
  on(e, t, i) {
    var n;
    let r = this.observers_[e];
    return r || (r = this.observers_[e] = []), r.push({ handler: t, key: (n = i == null ? void 0 : i.key) !== null && n !== void 0 ? n : t }), this;
  }
  off(e, t) {
    const i = this.observers_[e];
    return i && (this.observers_[e] = i.filter((n) => n.key !== t)), this;
  }
  emit(e, t) {
    const i = this.observers_[e];
    i && i.forEach((n) => {
      n.handler(t);
    });
  }
}
class Cx {
  constructor(e, t) {
    var i;
    this.constraint_ = t == null ? void 0 : t.constraint, this.equals_ = (i = t == null ? void 0 : t.equals) !== null && i !== void 0 ? i : (n, r) => n === r, this.emitter = new Mt(), this.rawValue_ = e;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(e) {
    this.setRawValue(e, { forceEmit: false, last: true });
  }
  setRawValue(e, t) {
    const i = t ?? { forceEmit: false, last: true }, n = this.constraint_ ? this.constraint_.constrain(e) : e, r = this.rawValue_;
    this.equals_(r, n) && !i.forceEmit || (this.emitter.emit("beforechange", { sender: this }), this.rawValue_ = n, this.emitter.emit("change", { options: i, previousRawValue: r, rawValue: n, sender: this }));
  }
}
class Tx {
  constructor(e) {
    this.emitter = new Mt(), this.value_ = e;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(e) {
    this.setRawValue(e, { forceEmit: false, last: true });
  }
  setRawValue(e, t) {
    const i = t ?? { forceEmit: false, last: true }, n = this.value_;
    n === e && !i.forceEmit || (this.emitter.emit("beforechange", { sender: this }), this.value_ = e, this.emitter.emit("change", { options: i, previousRawValue: n, rawValue: this.value_, sender: this }));
  }
}
class Ax {
  constructor(e) {
    this.emitter = new Mt(), this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.value_ = e, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(e) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), { sender: this }));
  }
  onValueChange_(e) {
    this.emitter.emit("change", Object.assign(Object.assign({}, e), { sender: this }));
  }
}
function mt(s, e) {
  const t = e == null ? void 0 : e.constraint, i = e == null ? void 0 : e.equals;
  return !t && !i ? new Tx(s) : new Cx(s, e);
}
function Px(s) {
  return [new Ax(s), (e, t) => {
    s.setRawValue(e, t);
  }];
}
class $e {
  constructor(e) {
    this.emitter = new Mt(), this.valMap_ = e;
    for (const t in this.valMap_) this.valMap_[t].emitter.on("change", () => {
      this.emitter.emit("change", { key: t, sender: this });
    });
  }
  static createCore(e) {
    return Object.keys(e).reduce((i, n) => Object.assign(i, { [n]: mt(e[n]) }), {});
  }
  static fromObject(e) {
    const t = this.createCore(e);
    return new $e(t);
  }
  get(e) {
    return this.valMap_[e].rawValue;
  }
  set(e, t) {
    this.valMap_[e].rawValue = t;
  }
  value(e) {
    return this.valMap_[e];
  }
}
class Ar {
  constructor(e) {
    this.values = $e.fromObject({ max: e.max, min: e.min });
  }
  constrain(e) {
    const t = this.values.get("max"), i = this.values.get("min");
    return Math.min(Math.max(e, i), t);
  }
}
class Rx {
  constructor(e) {
    this.values = $e.fromObject({ max: e.max, min: e.min });
  }
  constrain(e) {
    const t = this.values.get("max"), i = this.values.get("min");
    let n = e;
    return ht(i) || (n = Math.max(n, i)), ht(t) || (n = Math.min(n, t)), n;
  }
}
class Dx {
  constructor(e, t = 0) {
    this.step = e, this.origin = t;
  }
  constrain(e) {
    const t = this.origin % this.step, i = Math.round((e - t) / this.step);
    return t + i * this.step;
  }
}
class Lx {
  constructor(e) {
    this.text = e;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
}
const Ix = { "**": (s, e) => Math.pow(s, e), "*": (s, e) => s * e, "/": (s, e) => s / e, "%": (s, e) => s % e, "+": (s, e) => s + e, "-": (s, e) => s - e, "<<": (s, e) => s << e, ">>": (s, e) => s >> e, ">>>": (s, e) => s >>> e, "&": (s, e) => s & e, "^": (s, e) => s ^ e, "|": (s, e) => s | e };
class Nx {
  constructor(e, t, i) {
    this.left = t, this.operator = e, this.right = i;
  }
  evaluate() {
    const e = Ix[this.operator];
    if (!e) throw new Error(`unexpected binary operator: '${this.operator}`);
    return e(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ");
  }
}
const kx = { "+": (s) => s, "-": (s) => -s, "~": (s) => ~s };
class Ox {
  constructor(e, t) {
    this.operator = e, this.expression = t;
  }
  evaluate() {
    const e = kx[this.operator];
    if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
    return e(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
}
function Pc(s) {
  return (e, t) => {
    for (let i = 0; i < s.length; i++) {
      const n = s[i](e, t);
      if (n !== "") return n;
    }
    return "";
  };
}
function pr(s, e) {
  var t;
  const i = s.substr(e).match(/^\s+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Ux(s, e) {
  const t = s.substr(e, 1);
  return t.match(/^[1-9]$/) ? t : "";
}
function fr(s, e) {
  var t;
  const i = s.substr(e).match(/^[0-9]+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Fx(s, e) {
  const t = fr(s, e);
  if (t !== "") return t;
  const i = s.substr(e, 1);
  if (e += 1, i !== "-" && i !== "+") return "";
  const n = fr(s, e);
  return n === "" ? "" : i + n;
}
function Rc(s, e) {
  const t = s.substr(e, 1);
  if (e += 1, t.toLowerCase() !== "e") return "";
  const i = Fx(s, e);
  return i === "" ? "" : t + i;
}
function tp(s, e) {
  const t = s.substr(e, 1);
  if (t === "0") return t;
  const i = Ux(s, e);
  return e += i.length, i === "" ? "" : i + fr(s, e);
}
function zx(s, e) {
  const t = tp(s, e);
  if (e += t.length, t === "") return "";
  const i = s.substr(e, 1);
  if (e += i.length, i !== ".") return "";
  const n = fr(s, e);
  return e += n.length, t + i + n + Rc(s, e);
}
function Bx(s, e) {
  const t = s.substr(e, 1);
  if (e += t.length, t !== ".") return "";
  const i = fr(s, e);
  return e += i.length, i === "" ? "" : t + i + Rc(s, e);
}
function Vx(s, e) {
  const t = tp(s, e);
  return e += t.length, t === "" ? "" : t + Rc(s, e);
}
const Hx = Pc([zx, Bx, Vx]);
function Gx(s, e) {
  var t;
  const i = s.substr(e).match(/^[01]+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function $x(s, e) {
  const t = s.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0b") return "";
  const i = Gx(s, e);
  return i === "" ? "" : t + i;
}
function Wx(s, e) {
  var t;
  const i = s.substr(e).match(/^[0-7]+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Xx(s, e) {
  const t = s.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0o") return "";
  const i = Wx(s, e);
  return i === "" ? "" : t + i;
}
function jx(s, e) {
  var t;
  const i = s.substr(e).match(/^[0-9a-f]+/i);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Yx(s, e) {
  const t = s.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0x") return "";
  const i = jx(s, e);
  return i === "" ? "" : t + i;
}
const qx = Pc([$x, Xx, Yx]), Kx = Pc([qx, Hx]);
function Zx(s, e) {
  const t = Kx(s, e);
  return e += t.length, t === "" ? null : { evaluable: new Lx(t), cursor: e };
}
function Jx(s, e) {
  const t = s.substr(e, 1);
  if (e += t.length, t !== "(") return null;
  const i = np(s, e);
  if (!i) return null;
  e = i.cursor, e += pr(s, e).length;
  const n = s.substr(e, 1);
  return e += n.length, n !== ")" ? null : { evaluable: i.evaluable, cursor: e };
}
function Qx(s, e) {
  var t;
  return (t = Zx(s, e)) !== null && t !== void 0 ? t : Jx(s, e);
}
function ip(s, e) {
  const t = Qx(s, e);
  if (t) return t;
  const i = s.substr(e, 1);
  if (e += i.length, i !== "+" && i !== "-" && i !== "~") return null;
  const n = ip(s, e);
  return n ? (e = n.cursor, { cursor: e, evaluable: new Ox(i, n.evaluable) }) : null;
}
function ew(s, e, t) {
  t += pr(e, t).length;
  const i = s.filter((n) => e.startsWith(n, t))[0];
  return i ? (t += i.length, t += pr(e, t).length, { cursor: t, operator: i }) : null;
}
function tw(s, e) {
  return (t, i) => {
    const n = s(t, i);
    if (!n) return null;
    i = n.cursor;
    let r = n.evaluable;
    for (; ; ) {
      const o = ew(e, t, i);
      if (!o) break;
      i = o.cursor;
      const a = s(t, i);
      if (!a) return null;
      i = a.cursor, r = new Nx(o.operator, r, a.evaluable);
    }
    return r ? { cursor: i, evaluable: r } : null;
  };
}
const iw = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((s, e) => tw(s, e), ip);
function np(s, e) {
  return e += pr(s, e).length, iw(s, e);
}
function nw(s) {
  const e = np(s, 0);
  return !e || e.cursor + pr(s, e.cursor).length !== s.length ? null : e.evaluable;
}
function Vi(s) {
  var e;
  const t = nw(s);
  return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0 ? e : null;
}
function sp(s) {
  if (typeof s == "number") return s;
  if (typeof s == "string") {
    const e = Vi(s);
    if (!ht(e)) return e;
  }
  return 0;
}
function sw(s) {
  return String(s);
}
function Zt(s) {
  return (e) => e.toFixed(Math.max(Math.min(s, 20), 0));
}
function nt(s, e, t, i, n) {
  const r = (s - e) / (t - e);
  return i + r * (n - i);
}
function Cd(s) {
  return String(s.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
}
function Tt(s, e, t) {
  return Math.min(Math.max(s, e), t);
}
function rp(s, e) {
  return (s % e + e) % e;
}
function rw(s, e) {
  return ht(s.step) ? Math.max(Cd(e), 2) : Cd(s.step);
}
function op(s) {
  var e;
  return (e = s.step) !== null && e !== void 0 ? e : 1;
}
function ap(s, e) {
  var t;
  const i = Math.abs((t = s.step) !== null && t !== void 0 ? t : e);
  return i === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(i)) - 1);
}
function lp(s, e) {
  return ht(s.step) ? null : new Dx(s.step, e);
}
function cp(s) {
  return !ht(s.max) && !ht(s.min) ? new Ar({ max: s.max, min: s.min }) : !ht(s.max) || !ht(s.min) ? new Rx({ max: s.max, min: s.min }) : null;
}
function hp(s, e) {
  var t, i, n;
  return { formatter: (t = s.format) !== null && t !== void 0 ? t : Zt(rw(s, e)), keyScale: (i = s.keyScale) !== null && i !== void 0 ? i : op(s), pointerScale: (n = s.pointerScale) !== null && n !== void 0 ? n : ap(s, e) };
}
function dp(s) {
  return { format: s.optional.function, keyScale: s.optional.number, max: s.optional.number, min: s.optional.number, pointerScale: s.optional.number, step: s.optional.number };
}
function Dc(s) {
  return { constraint: s.constraint, textProps: $e.fromObject(hp(s.params, s.initialValue)) };
}
class $n {
  constructor(e) {
    this.controller = e;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(e) {
    this.controller.viewProps.set("disabled", e);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(e) {
    this.controller.viewProps.set("hidden", e);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(e) {
    return this.controller.importState(e);
  }
  exportState() {
    return this.controller.exportState();
  }
}
class na {
  constructor(e) {
    this.target = e;
  }
}
class Pr extends na {
  constructor(e, t, i) {
    super(e), this.value = t, this.last = i ?? true;
  }
}
class ow extends na {
  constructor(e, t) {
    super(e), this.expanded = t;
  }
}
class aw extends na {
  constructor(e, t) {
    super(e), this.index = t;
  }
}
class lw extends na {
  constructor(e, t) {
    super(e), this.native = t;
  }
}
class mr extends $n {
  constructor(e) {
    super(e), this.onValueChange_ = this.onValueChange_.bind(this), this.emitter_ = new Mt(), this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(e) {
    this.controller.tag = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(e) {
    const t = this.controller.value;
    this.emitter_.emit("change", new Pr(this, t.binding.target.read(), e.options.last));
  }
}
class cw {
  constructor(e, t) {
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = t, this.value_ = e, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.emitter = new Mt();
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  set rawValue(e) {
    this.value_.rawValue = e;
  }
  setRawValue(e, t) {
    this.value_.setRawValue(e, t);
  }
  fetch() {
    this.value_.rawValue = this.binding.read();
  }
  push() {
    this.binding.write(this.value_.rawValue);
  }
  onValueBeforeChange_(e) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), { sender: this }));
  }
  onValueChange_(e) {
    this.push(), this.emitter.emit("change", Object.assign(Object.assign({}, e), { sender: this }));
  }
}
function hw(s) {
  if (!("binding" in s)) return false;
  const e = s.binding;
  return Ac(e) && "read" in e && "write" in e;
}
function dw(s, e) {
  const i = Object.keys(e).reduce((n, r) => {
    if (n === void 0) return;
    const o = e[r], a = o(s[r]);
    return a.succeeded ? Object.assign(Object.assign({}, n), { [r]: a.value }) : void 0;
  }, {});
  return i;
}
function uw(s, e) {
  return s.reduce((t, i) => {
    if (t === void 0) return;
    const n = e(i);
    if (!(!n.succeeded || n.value === void 0)) return [...t, n.value];
  }, []);
}
function pw(s) {
  return s === null ? false : typeof s == "object";
}
function Li(s) {
  return (e) => (t) => {
    if (!e && t === void 0) return { succeeded: false, value: void 0 };
    if (e && t === void 0) return { succeeded: true, value: void 0 };
    const i = s(t);
    return i !== void 0 ? { succeeded: true, value: i } : { succeeded: false, value: void 0 };
  };
}
function Td(s) {
  return { custom: (e) => Li(e)(s), boolean: Li((e) => typeof e == "boolean" ? e : void 0)(s), number: Li((e) => typeof e == "number" ? e : void 0)(s), string: Li((e) => typeof e == "string" ? e : void 0)(s), function: Li((e) => typeof e == "function" ? e : void 0)(s), constant: (e) => Li((t) => t === e ? e : void 0)(s), raw: Li((e) => e)(s), object: (e) => Li((t) => {
    if (pw(t)) return dw(t, e);
  })(s), array: (e) => Li((t) => {
    if (Array.isArray(t)) return uw(t, e);
  })(s) };
}
const ic = { optional: Td(true), required: Td(false) };
function vt(s, e) {
  const t = e(ic), i = ic.required.object(t)(s);
  return i.succeeded ? i.value : void 0;
}
function ii(s, e, t, i) {
  if (e && !e(s)) return false;
  const n = vt(s, t);
  return n ? i(n) : false;
}
function ni(s, e) {
  var t;
  return zn((t = s == null ? void 0 : s()) !== null && t !== void 0 ? t : {}, e);
}
function kn(s) {
  return "value" in s;
}
function up(s) {
  if (!Tc(s) || !("binding" in s)) return false;
  const e = s.binding;
  return Ac(e);
}
const yi = "http://www.w3.org/2000/svg";
function Yo(s) {
  s.offsetHeight;
}
function fw(s, e) {
  const t = s.style.transition;
  s.style.transition = "none", e(), s.style.transition = t;
}
function Lc(s) {
  return s.ontouchstart !== void 0;
}
function mw() {
  return globalThis;
}
function gw() {
  return mw().document;
}
function vw(s) {
  const e = s.ownerDocument.defaultView;
  return e && "document" in e ? s.getContext("2d", { willReadFrequently: true }) : null;
}
const _w = { check: '<path d="M2 8l4 4l8 -8"/>', dropdown: '<path d="M5 7h6l-3 3 z"/>', p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>' };
function sa(s, e) {
  const t = s.createElementNS(yi, "svg");
  return t.innerHTML = _w[e], t;
}
function pp(s, e, t) {
  s.insertBefore(e, s.children[t]);
}
function Ic(s) {
  s.parentElement && s.parentElement.removeChild(s);
}
function fp(s) {
  for (; s.children.length > 0; ) s.removeChild(s.children[0]);
}
function bw(s) {
  for (; s.childNodes.length > 0; ) s.removeChild(s.childNodes[0]);
}
function mp(s) {
  return s.relatedTarget ? s.relatedTarget : "explicitOriginalTarget" in s ? s.explicitOriginalTarget : null;
}
function zi(s, e) {
  s.emitter.on("change", (t) => {
    e(t.rawValue);
  }), e(s.rawValue);
}
function Si(s, e, t) {
  zi(s.value(e), t);
}
const xw = "tp";
function Ze(s) {
  return (t, i) => [xw, "-", s, "v", t ? `_${t}` : "", i ? `-${i}` : ""].join("");
}
const Ks = Ze("lbl");
function ww(s, e) {
  const t = s.createDocumentFragment();
  return e.split(`
`).map((n) => s.createTextNode(n)).forEach((n, r) => {
    r > 0 && t.appendChild(s.createElement("br")), t.appendChild(n);
  }), t;
}
class gp {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Ks()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(Ks("l")), Si(t.props, "label", (r) => {
      ht(r) ? this.element.classList.add(Ks(void 0, "nol")) : (this.element.classList.remove(Ks(void 0, "nol")), bw(i), i.appendChild(ww(e, r)));
    }), this.element.appendChild(i), this.labelElement = i;
    const n = e.createElement("div");
    n.classList.add(Ks("v")), this.element.appendChild(n), this.valueElement = n;
  }
}
class vp {
  constructor(e, t) {
    this.props = t.props, this.valueController = t.valueController, this.viewProps = t.valueController.viewProps, this.view = new gp(e, { props: t.props, viewProps: this.viewProps }), this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(e) {
    return ii(e, null, (t) => ({ label: t.optional.string }), (t) => (this.props.set("label", t.label), true));
  }
  exportProps() {
    return ni(null, { label: this.props.get("label") });
  }
}
function yw() {
  return ["veryfirst", "first", "last", "verylast"];
}
const Ad = Ze(""), Pd = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
class ra {
  constructor(e) {
    this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
    const t = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      yw().forEach((i) => {
        t.classList.remove(Ad(void 0, Pd[i]));
      }), this.blade.get("positions").forEach((i) => {
        t.classList.add(Ad(void 0, Pd[i]));
      });
    }), this.viewProps.handleDispose(() => {
      Ic(t);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(e) {
    this.parent_ = e, this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(e) {
    return ii(e, null, (t) => ({ disabled: t.required.boolean, hidden: t.required.boolean }), (t) => (this.viewProps.importState(t), true));
  }
  exportState() {
    return ni(null, Object.assign({}, this.viewProps.exportState()));
  }
}
class Bn extends ra {
  constructor(e, t) {
    if (t.value !== t.valueController.value) throw bt.shouldNeverHappen();
    const i = t.valueController.viewProps, n = new vp(e, { blade: t.blade, props: t.props, valueController: t.valueController });
    super(Object.assign(Object.assign({}, t), { view: new gp(e, { props: t.props, viewProps: i }), viewProps: i })), this.labelController = n, this.value = t.value, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importState(e) {
    return ii(e, (t) => {
      var i, n, r;
      return super.importState(t) && this.labelController.importProps(t) && ((r = (n = (i = this.valueController).importProps) === null || n === void 0 ? void 0 : n.call(i, e)) !== null && r !== void 0 ? r : true);
    }, (t) => ({ value: t.optional.raw }), (t) => (t.value && (this.value.rawValue = t.value), true));
  }
  exportState() {
    var e, t, i;
    return ni(() => super.exportState(), Object.assign(Object.assign({ value: this.value.rawValue }, this.labelController.exportProps()), (i = (t = (e = this.valueController).exportProps) === null || t === void 0 ? void 0 : t.call(e)) !== null && i !== void 0 ? i : {}));
  }
}
function Rd(s) {
  const e = Object.assign({}, s);
  return delete e.value, e;
}
class _p extends Bn {
  constructor(e, t) {
    super(e, t), this.tag = t.tag;
  }
  importState(e) {
    return ii(e, (t) => super.importState(Rd(e)), (t) => ({ tag: t.optional.string }), (t) => (this.tag = t.tag, true));
  }
  exportState() {
    return ni(() => Rd(super.exportState()), { binding: { key: this.value.binding.target.key, value: this.value.binding.target.read() }, tag: this.tag });
  }
}
function Sw(s) {
  return kn(s) && up(s.value);
}
class Ew extends _p {
  importState(e) {
    return ii(e, (t) => super.importState(t), (t) => ({ binding: t.required.object({ value: t.required.raw }) }), (t) => (this.value.binding.inject(t.binding.value), this.value.fetch(), true));
  }
}
function Mw(s) {
  return kn(s) && hw(s.value);
}
function bp(s, e) {
  for (; s.length < e; ) s.push(void 0);
}
function Cw(s) {
  const e = [];
  return bp(e, s), e;
}
function Tw(s) {
  const e = s.indexOf(void 0);
  return e < 0 ? s : s.slice(0, e);
}
function Aw(s, e) {
  const t = [...Tw(s), e];
  return t.length > s.length ? t.splice(0, t.length - s.length) : bp(t, s.length), t;
}
class Pw {
  constructor(e) {
    this.emitter = new Mt(), this.onTick_ = this.onTick_.bind(this), this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = e.binding, this.value_ = mt(Cw(e.bufferSize)), this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.fetch();
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  set rawValue(e) {
    this.value_.rawValue = e;
  }
  setRawValue(e, t) {
    this.value_.setRawValue(e, t);
  }
  fetch() {
    this.value_.rawValue = Aw(this.value_.rawValue, this.binding.read());
  }
  onTick_() {
    this.fetch();
  }
  onValueBeforeChange_(e) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), { sender: this }));
  }
  onValueChange_(e) {
    this.emitter.emit("change", Object.assign(Object.assign({}, e), { sender: this }));
  }
}
function Rw(s) {
  if (!("binding" in s)) return false;
  const e = s.binding;
  return Ac(e) && "read" in e && !("write" in e);
}
class Dw extends _p {
  exportState() {
    return ni(() => super.exportState(), { binding: { readonly: true } });
  }
}
function Lw(s) {
  return kn(s) && Rw(s.value);
}
class Iw extends $n {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get title() {
    var e;
    return (e = this.controller.buttonController.props.get("title")) !== null && e !== void 0 ? e : "";
  }
  set title(e) {
    this.controller.buttonController.props.set("title", e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.controller.buttonController.emitter.on(e, (r) => {
      i(new lw(this, r.nativeEvent));
    }), this;
  }
  off(e, t) {
    return this.controller.buttonController.emitter.off(e, t), this;
  }
}
function Nw(s, e, t) {
  t ? s.classList.add(e) : s.classList.remove(e);
}
function Us(s, e) {
  return (t) => {
    Nw(s, e, t);
  };
}
function Nc(s, e) {
  zi(s, (t) => {
    e.textContent = t ?? "";
  });
}
const Ka = Ze("btn");
class kw {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Ka()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("button");
    i.classList.add(Ka("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
    const n = e.createElement("div");
    n.classList.add(Ka("t")), Nc(t.props.value("title"), n), this.buttonElement.appendChild(n);
  }
}
class Ow {
  constructor(e, t) {
    this.emitter = new Mt(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new kw(e, { props: this.props, viewProps: this.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(e) {
    return ii(e, null, (t) => ({ title: t.optional.string }), (t) => (this.props.set("title", t.title), true));
  }
  exportProps() {
    return ni(null, { title: this.props.get("title") });
  }
  onClick_(e) {
    this.emitter.emit("click", { nativeEvent: e, sender: this });
  }
}
class Dd extends ra {
  constructor(e, t) {
    const i = new Ow(e, { props: t.buttonProps, viewProps: t.viewProps }), n = new vp(e, { blade: t.blade, props: t.labelProps, valueController: i });
    super({ blade: t.blade, view: n.view, viewProps: t.viewProps }), this.buttonController = i, this.labelController = n;
  }
  importState(e) {
    return ii(e, (t) => super.importState(t) && this.buttonController.importProps(t) && this.labelController.importProps(t), () => ({}), () => true);
  }
  exportState() {
    return ni(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()));
  }
}
class xp {
  constructor(e) {
    const [t, i] = e.split("-"), n = t.split(".");
    this.major = parseInt(n[0], 10), this.minor = parseInt(n[1], 10), this.patch = parseInt(n[2], 10), this.prerelease = i ?? null;
  }
  toString() {
    const e = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [e, this.prerelease].join("-") : e;
  }
}
const Fs = new xp("2.0.4");
function Gt(s) {
  return Object.assign({ core: Fs }, s);
}
const Uw = Gt({ id: "button", type: "blade", accept(s) {
  const e = vt(s, (t) => ({ title: t.required.string, view: t.required.constant("button"), label: t.optional.string }));
  return e ? { params: e } : null;
}, controller(s) {
  return new Dd(s.document, { blade: s.blade, buttonProps: $e.fromObject({ title: s.params.title }), labelProps: $e.fromObject({ label: s.params.label }), viewProps: s.viewProps });
}, api(s) {
  return s.controller instanceof Dd ? new Iw(s.controller) : null;
} });
function Fw(s, e) {
  return s.addBlade(Object.assign(Object.assign({}, e), { view: "button" }));
}
function zw(s, e) {
  return s.addBlade(Object.assign(Object.assign({}, e), { view: "folder" }));
}
function Bw(s, e) {
  return s.addBlade(Object.assign(Object.assign({}, e), { view: "tab" }));
}
function Vw(s) {
  return Tc(s) ? "refresh" in s && typeof s.refresh == "function" : false;
}
function Hw(s, e) {
  if (!jo.isBindable(s)) throw bt.notBindable();
  return new jo(s, e);
}
class Gw {
  constructor(e, t) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.controller_ = e, this.emitter_ = new Mt(), this.pool_ = t, this.controller_.rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((e) => this.pool_.createApi(e));
  }
  addBinding(e, t, i) {
    const n = i ?? {}, r = this.controller_.element.ownerDocument, o = this.pool_.createBinding(r, Hw(e, t), n), a = this.pool_.createBindingApi(o);
    return this.add(a, n.index);
  }
  addFolder(e) {
    return zw(this, e);
  }
  addButton(e) {
    return Fw(this, e);
  }
  addTab(e) {
    return Bw(this, e);
  }
  add(e, t) {
    const i = e.controller;
    return this.controller_.rack.add(i, t), e;
  }
  remove(e) {
    this.controller_.rack.remove(e.controller);
  }
  addBlade(e) {
    const t = this.controller_.element.ownerDocument, i = this.pool_.createBlade(t, e), n = this.pool_.createApi(i);
    return this.add(n, e.index);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
  refresh() {
    this.children.forEach((e) => {
      Vw(e) && e.refresh();
    });
  }
  onRackValueChange_(e) {
    const t = e.bladeController, i = this.pool_.createApi(t), n = up(t.value) ? t.value.binding : null;
    this.emitter_.emit("change", new Pr(i, n ? n.target.read() : t.value.rawValue, e.options.last));
  }
}
class kc extends $n {
  constructor(e, t) {
    super(e), this.rackApi_ = new Gw(e.rackController, t);
  }
  refresh() {
    this.rackApi_.refresh();
  }
}
class Oc extends ra {
  constructor(e) {
    super({ blade: e.blade, view: e.view, viewProps: e.rackController.viewProps }), this.rackController = e.rackController;
  }
  importState(e) {
    return ii(e, (t) => super.importState(t), (t) => ({ children: t.required.array(t.required.raw) }), (t) => this.rackController.rack.children.every((i, n) => i.importState(t.children[n])));
  }
  exportState() {
    return ni(() => super.exportState(), { children: this.rackController.rack.children.map((e) => e.exportState()) });
  }
}
function nc(s) {
  return "rackController" in s;
}
class $w {
  constructor(e) {
    this.emitter = new Mt(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(e) {
    for (const t of this.allItems()) if (e(t)) return t;
    return null;
  }
  includes(e) {
    return this.cache_.has(e);
  }
  add(e, t) {
    if (this.includes(e)) throw bt.shouldNeverHappen();
    const i = t !== void 0 ? t : this.items_.length;
    this.items_.splice(i, 0, e), this.cache_.add(e);
    const n = this.extract_(e);
    n && (n.emitter.on("add", this.onSubListAdd_), n.emitter.on("remove", this.onSubListRemove_), n.allItems().forEach((r) => {
      this.cache_.add(r);
    })), this.emitter.emit("add", { index: i, item: e, root: this, target: this });
  }
  remove(e) {
    const t = this.items_.indexOf(e);
    if (t < 0) return;
    this.items_.splice(t, 1), this.cache_.delete(e);
    const i = this.extract_(e);
    i && (i.allItems().forEach((n) => {
      this.cache_.delete(n);
    }), i.emitter.off("add", this.onSubListAdd_), i.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", { index: t, item: e, root: this, target: this });
  }
  onSubListAdd_(e) {
    this.cache_.add(e.item), this.emitter.emit("add", { index: e.index, item: e.item, root: this, target: e.target });
  }
  onSubListRemove_(e) {
    this.cache_.delete(e.item), this.emitter.emit("remove", { index: e.index, item: e.item, root: this, target: e.target });
  }
}
function Ww(s, e) {
  for (let t = 0; t < s.length; t++) {
    const i = s[t];
    if (kn(i) && i.value === e) return i;
  }
  return null;
}
function Xw(s) {
  return nc(s) ? s.rackController.rack.bcSet_ : null;
}
class jw {
  constructor(e) {
    var t, i;
    this.emitter = new Mt(), this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onRackLayout_ = this.onRackLayout_.bind(this), this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.blade_ = (t = e.blade) !== null && t !== void 0 ? t : null, (i = this.blade_) === null || i === void 0 || i.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = e.viewProps, this.bcSet_ = new $w(Xw), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(e, t) {
    var i;
    (i = e.parent) === null || i === void 0 || i.remove(e), e.parent = this, this.bcSet_.add(e, t);
  }
  remove(e) {
    e.parent = null, this.bcSet_.remove(e);
  }
  find(e) {
    return this.bcSet_.allItems().filter(e);
  }
  onSetAdd_(e) {
    this.updatePositions_();
    const t = e.target === e.root;
    if (this.emitter.emit("add", { bladeController: e.item, index: e.index, root: t, sender: this }), !t) return;
    const i = e.item;
    if (i.viewProps.emitter.on("change", this.onChildViewPropsChange_), i.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), i.viewProps.handleDispose(this.onChildDispose_), kn(i)) i.value.emitter.on("change", this.onChildValueChange_);
    else if (nc(i)) {
      const n = i.rackController.rack;
      if (n) {
        const r = n.emitter;
        r.on("layout", this.onRackLayout_), r.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(e) {
    this.updatePositions_();
    const t = e.target === e.root;
    if (this.emitter.emit("remove", { bladeController: e.item, root: t, sender: this }), !t) return;
    const i = e.item;
    if (kn(i)) i.value.emitter.off("change", this.onChildValueChange_);
    else if (nc(i)) {
      const n = i.rackController.rack;
      if (n) {
        const r = n.emitter;
        r.off("layout", this.onRackLayout_), r.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const e = this.bcSet_.items.filter((n) => !n.viewProps.get("hidden")), t = e[0], i = e[e.length - 1];
    this.bcSet_.items.forEach((n) => {
      const r = [];
      n === t && (r.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && r.push("veryfirst")), n === i && (r.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && r.push("verylast")), n.blade.set("positions", r);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_(), this.emitter.emit("layout", { sender: this });
  }
  onChildViewPropsChange_(e) {
    this.updatePositions_(), this.emitter.emit("layout", { sender: this });
  }
  onChildDispose_() {
    this.bcSet_.items.filter((t) => t.viewProps.get("disposed")).forEach((t) => {
      this.bcSet_.remove(t);
    });
  }
  onChildValueChange_(e) {
    const t = Ww(this.find(kn), e.sender);
    if (!t) throw bt.alreadyDisposed();
    this.emitter.emit("valuechange", { bladeController: t, options: e.options, sender: this });
  }
  onRackLayout_(e) {
    this.updatePositions_(), this.emitter.emit("layout", { sender: this });
  }
  onRackValueChange_(e) {
    this.emitter.emit("valuechange", { bladeController: e.bladeController, options: e.options, sender: this });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
}
class Uc {
  constructor(e) {
    this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.element = e.element, this.viewProps = e.viewProps;
    const t = new jw({ blade: e.root ? void 0 : e.blade, viewProps: e.viewProps });
    t.emitter.on("add", this.onRackAdd_), t.emitter.on("remove", this.onRackRemove_), this.rack = t, this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) this.rack.children[i].viewProps.set("disposed", true);
    });
  }
  onRackAdd_(e) {
    e.root && pp(this.element, e.bladeController.view.element, e.index);
  }
  onRackRemove_(e) {
    e.root && Ic(e.bladeController.view.element);
  }
}
function zs() {
  return new $e({ positions: mt([], { equals: Ex }) });
}
class Rr extends $e {
  constructor(e) {
    super(e);
  }
  static create(e) {
    const t = { completed: true, expanded: e, expandedHeight: null, shouldFixHeight: false, temporaryExpanded: null }, i = $e.createCore(t);
    return new Rr(i);
  }
  get styleExpanded() {
    var e;
    return (e = this.get("temporaryExpanded")) !== null && e !== void 0 ? e : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) return "0";
    const e = this.get("expandedHeight");
    return this.get("shouldFixHeight") && !ht(e) ? `${e}px` : "auto";
  }
  bindExpandedClass(e, t) {
    const i = () => {
      this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
    };
    Si(this, "expanded", i), Si(this, "temporaryExpanded", i);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false), this.set("expandedHeight", null), this.set("completed", true);
  }
}
function Yw(s, e) {
  let t = 0;
  return fw(e, () => {
    s.set("expandedHeight", null), s.set("temporaryExpanded", true), Yo(e), t = e.clientHeight, s.set("temporaryExpanded", null), Yo(e);
  }), t;
}
function Ld(s, e) {
  e.style.height = s.styleHeight;
}
function Fc(s, e) {
  s.value("expanded").emitter.on("beforechange", () => {
    if (s.set("completed", false), ht(s.get("expandedHeight"))) {
      const t = Yw(s, e);
      t > 0 && s.set("expandedHeight", t);
    }
    s.set("shouldFixHeight", true), Yo(e);
  }), s.emitter.on("change", () => {
    Ld(s, e);
  }), Ld(s, e), e.addEventListener("transitionend", (t) => {
    t.propertyName === "height" && s.cleanUpTransition();
  });
}
class wp extends kc {
  constructor(e, t) {
    super(e, t), this.emitter_ = new Mt(), this.controller.foldable.value("expanded").emitter.on("change", (i) => {
      this.emitter_.emit("fold", new ow(this, i.sender.rawValue));
    }), this.rackApi_.on("change", (i) => {
      this.emitter_.emit("change", i);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(e) {
    this.controller.foldable.set("expanded", e);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(e) {
    this.controller.props.set("title", e);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(e, t, i) {
    return this.rackApi_.addBinding(e, t, i);
  }
  addFolder(e) {
    return this.rackApi_.addFolder(e);
  }
  addButton(e) {
    return this.rackApi_.addButton(e);
  }
  addTab(e) {
    return this.rackApi_.addTab(e);
  }
  add(e, t) {
    return this.rackApi_.add(e, t);
  }
  remove(e) {
    this.rackApi_.remove(e);
  }
  addBlade(e) {
    return this.rackApi_.addBlade(e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
const yp = Ze("cnt");
class qw {
  constructor(e, t) {
    var i;
    this.className_ = Ze((i = t.viewName) !== null && i !== void 0 ? i : "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), yp()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), Si(this.foldable_, "completed", Us(this.element, this.className_(void 0, "cpl")));
    const n = e.createElement("button");
    n.classList.add(this.className_("b")), Si(t.props, "title", (c) => {
      ht(c) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
    }), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
    const r = e.createElement("div");
    r.classList.add(this.className_("i")), this.element.appendChild(r);
    const o = e.createElement("div");
    o.classList.add(this.className_("t")), Nc(t.props.value("title"), o), this.buttonElement.appendChild(o), this.titleElement = o;
    const a = e.createElement("div");
    a.classList.add(this.className_("m")), this.buttonElement.appendChild(a);
    const l = e.createElement("div");
    l.classList.add(this.className_("c")), this.element.appendChild(l), this.containerElement = l;
  }
}
class sc extends Oc {
  constructor(e, t) {
    var i;
    const n = Rr.create((i = t.expanded) !== null && i !== void 0 ? i : true), r = new qw(e, { foldable: n, props: t.props, viewName: t.root ? "rot" : void 0, viewProps: t.viewProps });
    super(Object.assign(Object.assign({}, t), { rackController: new Uc({ blade: t.blade, element: r.containerElement, root: t.root, viewProps: t.viewProps }), view: r })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = n, Fc(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    }), this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(e) {
    return ii(e, (t) => super.importState(t), (t) => ({ expanded: t.required.boolean, title: t.optional.string }), (t) => (this.foldable.set("expanded", t.expanded), this.props.set("title", t.title), true));
  }
  exportState() {
    return ni(() => super.exportState(), { expanded: this.foldable.get("expanded"), title: this.props.get("title") });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
}
const Kw = Gt({ id: "folder", type: "blade", accept(s) {
  const e = vt(s, (t) => ({ title: t.required.string, view: t.required.constant("folder"), expanded: t.optional.boolean }));
  return e ? { params: e } : null;
}, controller(s) {
  return new sc(s.document, { blade: s.blade, expanded: s.params.expanded, props: $e.fromObject({ title: s.params.title }), viewProps: s.viewProps });
}, api(s) {
  return s.controller instanceof sc ? new wp(s.controller, s.pool) : null;
} }), Zw = Ze("");
function Id(s, e) {
  return Us(s, Zw(void 0, e));
}
class Gi extends $e {
  constructor(e) {
    var t;
    super(e), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = Px(mt(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (t = this.get("parent")) === null || t === void 0 || t.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
  }
  static create(e) {
    var t, i, n;
    const r = e ?? {};
    return new Gi($e.createCore({ disabled: (t = r.disabled) !== null && t !== void 0 ? t : false, disposed: false, hidden: (i = r.hidden) !== null && i !== void 0 ? i : false, parent: (n = r.parent) !== null && n !== void 0 ? n : null }));
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(e) {
    zi(this.globalDisabled_, Id(e, "disabled")), Si(this, "hidden", Id(e, "hidden"));
  }
  bindDisabled(e) {
    zi(this.globalDisabled_, (t) => {
      e.disabled = t;
    });
  }
  bindTabIndex(e) {
    zi(this.globalDisabled_, (t) => {
      e.tabIndex = t ? -1 : 0;
    });
  }
  handleDispose(e) {
    this.value("disposed").emitter.on("change", (t) => {
      t && e();
    });
  }
  importState(e) {
    this.set("disabled", e.disabled), this.set("hidden", e.hidden);
  }
  exportState() {
    return { disabled: this.get("disabled"), hidden: this.get("hidden") };
  }
  getGlobalDisabled_() {
    const e = this.get("parent");
    return (e ? e.globalDisabled.rawValue : false) || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(e) {
    var t;
    const i = e.previousRawValue;
    i == null ? void 0 : i.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (t = this.get("parent")) === null || t === void 0 || t.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
  }
}
const Nd = Ze("tbp");
class Jw {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Nd()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(Nd("c")), this.element.appendChild(i), this.containerElement = i;
  }
}
const Zs = Ze("tbi");
class Qw {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Zs()), t.viewProps.bindClassModifiers(this.element), Si(t.props, "selected", (r) => {
      r ? this.element.classList.add(Zs(void 0, "sel")) : this.element.classList.remove(Zs(void 0, "sel"));
    });
    const i = e.createElement("button");
    i.classList.add(Zs("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
    const n = e.createElement("div");
    n.classList.add(Zs("t")), Nc(t.props.value("title"), n), this.buttonElement.appendChild(n), this.titleElement = n;
  }
}
class ey {
  constructor(e, t) {
    this.emitter = new Mt(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new Qw(e, { props: t.props, viewProps: t.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", { sender: this });
  }
}
class rc extends Oc {
  constructor(e, t) {
    const i = new Jw(e, { viewProps: t.viewProps });
    super(Object.assign(Object.assign({}, t), { rackController: new Uc({ blade: t.blade, element: i.containerElement, viewProps: t.viewProps }), view: i })), this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new ey(e, { props: t.itemProps, viewProps: Gi.create() }), this.ic_.emitter.on("click", this.onItemClick_), this.props = t.props, Si(this.props, "selected", (n) => {
      this.itemController.props.set("selected", n), this.viewProps.set("hidden", !n);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(e) {
    return ii(e, (t) => super.importState(t), (t) => ({ selected: t.required.boolean, title: t.required.string }), (t) => (this.ic_.props.set("selected", t.selected), this.ic_.props.set("title", t.title), true));
  }
  exportState() {
    return ni(() => super.exportState(), { selected: this.ic_.props.get("selected"), title: this.ic_.props.get("title") });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
}
class ty extends kc {
  constructor(e, t) {
    super(e, t), this.emitter_ = new Mt(), this.onSelect_ = this.onSelect_.bind(this), this.pool_ = t, this.rackApi_.on("change", (i) => {
      this.emitter_.emit("change", i);
    }), this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(e) {
    const t = this.controller.view.element.ownerDocument, i = new rc(t, { blade: zs(), itemProps: $e.fromObject({ selected: false, title: e.title }), props: $e.fromObject({ selected: false }), viewProps: Gi.create() }), n = this.pool_.createApi(i);
    return this.rackApi_.add(n, e.index);
  }
  removePage(e) {
    this.rackApi_.remove(this.rackApi_.children[e]);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
  onSelect_(e) {
    this.emitter_.emit("select", new aw(this, e.rawValue));
  }
}
class iy extends kc {
  get title() {
    var e;
    return (e = this.controller.itemController.props.get("title")) !== null && e !== void 0 ? e : "";
  }
  set title(e) {
    this.controller.itemController.props.set("title", e);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(e) {
    this.controller.props.set("selected", e);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(e) {
    return this.rackApi_.addButton(e);
  }
  addFolder(e) {
    return this.rackApi_.addFolder(e);
  }
  addTab(e) {
    return this.rackApi_.addTab(e);
  }
  add(e, t) {
    this.rackApi_.add(e, t);
  }
  remove(e) {
    this.rackApi_.remove(e);
  }
  addBinding(e, t, i) {
    return this.rackApi_.addBinding(e, t, i);
  }
  addBlade(e) {
    return this.rackApi_.addBlade(e);
  }
}
const kd = -1;
class ny {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = mt(true), this.selectedIndex = mt(kd), this.items_ = [];
  }
  add(e, t) {
    const i = t ?? this.items_.length;
    this.items_.splice(i, 0, e), e.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
  }
  remove(e) {
    const t = this.items_.indexOf(e);
    t < 0 || (this.items_.splice(t, 1), e.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = kd, this.empty.rawValue = true;
      return;
    }
    const e = this.items_.findIndex((t) => t.rawValue);
    e < 0 ? (this.items_.forEach((t, i) => {
      t.rawValue = i === 0;
    }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((t, i) => {
      t.rawValue = i === e;
    }), this.selectedIndex.rawValue = e), this.empty.rawValue = false;
  }
  onItemSelectedChange_(e) {
    if (e.rawValue) {
      const t = this.items_.findIndex((i) => i === e.sender);
      this.items_.forEach((i, n) => {
        i.rawValue = n === t;
      }), this.selectedIndex.rawValue = t;
    } else this.keepSelection_();
  }
}
const Js = Ze("tab");
class sy {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Js(), yp()), t.viewProps.bindClassModifiers(this.element), zi(t.empty, Us(this.element, Js(void 0, "nop")));
    const i = e.createElement("div");
    i.classList.add(Js("t")), this.element.appendChild(i), this.itemsElement = i;
    const n = e.createElement("div");
    n.classList.add(Js("i")), this.element.appendChild(n);
    const r = e.createElement("div");
    r.classList.add(Js("c")), this.element.appendChild(r), this.contentsElement = r;
  }
}
class Od extends Oc {
  constructor(e, t) {
    const i = new ny(), n = new sy(e, { empty: i.empty, viewProps: t.viewProps });
    super({ blade: t.blade, rackController: new Uc({ blade: t.blade, element: n.contentsElement, viewProps: t.viewProps }), view: n }), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
    const r = this.rackController.rack;
    r.emitter.on("add", this.onRackAdd_), r.emitter.on("remove", this.onRackRemove_), this.tab = i;
  }
  add(e, t) {
    this.rackController.rack.add(e, t);
  }
  remove(e) {
    this.rackController.rack.remove(this.rackController.rack.children[e]);
  }
  onRackAdd_(e) {
    if (!e.root) return;
    const t = e.bladeController;
    pp(this.view.itemsElement, t.itemController.view.element, e.index), t.itemController.viewProps.set("parent", this.viewProps), this.tab.add(t.props.value("selected"));
  }
  onRackRemove_(e) {
    if (!e.root) return;
    const t = e.bladeController;
    Ic(t.itemController.view.element), t.itemController.viewProps.set("parent", null), this.tab.remove(t.props.value("selected"));
  }
}
const Sp = Gt({ id: "tab", type: "blade", accept(s) {
  const e = vt(s, (t) => ({ pages: t.required.array(t.required.object({ title: t.required.string })), view: t.required.constant("tab") }));
  return !e || e.pages.length === 0 ? null : { params: e };
}, controller(s) {
  const e = new Od(s.document, { blade: s.blade, viewProps: s.viewProps });
  return s.params.pages.forEach((t) => {
    const i = new rc(s.document, { blade: zs(), itemProps: $e.fromObject({ selected: false, title: t.title }), props: $e.fromObject({ selected: false }), viewProps: Gi.create() });
    e.add(i);
  }), e;
}, api(s) {
  return s.controller instanceof Od ? new ty(s.controller, s.pool) : s.controller instanceof rc ? new iy(s.controller, s.pool) : null;
} });
function ry(s, e) {
  const t = s.accept(e.params);
  if (!t) return null;
  const i = vt(e.params, (n) => ({ disabled: n.optional.boolean, hidden: n.optional.boolean }));
  return s.controller({ blade: zs(), document: e.document, params: Object.assign(Object.assign({}, t.params), { disabled: i == null ? void 0 : i.disabled, hidden: i == null ? void 0 : i.hidden }), viewProps: Gi.create({ disabled: i == null ? void 0 : i.disabled, hidden: i == null ? void 0 : i.hidden }) });
}
class zc extends mr {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(e) {
    this.controller.valueController.props.set("options", e);
  }
}
class oy {
  constructor() {
    this.disabled = false, this.emitter = new Mt();
  }
  dispose() {
  }
  tick() {
    this.disabled || this.emitter.emit("tick", { sender: this });
  }
}
class ay {
  constructor(e, t) {
    this.disabled_ = false, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new Mt(), this.interval_ = t, this.setTimer_();
  }
  get disabled() {
    return this.disabled_;
  }
  set disabled(e) {
    this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_();
  }
  dispose() {
    this.clearTimer_();
  }
  clearTimer_() {
    if (this.timerId_ === null) return;
    const e = this.doc_.defaultView;
    e && e.clearInterval(this.timerId_), this.timerId_ = null;
  }
  setTimer_() {
    if (this.clearTimer_(), this.interval_ <= 0) return;
    const e = this.doc_.defaultView;
    e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
  }
  onTick_() {
    this.disabled_ || this.emitter.emit("tick", { sender: this });
  }
}
class Dr {
  constructor(e) {
    this.constraints = e;
  }
  constrain(e) {
    return this.constraints.reduce((t, i) => i.constrain(t), e);
  }
}
function qo(s, e) {
  if (s instanceof e) return s;
  if (s instanceof Dr) {
    const t = s.constraints.reduce((i, n) => i || (n instanceof e ? n : null), null);
    if (t) return t;
  }
  return null;
}
class Lr {
  constructor(e) {
    this.values = $e.fromObject({ options: e });
  }
  constrain(e) {
    const t = this.values.get("options");
    return t.length === 0 || t.filter((n) => n.value === e).length > 0 ? e : t[0].value;
  }
}
function Ir(s) {
  var e;
  const t = ic;
  if (Array.isArray(s)) return (e = vt({ items: s }, (i) => ({ items: i.required.array(i.required.object({ text: i.required.string, value: i.required.raw })) }))) === null || e === void 0 ? void 0 : e.items;
  if (typeof s == "object") return t.required.raw(s).value;
}
function Bc(s) {
  if (Array.isArray(s)) return s;
  const e = [];
  return Object.keys(s).forEach((t) => {
    e.push({ text: t, value: s[t] });
  }), e;
}
function Vc(s) {
  return ht(s) ? null : new Lr(Bc(s));
}
const Za = Ze("lst");
class ly {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(Za()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("select");
    i.classList.add(Za("s")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.selectElement = i;
    const n = e.createElement("div");
    n.classList.add(Za("m")), n.appendChild(sa(e, "dropdown")), this.element.appendChild(n), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, Si(this.props_, "options", (r) => {
      fp(this.selectElement), r.forEach((o) => {
        const a = e.createElement("option");
        a.textContent = o.text, this.selectElement.appendChild(a);
      }), this.update_();
    });
  }
  update_() {
    const e = this.props_.get("options").map((t) => t.value);
    this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
}
class mn {
  constructor(e, t) {
    this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new ly(e, { props: this.props, value: this.value, viewProps: this.viewProps }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const t = e.currentTarget;
    this.value.rawValue = this.props.get("options")[t.selectedIndex].value;
  }
  importProps(e) {
    return ii(e, null, (t) => ({ options: t.required.custom(Ir) }), (t) => (this.props.set("options", Bc(t.options)), true));
  }
  exportProps() {
    return ni(null, { options: this.props.get("options") });
  }
}
const Ud = Ze("pop");
class cy {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Ud()), t.viewProps.bindClassModifiers(this.element), zi(t.shows, Us(this.element, Ud(void 0, "v")));
  }
}
class Ep {
  constructor(e, t) {
    this.shows = mt(false), this.viewProps = t.viewProps, this.view = new cy(e, { shows: this.shows, viewProps: this.viewProps });
  }
}
const Fd = Ze("txt");
class hy {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(Fd()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
    const i = e.createElement("input");
    i.classList.add(Fd("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh();
  }
  refresh() {
    const e = this.props_.get("formatter");
    this.inputElement.value = e(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class gr {
  constructor(e, t) {
    this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new hy(e, { props: t.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const i = e.currentTarget.value, n = this.parser_(i);
    ht(n) || (this.value.rawValue = n), this.view.refresh();
  }
}
function dy(s) {
  return String(s);
}
function Mp(s) {
  return s === "false" ? false : !!s;
}
function zd(s) {
  return dy(s);
}
function uy(s) {
  return (e) => s.reduce((t, i) => t !== null ? t : i(e), null);
}
const py = Zt(0);
function Ko(s) {
  return py(s) + "%";
}
function Cp(s) {
  return String(s);
}
function oc(s) {
  return s;
}
function Bs({ primary: s, secondary: e, forward: t, backward: i }) {
  let n = false;
  function r(o) {
    n || (n = true, o(), n = false);
  }
  s.emitter.on("change", (o) => {
    r(() => {
      e.setRawValue(t(s.rawValue, e.rawValue), o.options);
    });
  }), e.emitter.on("change", (o) => {
    r(() => {
      s.setRawValue(i(s.rawValue, e.rawValue), o.options);
    }), r(() => {
      e.setRawValue(t(s.rawValue, e.rawValue), o.options);
    });
  }), r(() => {
    e.setRawValue(t(s.rawValue, e.rawValue), { forceEmit: false, last: true });
  });
}
function qt(s, e) {
  const t = s * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
  return e.upKey ? +t : e.downKey ? -t : 0;
}
function vr(s) {
  return { altKey: s.altKey, downKey: s.key === "ArrowDown", shiftKey: s.shiftKey, upKey: s.key === "ArrowUp" };
}
function Hi(s) {
  return { altKey: s.altKey, downKey: s.key === "ArrowLeft", shiftKey: s.shiftKey, upKey: s.key === "ArrowRight" };
}
function fy(s) {
  return s === "ArrowUp" || s === "ArrowDown";
}
function Tp(s) {
  return fy(s) || s === "ArrowLeft" || s === "ArrowRight";
}
function Ja(s, e) {
  var t, i;
  const n = e.ownerDocument.defaultView, r = e.getBoundingClientRect();
  return { x: s.pageX - (((t = n && n.scrollX) !== null && t !== void 0 ? t : 0) + r.left), y: s.pageY - (((i = n && n.scrollY) !== null && i !== void 0 ? i : 0) + r.top) };
}
class Wn {
  constructor(e) {
    this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new Mt(), e.addEventListener("touchstart", this.onTouchStart_, { passive: false }), e.addEventListener("touchmove", this.onTouchMove_, { passive: true }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(e) {
    const t = this.elem_.getBoundingClientRect();
    return { bounds: { width: t.width, height: t.height }, point: e ? { x: e.x, y: e.y } : null };
  }
  onMouseDown_(e) {
    var t;
    e.preventDefault(), (t = e.currentTarget) === null || t === void 0 || t.focus();
    const i = this.elem_.ownerDocument;
    i.addEventListener("mousemove", this.onDocumentMouseMove_), i.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", { altKey: e.altKey, data: this.computePosition_(Ja(e, this.elem_)), sender: this, shiftKey: e.shiftKey });
  }
  onDocumentMouseMove_(e) {
    this.emitter.emit("move", { altKey: e.altKey, data: this.computePosition_(Ja(e, this.elem_)), sender: this, shiftKey: e.shiftKey });
  }
  onDocumentMouseUp_(e) {
    const t = this.elem_.ownerDocument;
    t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", { altKey: e.altKey, data: this.computePosition_(Ja(e, this.elem_)), sender: this, shiftKey: e.shiftKey });
  }
  onTouchStart_(e) {
    e.preventDefault();
    const t = e.targetTouches.item(0), i = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", { altKey: e.altKey, data: this.computePosition_(t ? { x: t.clientX - i.left, y: t.clientY - i.top } : void 0), sender: this, shiftKey: e.shiftKey }), this.lastTouch_ = t;
  }
  onTouchMove_(e) {
    const t = e.targetTouches.item(0), i = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", { altKey: e.altKey, data: this.computePosition_(t ? { x: t.clientX - i.left, y: t.clientY - i.top } : void 0), sender: this, shiftKey: e.shiftKey }), this.lastTouch_ = t;
  }
  onTouchEnd_(e) {
    var t;
    const i = (t = e.targetTouches.item(0)) !== null && t !== void 0 ? t : this.lastTouch_, n = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", { altKey: e.altKey, data: this.computePosition_(i ? { x: i.clientX - n.left, y: i.clientY - n.top } : void 0), sender: this, shiftKey: e.shiftKey });
  }
}
const oi = Ze("txt");
class my {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(oi(), oi(void 0, "num")), t.arrayPosition && this.element.classList.add(oi(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("input");
    i.classList.add(oi("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(oi()), this.inputElement.classList.add(oi("i"));
    const n = e.createElement("div");
    n.classList.add(oi("k")), this.element.appendChild(n), this.knobElement = n;
    const r = e.createElementNS(yi, "svg");
    r.classList.add(oi("g")), this.knobElement.appendChild(r);
    const o = e.createElementNS(yi, "path");
    o.classList.add(oi("gb")), r.appendChild(o), this.guideBodyElem_ = o;
    const a = e.createElementNS(yi, "path");
    a.classList.add(oi("gh")), r.appendChild(a), this.guideHeadElem_ = a;
    const l = e.createElement("div");
    l.classList.add(Ze("tt")()), this.knobElement.appendChild(l), this.tooltipElem_ = l, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh();
  }
  onDraggingChange_(e) {
    if (e.rawValue === null) {
      this.element.classList.remove(oi(void 0, "drg"));
      return;
    }
    this.element.classList.add(oi(void 0, "drg"));
    const t = e.rawValue / this.props_.get("pointerScale"), i = t + (t > 0 ? -1 : t < 0 ? 1 : 0), n = Tt(-i, -4, 4);
    this.guideHeadElem_.setAttributeNS(null, "d", [`M ${i + n},0 L${i},4 L${i + n},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
    const r = this.props_.get("formatter");
    this.tooltipElem_.textContent = r(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`;
  }
  refresh() {
    const e = this.props_.get("formatter");
    this.inputElement.value = e(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class Nr {
  constructor(e, t) {
    var i;
    this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.parser_ = t.parser, this.props = t.props, this.sliderProps_ = (i = t.sliderProps) !== null && i !== void 0 ? i : null, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = mt(null), this.view = new my(e, { arrayPosition: t.arrayPosition, dragging: this.dragging_, props: this.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const n = new Wn(this.view.knobElement);
    n.emitter.on("down", this.onPointerDown_), n.emitter.on("move", this.onPointerMove_), n.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(e) {
    var t, i;
    const n = (t = this.sliderProps_) === null || t === void 0 ? void 0 : t.get("min"), r = (i = this.sliderProps_) === null || i === void 0 ? void 0 : i.get("max");
    let o = e;
    return n !== void 0 && (o = Math.max(o, n)), r !== void 0 && (o = Math.min(o, r)), o;
  }
  onInputChange_(e) {
    const i = e.currentTarget.value, n = this.parser_(i);
    ht(n) || (this.value.rawValue = this.constrainValue_(n)), this.view.refresh();
  }
  onInputKeyDown_(e) {
    const t = qt(this.props.get("keyScale"), vr(e));
    t !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t), { forceEmit: false, last: false });
  }
  onInputKeyUp_(e) {
    qt(this.props.get("keyScale"), vr(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(e) {
    if (!e.point) return null;
    const t = e.point.x - e.bounds.width / 2;
    return this.constrainValue_(this.originRawValue_ + t * this.props.get("pointerScale"));
  }
  onPointerMove_(e) {
    const t = this.computeDraggingValue_(e.data);
    t !== null && (this.value.setRawValue(t, { forceEmit: false, last: false }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
  }
  onPointerUp_(e) {
    const t = this.computeDraggingValue_(e.data);
    t !== null && (this.value.setRawValue(t, { forceEmit: true, last: true }), this.dragging_.rawValue = null);
  }
}
const Qa = Ze("sld");
class gy {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Qa()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(Qa("t")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.trackElement = i;
    const n = e.createElement("div");
    n.classList.add(Qa("k")), this.trackElement.appendChild(n), this.knobElement = n, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_();
  }
  update_() {
    const e = Tt(nt(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
    this.knobElement.style.width = `${e}%`;
  }
  onChange_() {
    this.update_();
  }
}
class vy {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new gy(e, { props: this.props, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Wn(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    e.point && this.value.setRawValue(nt(Tt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("min"), this.props.get("max")), t);
  }
  onPointerDownOrMove_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: true, last: true });
  }
  onKeyDown_(e) {
    const t = qt(this.props.get("keyScale"), Hi(e));
    t !== 0 && this.value.setRawValue(this.value.rawValue + t, { forceEmit: false, last: false });
  }
  onKeyUp_(e) {
    qt(this.props.get("keyScale"), Hi(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
  }
}
const el = Ze("sldtxt");
class _y {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(el());
    const i = e.createElement("div");
    i.classList.add(el("s")), this.sliderView_ = t.sliderView, i.appendChild(this.sliderView_.element), this.element.appendChild(i);
    const n = e.createElement("div");
    n.classList.add(el("t")), this.textView_ = t.textView, n.appendChild(this.textView_.element), this.element.appendChild(n);
  }
}
class Zo {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new vy(e, { props: t.sliderProps, value: t.value, viewProps: this.viewProps }), this.textC_ = new Nr(e, { parser: t.parser, props: t.textProps, sliderProps: t.sliderProps, value: t.value, viewProps: t.viewProps }), this.view = new _y(e, { sliderView: this.sliderC_.view, textView: this.textC_.view });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(e) {
    return ii(e, null, (t) => ({ max: t.required.number, min: t.required.number }), (t) => {
      const i = this.sliderC_.props;
      return i.set("max", t.max), i.set("min", t.min), true;
    });
  }
  exportProps() {
    const e = this.sliderC_.props;
    return ni(null, { max: e.get("max"), min: e.get("min") });
  }
}
function Ap(s) {
  return { sliderProps: new $e({ keyScale: s.keyScale, max: s.max, min: s.min }), textProps: new $e({ formatter: mt(s.formatter), keyScale: s.keyScale, pointerScale: mt(s.pointerScale) }) };
}
const by = { containerUnitSize: "cnt-usz" };
function Pp(s) {
  return `--${by[s]}`;
}
function _r(s) {
  return dp(s);
}
function rn(s) {
  if (tc(s)) return vt(s, _r);
}
function Oi(s, e) {
  if (!s) return;
  const t = [], i = lp(s, e);
  i && t.push(i);
  const n = cp(s);
  return n && t.push(n), new Dr(t);
}
function xy(s) {
  return s ? s.major === Fs.major : false;
}
function Rp(s) {
  if (s === "inline" || s === "popup") return s;
}
function kr(s, e) {
  s.write(e);
}
const yo = Ze("ckb");
class wy {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(yo()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("label");
    i.classList.add(yo("l")), this.element.appendChild(i), this.labelElement = i;
    const n = e.createElement("input");
    n.classList.add(yo("i")), n.type = "checkbox", this.labelElement.appendChild(n), this.inputElement = n, t.viewProps.bindDisabled(this.inputElement);
    const r = e.createElement("div");
    r.classList.add(yo("w")), this.labelElement.appendChild(r);
    const o = sa(e, "check");
    r.appendChild(o), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
}
class yy {
  constructor(e, t) {
    this.onInputChange_ = this.onInputChange_.bind(this), this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new wy(e, { value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.labelElement.addEventListener("mousedown", this.onLabelMouseDown_);
  }
  onInputChange_(e) {
    const t = e.currentTarget;
    this.value.rawValue = t.checked, e.preventDefault(), e.stopPropagation();
  }
  onLabelMouseDown_(e) {
    e.preventDefault();
  }
}
function Sy(s) {
  const e = [], t = Vc(s.options);
  return t && e.push(t), new Dr(e);
}
const Ey = Gt({ id: "input-bool", type: "input", accept: (s, e) => {
  if (typeof s != "boolean") return null;
  const t = vt(e, (i) => ({ options: i.optional.custom(Ir), readonly: i.optional.constant(false) }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => Mp, constraint: (s) => Sy(s.params), writer: (s) => kr }, controller: (s) => {
  const e = s.document, t = s.value, i = s.constraint, n = i && qo(i, Lr);
  return n ? new mn(e, { props: new $e({ options: n.values.value("options") }), value: t, viewProps: s.viewProps }) : new yy(e, { value: t, viewProps: s.viewProps });
}, api(s) {
  return typeof s.controller.value.rawValue != "boolean" ? null : s.controller.valueController instanceof mn ? new zc(s.controller) : null;
} }), Mn = Ze("col");
class My {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Mn()), t.foldable.bindExpandedClass(this.element, Mn(void 0, "expanded")), Si(t.foldable, "completed", Us(this.element, Mn(void 0, "cpl")));
    const i = e.createElement("div");
    i.classList.add(Mn("h")), this.element.appendChild(i);
    const n = e.createElement("div");
    n.classList.add(Mn("s")), i.appendChild(n), this.swatchElement = n;
    const r = e.createElement("div");
    if (r.classList.add(Mn("t")), i.appendChild(r), this.textElement = r, t.pickerLayout === "inline") {
      const o = e.createElement("div");
      o.classList.add(Mn("p")), this.element.appendChild(o), this.pickerElement = o;
    } else this.pickerElement = null;
  }
}
function Cy(s, e, t) {
  const i = Tt(s / 255, 0, 1), n = Tt(e / 255, 0, 1), r = Tt(t / 255, 0, 1), o = Math.max(i, n, r), a = Math.min(i, n, r), l = o - a;
  let c = 0, h = 0;
  const d = (a + o) / 2;
  return l !== 0 && (h = l / (1 - Math.abs(o + a - 1)), i === o ? c = (n - r) / l : n === o ? c = 2 + (r - i) / l : c = 4 + (i - n) / l, c = c / 6 + (c < 0 ? 1 : 0)), [c * 360, h * 100, d * 100];
}
function Ty(s, e, t) {
  const i = (s % 360 + 360) % 360, n = Tt(e / 100, 0, 1), r = Tt(t / 100, 0, 1), o = (1 - Math.abs(2 * r - 1)) * n, a = o * (1 - Math.abs(i / 60 % 2 - 1)), l = r - o / 2;
  let c, h, d;
  return i >= 0 && i < 60 ? [c, h, d] = [o, a, 0] : i >= 60 && i < 120 ? [c, h, d] = [a, o, 0] : i >= 120 && i < 180 ? [c, h, d] = [0, o, a] : i >= 180 && i < 240 ? [c, h, d] = [0, a, o] : i >= 240 && i < 300 ? [c, h, d] = [a, 0, o] : [c, h, d] = [o, 0, a], [(c + l) * 255, (h + l) * 255, (d + l) * 255];
}
function Ay(s, e, t) {
  const i = Tt(s / 255, 0, 1), n = Tt(e / 255, 0, 1), r = Tt(t / 255, 0, 1), o = Math.max(i, n, r), a = Math.min(i, n, r), l = o - a;
  let c;
  l === 0 ? c = 0 : o === i ? c = 60 * (((n - r) / l % 6 + 6) % 6) : o === n ? c = 60 * ((r - i) / l + 2) : c = 60 * ((i - n) / l + 4);
  const h = o === 0 ? 0 : l / o, d = o;
  return [c, h * 100, d * 100];
}
function Dp(s, e, t) {
  const i = rp(s, 360), n = Tt(e / 100, 0, 1), r = Tt(t / 100, 0, 1), o = r * n, a = o * (1 - Math.abs(i / 60 % 2 - 1)), l = r - o;
  let c, h, d;
  return i >= 0 && i < 60 ? [c, h, d] = [o, a, 0] : i >= 60 && i < 120 ? [c, h, d] = [a, o, 0] : i >= 120 && i < 180 ? [c, h, d] = [0, o, a] : i >= 180 && i < 240 ? [c, h, d] = [0, a, o] : i >= 240 && i < 300 ? [c, h, d] = [a, 0, o] : [c, h, d] = [o, 0, a], [(c + l) * 255, (h + l) * 255, (d + l) * 255];
}
function Py(s, e, t) {
  const i = t + e * (100 - Math.abs(2 * t - 100)) / 200;
  return [s, i !== 0 ? e * (100 - Math.abs(2 * t - 100)) / i : 0, t + e * (100 - Math.abs(2 * t - 100)) / (2 * 100)];
}
function Ry(s, e, t) {
  const i = 100 - Math.abs(t * (200 - e) / 100 - 100);
  return [s, i !== 0 ? e * t / i : 0, t * (200 - e) / (2 * 100)];
}
function Ei(s) {
  return [s[0], s[1], s[2]];
}
function oa(s, e) {
  return [s[0], s[1], s[2], e];
}
const Dy = { hsl: { hsl: (s, e, t) => [s, e, t], hsv: Py, rgb: Ty }, hsv: { hsl: Ry, hsv: (s, e, t) => [s, e, t], rgb: Dp }, rgb: { hsl: Cy, hsv: Ay, rgb: (s, e, t) => [s, e, t] } };
function Is(s, e) {
  return [e === "float" ? 1 : s === "rgb" ? 255 : 360, e === "float" ? 1 : s === "rgb" ? 255 : 100, e === "float" ? 1 : s === "rgb" ? 255 : 100];
}
function Ly(s, e) {
  return s === e ? e : rp(s, e);
}
function Lp(s, e, t) {
  var i;
  const n = Is(e, t);
  return [e === "rgb" ? Tt(s[0], 0, n[0]) : Ly(s[0], n[0]), Tt(s[1], 0, n[1]), Tt(s[2], 0, n[2]), Tt((i = s[3]) !== null && i !== void 0 ? i : 1, 0, 1)];
}
function Bd(s, e, t, i) {
  const n = Is(e, t), r = Is(e, i);
  return s.map((o, a) => o / n[a] * r[a]);
}
function Ip(s, e, t) {
  const i = Bd(s, e.mode, e.type, "int"), n = Dy[e.mode][t.mode](...i);
  return Bd(n, t.mode, "int", t.type);
}
class Je {
  static black() {
    return new Je([0, 0, 0], "rgb");
  }
  constructor(e, t) {
    this.type = "int", this.mode = t, this.comps_ = Lp(e, t, this.type);
  }
  getComponents(e) {
    return oa(Ip(Ei(this.comps_), { mode: this.mode, type: this.type }, { mode: e ?? this.mode, type: this.type }), this.comps_[3]);
  }
  toRgbaObject() {
    const e = this.getComponents("rgb");
    return { r: e[0], g: e[1], b: e[2], a: e[3] };
  }
}
const Zi = Ze("colp");
class Iy {
  constructor(e, t) {
    this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(Zi()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(Zi("hsv"));
    const n = e.createElement("div");
    n.classList.add(Zi("sv")), this.svPaletteView_ = t.svPaletteView, n.appendChild(this.svPaletteView_.element), i.appendChild(n);
    const r = e.createElement("div");
    r.classList.add(Zi("h")), this.hPaletteView_ = t.hPaletteView, r.appendChild(this.hPaletteView_.element), i.appendChild(r), this.element.appendChild(i);
    const o = e.createElement("div");
    if (o.classList.add(Zi("rgb")), this.textsView_ = t.textsView, o.appendChild(this.textsView_.element), this.element.appendChild(o), t.alphaViews) {
      this.alphaViews_ = { palette: t.alphaViews.palette, text: t.alphaViews.text };
      const a = e.createElement("div");
      a.classList.add(Zi("a"));
      const l = e.createElement("div");
      l.classList.add(Zi("ap")), l.appendChild(this.alphaViews_.palette.element), a.appendChild(l);
      const c = e.createElement("div");
      c.classList.add(Zi("at")), c.appendChild(this.alphaViews_.text.element), a.appendChild(c), this.element.appendChild(a);
    }
  }
  get allFocusableElements() {
    const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textsView_.modeSelectElement, ...this.textsView_.inputViews.map((t) => t.inputElement)];
    return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e;
  }
}
function Ny(s) {
  return s === "int" ? "int" : s === "float" ? "float" : void 0;
}
function Hc(s) {
  return vt(s, (e) => ({ color: e.optional.object({ alpha: e.optional.boolean, type: e.optional.custom(Ny) }), expanded: e.optional.boolean, picker: e.optional.custom(Rp), readonly: e.optional.constant(false) }));
}
function Vn(s) {
  return s ? 0.1 : 1;
}
function Np(s) {
  var e;
  return (e = s.color) === null || e === void 0 ? void 0 : e.type;
}
class Gc {
  constructor(e, t) {
    this.type = "float", this.mode = t, this.comps_ = Lp(e, t, this.type);
  }
  getComponents(e) {
    return oa(Ip(Ei(this.comps_), { mode: this.mode, type: this.type }, { mode: e ?? this.mode, type: this.type }), this.comps_[3]);
  }
  toRgbaObject() {
    const e = this.getComponents("rgb");
    return { r: e[0], g: e[1], b: e[2], a: e[3] };
  }
}
const ky = { int: (s, e) => new Je(s, e), float: (s, e) => new Gc(s, e) };
function $c(s, e, t) {
  return ky[t](s, e);
}
function Oy(s) {
  return s.type === "float";
}
function Uy(s) {
  return s.type === "int";
}
function Fy(s) {
  const e = s.getComponents(), t = Is(s.mode, "int");
  return new Je([Math.round(nt(e[0], 0, 1, 0, t[0])), Math.round(nt(e[1], 0, 1, 0, t[1])), Math.round(nt(e[2], 0, 1, 0, t[2])), e[3]], s.mode);
}
function zy(s) {
  const e = s.getComponents(), t = Is(s.mode, "int");
  return new Gc([nt(e[0], 0, t[0], 0, 1), nt(e[1], 0, t[1], 0, 1), nt(e[2], 0, t[2], 0, 1), e[3]], s.mode);
}
function Ht(s, e) {
  if (s.type === e) return s;
  if (Uy(s) && e === "float") return zy(s);
  if (Oy(s) && e === "int") return Fy(s);
  throw bt.shouldNeverHappen();
}
function By(s, e) {
  return s.alpha === e.alpha && s.mode === e.mode && s.notation === e.notation && s.type === e.type;
}
function hi(s, e) {
  const t = s.match(/^(.+)%$/);
  return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(s), e);
}
const Vy = { deg: (s) => s, grad: (s) => s * 360 / 400, rad: (s) => s * 360 / (2 * Math.PI), turn: (s) => s * 360 };
function kp(s) {
  const e = s.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!e) return parseFloat(s);
  const t = parseFloat(e[1]), i = e[2];
  return Vy[i](t);
}
function Op(s) {
  const e = s.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e) return null;
  const t = [hi(e[1], 255), hi(e[2], 255), hi(e[3], 255)];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function Hy(s) {
  const e = Op(s);
  return e ? new Je(e, "rgb") : null;
}
function Up(s) {
  const e = s.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e) return null;
  const t = [hi(e[1], 255), hi(e[2], 255), hi(e[3], 255), hi(e[4], 1)];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function Gy(s) {
  const e = Up(s);
  return e ? new Je(e, "rgb") : null;
}
function Fp(s) {
  const e = s.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e) return null;
  const t = [kp(e[1]), hi(e[2], 100), hi(e[3], 100)];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function $y(s) {
  const e = Fp(s);
  return e ? new Je(e, "hsl") : null;
}
function zp(s) {
  const e = s.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!e) return null;
  const t = [kp(e[1]), hi(e[2], 100), hi(e[3], 100), hi(e[4], 1)];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function Wy(s) {
  const e = zp(s);
  return e ? new Je(e, "hsl") : null;
}
function Bp(s) {
  const e = s.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)];
  const t = s.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
  return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : null;
}
function Xy(s) {
  const e = Bp(s);
  return e ? new Je(e, "rgb") : null;
}
function Vp(s) {
  const e = s.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16), nt(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)];
  const t = s.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
  return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16), nt(parseInt(t[4], 16), 0, 255, 0, 1)] : null;
}
function jy(s) {
  const e = Vp(s);
  return e ? new Je(e, "rgb") : null;
}
function Hp(s) {
  const e = s.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
  if (!e) return null;
  const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function Yy(s) {
  return (e) => {
    const t = Hp(e);
    return t ? $c(t, "rgb", s) : null;
  };
}
function Gp(s) {
  const e = s.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
  if (!e) return null;
  const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]), parseFloat(e[4])];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function qy(s) {
  return (e) => {
    const t = Gp(e);
    return t ? $c(t, "rgb", s) : null;
  };
}
const Ky = [{ parser: Bp, result: { alpha: false, mode: "rgb", notation: "hex" } }, { parser: Vp, result: { alpha: true, mode: "rgb", notation: "hex" } }, { parser: Op, result: { alpha: false, mode: "rgb", notation: "func" } }, { parser: Up, result: { alpha: true, mode: "rgb", notation: "func" } }, { parser: Fp, result: { alpha: false, mode: "hsl", notation: "func" } }, { parser: zp, result: { alpha: true, mode: "hsl", notation: "func" } }, { parser: Hp, result: { alpha: false, mode: "rgb", notation: "object" } }, { parser: Gp, result: { alpha: true, mode: "rgb", notation: "object" } }];
function Zy(s) {
  return Ky.reduce((e, { parser: t, result: i }) => e || (t(s) ? i : null), null);
}
function Jy(s, e = "int") {
  const t = Zy(s);
  return t ? t.notation === "hex" && e !== "float" ? Object.assign(Object.assign({}, t), { type: "int" }) : t.notation === "func" ? Object.assign(Object.assign({}, t), { type: e }) : null : null;
}
function Or(s) {
  const e = [Xy, jy, Hy, Gy, $y, Wy];
  e.push(Yy("int"), qy("int"));
  const t = uy(e);
  return (i) => {
    const n = t(i);
    return n ? Ht(n, s) : null;
  };
}
function Qy(s) {
  const e = Or("int");
  if (typeof s != "string") return Je.black();
  const t = e(s);
  return t ?? Je.black();
}
function $p(s) {
  const e = Tt(Math.floor(s), 0, 255).toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function Wc(s, e = "#") {
  const t = Ei(s.getComponents("rgb")).map($p).join("");
  return `${e}${t}`;
}
function Xc(s, e = "#") {
  const t = s.getComponents("rgb"), i = [t[0], t[1], t[2], t[3] * 255].map($p).join("");
  return `${e}${i}`;
}
function Wp(s) {
  const e = Zt(0), t = Ht(s, "int");
  return `rgb(${Ei(t.getComponents("rgb")).map((n) => e(n)).join(", ")})`;
}
function Io(s) {
  const e = Zt(2), t = Zt(0);
  return `rgba(${Ht(s, "int").getComponents("rgb").map((r, o) => (o === 3 ? e : t)(r)).join(", ")})`;
}
function eS(s) {
  const e = [Zt(0), Ko, Ko], t = Ht(s, "int");
  return `hsl(${Ei(t.getComponents("hsl")).map((n, r) => e[r](n)).join(", ")})`;
}
function tS(s) {
  const e = [Zt(0), Ko, Ko, Zt(2)];
  return `hsla(${Ht(s, "int").getComponents("hsl").map((n, r) => e[r](n)).join(", ")})`;
}
function Xp(s, e) {
  const t = Zt(e === "float" ? 2 : 0), i = ["r", "g", "b"], n = Ht(s, e);
  return `{${Ei(n.getComponents("rgb")).map((o, a) => `${i[a]}: ${t(o)}`).join(", ")}}`;
}
function iS(s) {
  return (e) => Xp(e, s);
}
function jp(s, e) {
  const t = Zt(2), i = Zt(e === "float" ? 2 : 0), n = ["r", "g", "b", "a"];
  return `{${Ht(s, e).getComponents("rgb").map((a, l) => {
    const c = l === 3 ? t : i;
    return `${n[l]}: ${c(a)}`;
  }).join(", ")}}`;
}
function nS(s) {
  return (e) => jp(e, s);
}
const sS = [{ format: { alpha: false, mode: "rgb", notation: "hex", type: "int" }, stringifier: Wc }, { format: { alpha: true, mode: "rgb", notation: "hex", type: "int" }, stringifier: Xc }, { format: { alpha: false, mode: "rgb", notation: "func", type: "int" }, stringifier: Wp }, { format: { alpha: true, mode: "rgb", notation: "func", type: "int" }, stringifier: Io }, { format: { alpha: false, mode: "hsl", notation: "func", type: "int" }, stringifier: eS }, { format: { alpha: true, mode: "hsl", notation: "func", type: "int" }, stringifier: tS }, ...["int", "float"].reduce((s, e) => [...s, { format: { alpha: false, mode: "rgb", notation: "object", type: e }, stringifier: iS(e) }, { format: { alpha: true, mode: "rgb", notation: "object", type: e }, stringifier: nS(e) }], [])];
function Yp(s) {
  return sS.reduce((e, t) => e || (By(t.format, s) ? t.stringifier : null), null);
}
const Qs = Ze("apl");
class rS {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Qs()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
    const i = e.createElement("div");
    i.classList.add(Qs("b")), this.element.appendChild(i);
    const n = e.createElement("div");
    n.classList.add(Qs("c")), i.appendChild(n), this.colorElem_ = n;
    const r = e.createElement("div");
    r.classList.add(Qs("m")), this.element.appendChild(r), this.markerElem_ = r;
    const o = e.createElement("div");
    o.classList.add(Qs("p")), this.markerElem_.appendChild(o), this.previewElem_ = o, this.update_();
  }
  update_() {
    const e = this.value.rawValue, t = e.getComponents("rgb"), i = new Je([t[0], t[1], t[2], 0], "rgb"), n = new Je([t[0], t[1], t[2], 255], "rgb"), r = ["to right", Io(i), Io(n)];
    this.colorElem_.style.background = `linear-gradient(${r.join(",")})`, this.previewElem_.style.backgroundColor = Io(e);
    const o = nt(t[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${o}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class oS {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new rS(e, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Wn(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point) return;
    const i = e.point.x / e.bounds.width, n = this.value.rawValue, [r, o, a] = n.getComponents("hsv");
    this.value.setRawValue(new Je([r, o, a, i], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: true, last: true });
  }
  onKeyDown_(e) {
    const t = qt(Vn(true), Hi(e));
    if (t === 0) return;
    const i = this.value.rawValue, [n, r, o, a] = i.getComponents("hsv");
    this.value.setRawValue(new Je([n, r, o, a + t], "hsv"), { forceEmit: false, last: false });
  }
  onKeyUp_(e) {
    qt(Vn(true), Hi(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
  }
}
const us = Ze("coltxt");
function aS(s) {
  const e = s.createElement("select"), t = [{ text: "RGB", value: "rgb" }, { text: "HSL", value: "hsl" }, { text: "HSV", value: "hsv" }, { text: "HEX", value: "hex" }];
  return e.appendChild(t.reduce((i, n) => {
    const r = s.createElement("option");
    return r.textContent = n.text, r.value = n.value, i.appendChild(r), i;
  }, s.createDocumentFragment())), e;
}
class lS {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(us()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(us("m")), this.modeElem_ = aS(e), this.modeElem_.classList.add(us("ms")), i.appendChild(this.modeSelectElement), t.viewProps.bindDisabled(this.modeElem_);
    const n = e.createElement("div");
    n.classList.add(us("mm")), n.appendChild(sa(e, "dropdown")), i.appendChild(n), this.element.appendChild(i);
    const r = e.createElement("div");
    r.classList.add(us("w")), this.element.appendChild(r), this.inputsElem_ = r, this.inputViews_ = t.inputViews, this.applyInputViews_(), zi(t.mode, (o) => {
      this.modeElem_.value = o;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(e) {
    this.inputViews_ = e, this.applyInputViews_();
  }
  applyInputViews_() {
    fp(this.inputsElem_);
    const e = this.element.ownerDocument;
    this.inputViews_.forEach((t) => {
      const i = e.createElement("div");
      i.classList.add(us("c")), i.appendChild(t.element), this.inputsElem_.appendChild(i);
    });
  }
}
function cS(s) {
  return Zt(s === "float" ? 2 : 0);
}
function hS(s, e, t) {
  const i = Is(s, e)[t];
  return new Ar({ min: 0, max: i });
}
function dS(s, e, t) {
  return new Nr(s, { arrayPosition: t === 0 ? "fst" : t === 2 ? "lst" : "mid", parser: e.parser, props: $e.fromObject({ formatter: cS(e.colorType), keyScale: Vn(false), pointerScale: e.colorType === "float" ? 0.01 : 1 }), value: mt(0, { constraint: hS(e.colorMode, e.colorType, t) }), viewProps: e.viewProps });
}
function uS(s, e) {
  const t = { colorMode: e.colorMode, colorType: e.colorType, parser: Vi, viewProps: e.viewProps };
  return [0, 1, 2].map((i) => {
    const n = dS(s, t, i);
    return Bs({ primary: e.value, secondary: n.value, forward(r) {
      return Ht(r, e.colorType).getComponents(e.colorMode)[i];
    }, backward(r, o) {
      const a = e.colorMode, c = Ht(r, e.colorType).getComponents(a);
      c[i] = o;
      const h = $c(oa(Ei(c), c[3]), a, e.colorType);
      return Ht(h, "int");
    } }), n;
  });
}
function pS(s, e) {
  const t = new gr(s, { parser: Or("int"), props: $e.fromObject({ formatter: Wc }), value: mt(Je.black()), viewProps: e.viewProps });
  return Bs({ primary: e.value, secondary: t.value, forward: (i) => new Je(Ei(i.getComponents()), i.mode), backward: (i, n) => new Je(oa(Ei(n.getComponents(i.mode)), i.getComponents()[3]), i.mode) }), [t];
}
function fS(s) {
  return s !== "hex";
}
class mS {
  constructor(e, t) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t.colorType, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = mt(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new lS(e, { mode: this.colorMode, inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view], viewProps: this.viewProps }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
  }
  createComponentControllers_(e) {
    const t = this.colorMode.rawValue;
    return fS(t) ? uS(e, { colorMode: t, colorType: this.colorType_, value: this.value, viewProps: this.viewProps }) : pS(e, { value: this.value, viewProps: this.viewProps });
  }
  onModeSelectChange_(e) {
    const t = e.currentTarget;
    this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.inputViews = this.ccs_.map((i) => i.view);
  }
}
const tl = Ze("hpl");
class gS {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(tl()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
    const i = e.createElement("div");
    i.classList.add(tl("c")), this.element.appendChild(i);
    const n = e.createElement("div");
    n.classList.add(tl("m")), this.element.appendChild(n), this.markerElem_ = n, this.update_();
  }
  update_() {
    const e = this.value.rawValue, [t] = e.getComponents("hsv");
    this.markerElem_.style.backgroundColor = Wp(new Je([t, 100, 100], "hsv"));
    const i = nt(t, 0, 360, 0, 100);
    this.markerElem_.style.left = `${i}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class vS {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new gS(e, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Wn(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point) return;
    const i = nt(Tt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 360), n = this.value.rawValue, [, r, o, a] = n.getComponents("hsv");
    this.value.setRawValue(new Je([i, r, o, a], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: true, last: true });
  }
  onKeyDown_(e) {
    const t = qt(Vn(false), Hi(e));
    if (t === 0) return;
    const i = this.value.rawValue, [n, r, o, a] = i.getComponents("hsv");
    this.value.setRawValue(new Je([n + t, r, o, a], "hsv"), { forceEmit: false, last: false });
  }
  onKeyUp_(e) {
    qt(Vn(false), Hi(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
  }
}
const il = Ze("svp"), Vd = 64;
class _S {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(il()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
    const i = e.createElement("canvas");
    i.height = Vd, i.width = Vd, i.classList.add(il("c")), this.element.appendChild(i), this.canvasElement = i;
    const n = e.createElement("div");
    n.classList.add(il("m")), this.element.appendChild(n), this.markerElem_ = n, this.update_();
  }
  update_() {
    const e = vw(this.canvasElement);
    if (!e) return;
    const i = this.value.rawValue.getComponents("hsv"), n = this.canvasElement.width, r = this.canvasElement.height, o = e.getImageData(0, 0, n, r), a = o.data;
    for (let h = 0; h < r; h++) for (let d = 0; d < n; d++) {
      const u = nt(d, 0, n, 0, 100), f = nt(h, 0, r, 100, 0), m = Dp(i[0], u, f), _ = (h * n + d) * 4;
      a[_] = m[0], a[_ + 1] = m[1], a[_ + 2] = m[2], a[_ + 3] = 255;
    }
    e.putImageData(o, 0, 0);
    const l = nt(i[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${l}%`;
    const c = nt(i[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${c}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class bS {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new _S(e, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Wn(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point) return;
    const i = nt(e.point.x, 0, e.bounds.width, 0, 100), n = nt(e.point.y, 0, e.bounds.height, 100, 0), [r, , , o] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(new Je([r, i, n, o], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: true, last: true });
  }
  onKeyDown_(e) {
    Tp(e.key) && e.preventDefault();
    const [t, i, n, r] = this.value.rawValue.getComponents("hsv"), o = Vn(false), a = qt(o, Hi(e)), l = qt(o, vr(e));
    a === 0 && l === 0 || this.value.setRawValue(new Je([t, i + a, n + l, r], "hsv"), { forceEmit: false, last: false });
  }
  onKeyUp_(e) {
    const t = Vn(false), i = qt(t, Hi(e)), n = qt(t, vr(e));
    i === 0 && n === 0 || this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
  }
}
class xS {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new vS(e, { value: this.value, viewProps: this.viewProps }), this.svPaletteC_ = new bS(e, { value: this.value, viewProps: this.viewProps }), this.alphaIcs_ = t.supportsAlpha ? { palette: new oS(e, { value: this.value, viewProps: this.viewProps }), text: new Nr(e, { parser: Vi, props: $e.fromObject({ pointerScale: 0.01, keyScale: 0.1, formatter: Zt(2) }), value: mt(0, { constraint: new Ar({ min: 0, max: 1 }) }), viewProps: this.viewProps }) } : null, this.alphaIcs_ && Bs({ primary: this.value, secondary: this.alphaIcs_.text.value, forward: (i) => i.getComponents()[3], backward: (i, n) => {
      const r = i.getComponents();
      return r[3] = n, new Je(r, i.mode);
    } }), this.textsC_ = new mS(e, { colorType: t.colorType, value: this.value, viewProps: this.viewProps }), this.view = new Iy(e, { alphaViews: this.alphaIcs_ ? { palette: this.alphaIcs_.palette.view, text: this.alphaIcs_.text.view } : null, hPaletteView: this.hPaletteC_.view, supportsAlpha: t.supportsAlpha, svPaletteView: this.svPaletteC_.view, textsView: this.textsC_.view, viewProps: this.viewProps });
  }
  get textsController() {
    return this.textsC_;
  }
}
const nl = Ze("colsw");
class wS {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(nl()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(nl("sw")), this.element.appendChild(i), this.swatchElem_ = i;
    const n = e.createElement("button");
    n.classList.add(nl("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n, this.update_();
  }
  update_() {
    const e = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = Xc(e);
  }
  onValueChange_() {
    this.update_();
  }
}
class yS {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new wS(e, { value: this.value, viewProps: this.viewProps });
  }
}
class jc {
  constructor(e, t) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Rr.create(t.expanded), this.swatchC_ = new yS(e, { value: this.value, viewProps: this.viewProps });
    const i = this.swatchC_.view.buttonElement;
    i.addEventListener("blur", this.onButtonBlur_), i.addEventListener("click", this.onButtonClick_), this.textC_ = new gr(e, { parser: t.parser, props: $e.fromObject({ formatter: t.formatter }), value: this.value, viewProps: this.viewProps }), this.view = new My(e, { foldable: this.foldable_, pickerLayout: t.pickerLayout }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = t.pickerLayout === "popup" ? new Ep(e, { viewProps: this.viewProps }) : null;
    const n = new xS(e, { colorType: t.colorType, supportsAlpha: t.supportsAlpha, value: this.value, viewProps: this.viewProps });
    n.view.allFocusableElements.forEach((r) => {
      r.addEventListener("blur", this.onPopupChildBlur_), r.addEventListener("keydown", this.onPopupChildKeydown_);
    }), this.pickerC_ = n, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(n.view.element), Bs({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (r) => r, backward: (r, o) => o })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Fc(this.foldable_, this.view.pickerElement));
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) return;
    const t = this.view.element, i = e.relatedTarget;
    (!i || !t.contains(i)) && (this.popC_.shows.rawValue = false);
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
  }
  onPopupChildBlur_(e) {
    if (!this.popC_) return;
    const t = this.popC_.view.element, i = mp(e);
    i && t.contains(i) || i && i === this.swatchC_.view.buttonElement && !Lc(t.ownerDocument) || (this.popC_.shows.rawValue = false);
  }
  onPopupChildKeydown_(e) {
    this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = false) : this.view.pickerElement && e.key === "Escape" && this.swatchC_.view.buttonElement.focus();
  }
}
function SS(s) {
  return Ei(s.getComponents("rgb")).reduce((e, t) => e << 8 | Math.floor(t) & 255, 0);
}
function ES(s) {
  return s.getComponents("rgb").reduce((e, t, i) => {
    const n = Math.floor(i === 3 ? t * 255 : t) & 255;
    return e << 8 | n;
  }, 0) >>> 0;
}
function MS(s) {
  return new Je([s >> 16 & 255, s >> 8 & 255, s & 255], "rgb");
}
function CS(s) {
  return new Je([s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, nt(s & 255, 0, 255, 0, 1)], "rgb");
}
function TS(s) {
  return typeof s != "number" ? Je.black() : MS(s);
}
function AS(s) {
  return typeof s != "number" ? Je.black() : CS(s);
}
function No(s, e) {
  return typeof s != "object" || ht(s) ? false : e in s && typeof s[e] == "number";
}
function qp(s) {
  return No(s, "r") && No(s, "g") && No(s, "b");
}
function Kp(s) {
  return qp(s) && No(s, "a");
}
function Zp(s) {
  return qp(s);
}
function Yc(s, e) {
  if (s.mode !== e.mode || s.type !== e.type) return false;
  const t = s.getComponents(), i = e.getComponents();
  for (let n = 0; n < t.length; n++) if (t[n] !== i[n]) return false;
  return true;
}
function Hd(s) {
  return "a" in s ? [s.r, s.g, s.b, s.a] : [s.r, s.g, s.b];
}
function PS(s) {
  const e = Yp(s);
  return e ? (t, i) => {
    kr(t, e(i));
  } : null;
}
function RS(s) {
  const e = s ? ES : SS;
  return (t, i) => {
    kr(t, e(i));
  };
}
function DS(s, e, t) {
  const n = Ht(e, t).toRgbaObject();
  s.writeProperty("r", n.r), s.writeProperty("g", n.g), s.writeProperty("b", n.b), s.writeProperty("a", n.a);
}
function LS(s, e, t) {
  const n = Ht(e, t).toRgbaObject();
  s.writeProperty("r", n.r), s.writeProperty("g", n.g), s.writeProperty("b", n.b);
}
function IS(s, e) {
  return (t, i) => {
    s ? DS(t, i, e) : LS(t, i, e);
  };
}
function NS(s) {
  var e;
  return !!(!((e = s == null ? void 0 : s.color) === null || e === void 0) && e.alpha);
}
function kS(s) {
  return s ? (e) => Xc(e, "0x") : (e) => Wc(e, "0x");
}
function OS(s) {
  return "color" in s || s.view === "color";
}
const US = Gt({ id: "input-color-number", type: "input", accept: (s, e) => {
  if (typeof s != "number" || !OS(e)) return null;
  const t = Hc(e);
  return t ? { initialValue: s, params: Object.assign(Object.assign({}, t), { supportsAlpha: NS(e) }) } : null;
}, binding: { reader: (s) => s.params.supportsAlpha ? AS : TS, equals: Yc, writer: (s) => RS(s.params.supportsAlpha) }, controller: (s) => {
  var e, t;
  return new jc(s.document, { colorType: "int", expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : false, formatter: kS(s.params.supportsAlpha), parser: Or("int"), pickerLayout: (t = s.params.picker) !== null && t !== void 0 ? t : "popup", supportsAlpha: s.params.supportsAlpha, value: s.value, viewProps: s.viewProps });
} });
function FS(s, e) {
  if (!Zp(s)) return Ht(Je.black(), e);
  if (e === "int") {
    const t = Hd(s);
    return new Je(t, "rgb");
  }
  if (e === "float") {
    const t = Hd(s);
    return new Gc(t, "rgb");
  }
  return Ht(Je.black(), "int");
}
function zS(s) {
  return Kp(s);
}
function BS(s) {
  return (e) => {
    const t = FS(e, s);
    return Ht(t, "int");
  };
}
function VS(s, e) {
  return (t) => s ? jp(t, e) : Xp(t, e);
}
const HS = Gt({ id: "input-color-object", type: "input", accept: (s, e) => {
  var t;
  if (!Zp(s)) return null;
  const i = Hc(e);
  return i ? { initialValue: s, params: Object.assign(Object.assign({}, i), { colorType: (t = Np(e)) !== null && t !== void 0 ? t : "int" }) } : null;
}, binding: { reader: (s) => BS(s.params.colorType), equals: Yc, writer: (s) => IS(zS(s.initialValue), s.params.colorType) }, controller: (s) => {
  var e, t;
  const i = Kp(s.initialValue);
  return new jc(s.document, { colorType: s.params.colorType, expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : false, formatter: VS(i, s.params.colorType), parser: Or("int"), pickerLayout: (t = s.params.picker) !== null && t !== void 0 ? t : "popup", supportsAlpha: i, value: s.value, viewProps: s.viewProps });
} }), GS = Gt({ id: "input-color-string", type: "input", accept: (s, e) => {
  if (typeof s != "string" || e.view === "text") return null;
  const t = Jy(s, Np(e));
  if (!t) return null;
  const i = Yp(t);
  if (!i) return null;
  const n = Hc(e);
  return n ? { initialValue: s, params: Object.assign(Object.assign({}, n), { format: t, stringifier: i }) } : null;
}, binding: { reader: () => Qy, equals: Yc, writer: (s) => {
  const e = PS(s.params.format);
  if (!e) throw bt.notBindable();
  return e;
} }, controller: (s) => {
  var e, t;
  return new jc(s.document, { colorType: s.params.format.type, expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : false, formatter: s.params.stringifier, parser: Or("int"), pickerLayout: (t = s.params.picker) !== null && t !== void 0 ? t : "popup", supportsAlpha: s.params.format.alpha, value: s.value, viewProps: s.viewProps });
} });
class qc {
  constructor(e) {
    this.components = e.components, this.asm_ = e.assembly;
  }
  constrain(e) {
    const t = this.asm_.toComponents(e).map((i, n) => {
      var r, o;
      return (o = (r = this.components[n]) === null || r === void 0 ? void 0 : r.constrain(i)) !== null && o !== void 0 ? o : i;
    });
    return this.asm_.fromComponents(t);
  }
}
const Gd = Ze("pndtxt");
class $S {
  constructor(e, t) {
    this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(Gd()), this.textViews.forEach((i) => {
      const n = e.createElement("div");
      n.classList.add(Gd("a")), n.appendChild(i.element), this.element.appendChild(n);
    });
  }
}
function WS(s, e, t) {
  return new Nr(s, { arrayPosition: t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid", parser: e.parser, props: e.axes[t].textProps, value: mt(0, { constraint: e.axes[t].constraint }), viewProps: e.viewProps });
}
class Kc {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map((i, n) => WS(e, t, n)), this.acs_.forEach((i, n) => {
      Bs({ primary: this.value, secondary: i.value, forward: (r) => t.assembly.toComponents(r)[n], backward: (r, o) => {
        const a = t.assembly.toComponents(r);
        return a[n] = o, t.assembly.fromComponents(a);
      } });
    }), this.view = new $S(e, { textViews: this.acs_.map((i) => i.view) });
  }
  get textControllers() {
    return this.acs_;
  }
}
class XS extends mr {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(e) {
    this.controller.valueController.sliderController.props.set("max", e);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(e) {
    this.controller.valueController.sliderController.props.set("min", e);
  }
}
function jS(s, e) {
  const t = [], i = lp(s, e);
  i && t.push(i);
  const n = cp(s);
  n && t.push(n);
  const r = Vc(s.options);
  return r && t.push(r), new Dr(t);
}
const YS = Gt({ id: "input-number", type: "input", accept: (s, e) => {
  if (typeof s != "number") return null;
  const t = vt(e, (i) => Object.assign(Object.assign({}, dp(i)), { options: i.optional.custom(Ir), readonly: i.optional.constant(false) }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => sp, constraint: (s) => jS(s.params, s.initialValue), writer: (s) => kr }, controller: (s) => {
  const e = s.value, t = s.constraint, i = t && qo(t, Lr);
  if (i) return new mn(s.document, { props: new $e({ options: i.values.value("options") }), value: e, viewProps: s.viewProps });
  const n = hp(s.params, e.rawValue), r = t && qo(t, Ar);
  return r ? new Zo(s.document, Object.assign(Object.assign({}, Ap(Object.assign(Object.assign({}, n), { keyScale: mt(n.keyScale), max: r.values.value("max"), min: r.values.value("min") }))), { parser: Vi, value: e, viewProps: s.viewProps })) : new Nr(s.document, { parser: Vi, props: $e.fromObject(n), value: e, viewProps: s.viewProps });
}, api(s) {
  return typeof s.controller.value.rawValue != "number" ? null : s.controller.valueController instanceof Zo ? new XS(s.controller) : s.controller.valueController instanceof mn ? new zc(s.controller) : null;
} });
class hn {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(e) {
    if (ht(e)) return false;
    const t = e.x, i = e.y;
    return !(typeof t != "number" || typeof i != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y;
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
}
const Jp = { toComponents: (s) => s.getComponents(), fromComponents: (s) => new hn(...s) }, ps = Ze("p2d");
class qS {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(ps()), t.viewProps.bindClassModifiers(this.element), zi(t.expanded, Us(this.element, ps(void 0, "expanded")));
    const i = e.createElement("div");
    i.classList.add(ps("h")), this.element.appendChild(i);
    const n = e.createElement("button");
    n.classList.add(ps("b")), n.appendChild(sa(e, "p2dpad")), t.viewProps.bindDisabled(n), i.appendChild(n), this.buttonElement = n;
    const r = e.createElement("div");
    if (r.classList.add(ps("t")), i.appendChild(r), this.textElement = r, t.pickerLayout === "inline") {
      const o = e.createElement("div");
      o.classList.add(ps("p")), this.element.appendChild(o), this.pickerElement = o;
    } else this.pickerElement = null;
  }
}
const Ji = Ze("p2dp");
class KS {
  constructor(e, t) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onPropsChange_ = this.onPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onPropsChange_), this.element = e.createElement("div"), this.element.classList.add(Ji()), t.layout === "popup" && this.element.classList.add(Ji(void 0, "p")), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(Ji("p")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.padElement = i;
    const n = e.createElementNS(yi, "svg");
    n.classList.add(Ji("g")), this.padElement.appendChild(n), this.svgElem_ = n;
    const r = e.createElementNS(yi, "line");
    r.classList.add(Ji("ax")), r.setAttributeNS(null, "x1", "0"), r.setAttributeNS(null, "y1", "50%"), r.setAttributeNS(null, "x2", "100%"), r.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(r);
    const o = e.createElementNS(yi, "line");
    o.classList.add(Ji("ax")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "0"), o.setAttributeNS(null, "x2", "50%"), o.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(o);
    const a = e.createElementNS(yi, "line");
    a.classList.add(Ji("l")), a.setAttributeNS(null, "x1", "50%"), a.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(a), this.lineElem_ = a;
    const l = e.createElement("div");
    l.classList.add(Ji("m")), this.padElement.appendChild(l), this.markerElem_ = l, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [e, t] = this.value.rawValue.getComponents(), i = this.props_.get("max"), n = nt(e, -i, +i, 0, 100), r = nt(t, -i, +i, 0, 100), o = this.props_.get("invertsY") ? 100 - r : r;
    this.lineElem_.setAttributeNS(null, "x2", `${n}%`), this.lineElem_.setAttributeNS(null, "y2", `${o}%`), this.markerElem_.style.left = `${n}%`, this.markerElem_.style.top = `${o}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
}
function $d(s, e, t) {
  return [qt(e[0], Hi(s)), qt(e[1], vr(s)) * (t ? 1 : -1)];
}
class ZS {
  constructor(e, t) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new KS(e, { layout: t.layout, props: this.props, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Wn(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point) return;
    const i = this.props.get("max"), n = nt(e.point.x, 0, e.bounds.width, -i, +i), r = nt(this.props.get("invertsY") ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -i, +i);
    this.value.setRawValue(new hn(n, r), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: false, last: false });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, { forceEmit: true, last: true });
  }
  onPadKeyDown_(e) {
    Tp(e.key) && e.preventDefault();
    const [t, i] = $d(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
    t === 0 && i === 0 || this.value.setRawValue(new hn(this.value.rawValue.x + t, this.value.rawValue.y + i), { forceEmit: false, last: false });
  }
  onPadKeyUp_(e) {
    const [t, i] = $d(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
    t === 0 && i === 0 || this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
  }
}
class JS {
  constructor(e, t) {
    var i, n;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Rr.create(t.expanded), this.popC_ = t.pickerLayout === "popup" ? new Ep(e, { viewProps: this.viewProps }) : null;
    const r = new ZS(e, { layout: t.pickerLayout, props: new $e({ invertsY: mt(t.invertsY), max: mt(t.max), xKeyScale: t.axes[0].textProps.value("keyScale"), yKeyScale: t.axes[1].textProps.value("keyScale") }), value: this.value, viewProps: this.viewProps });
    r.view.allFocusableElements.forEach((o) => {
      o.addEventListener("blur", this.onPopupChildBlur_), o.addEventListener("keydown", this.onPopupChildKeydown_);
    }), this.pickerC_ = r, this.textC_ = new Kc(e, { assembly: Jp, axes: t.axes, parser: t.parser, value: this.value, viewProps: this.viewProps }), this.view = new qS(e, { expanded: this.foldable_.value("expanded"), pickerLayout: t.pickerLayout, viewProps: this.viewProps }), this.view.textElement.appendChild(this.textC_.view.element), (i = this.view.buttonElement) === null || i === void 0 || i.addEventListener("blur", this.onPadButtonBlur_), (n = this.view.buttonElement) === null || n === void 0 || n.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Bs({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (o) => o, backward: (o, a) => a })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Fc(this.foldable_, this.view.pickerElement));
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) return;
    const t = this.view.element, i = e.relatedTarget;
    (!i || !t.contains(i)) && (this.popC_.shows.rawValue = false);
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
  }
  onPopupChildBlur_(e) {
    if (!this.popC_) return;
    const t = this.popC_.view.element, i = mp(e);
    i && t.contains(i) || i && i === this.view.buttonElement && !Lc(t.ownerDocument) || (this.popC_.shows.rawValue = false);
  }
  onPopupChildKeydown_(e) {
    this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = false) : this.view.pickerElement && e.key === "Escape" && this.view.buttonElement.focus();
  }
}
function QS(s) {
  return hn.isObject(s) ? new hn(s.x, s.y) : new hn();
}
function eE(s, e) {
  s.writeProperty("x", e.x), s.writeProperty("y", e.y);
}
function tE(s, e) {
  return new qc({ assembly: Jp, components: [Oi(Object.assign(Object.assign({}, s), s.x), e.x), Oi(Object.assign(Object.assign({}, s), s.y), e.y)] });
}
function Wd(s, e) {
  var t, i;
  if (!ht(s.min) || !ht(s.max)) return Math.max(Math.abs((t = s.min) !== null && t !== void 0 ? t : 0), Math.abs((i = s.max) !== null && i !== void 0 ? i : 0));
  const n = op(s);
  return Math.max(Math.abs(n) * 10, Math.abs(e) * 10);
}
function iE(s, e) {
  var t, i;
  const n = Wd(zn(s, (t = s.x) !== null && t !== void 0 ? t : {}), e.x), r = Wd(zn(s, (i = s.y) !== null && i !== void 0 ? i : {}), e.y);
  return Math.max(n, r);
}
function nE(s) {
  if (!("y" in s)) return false;
  const e = s.y;
  return e && "inverted" in e ? !!e.inverted : false;
}
const sE = Gt({ id: "input-point2d", type: "input", accept: (s, e) => {
  if (!hn.isObject(s)) return null;
  const t = vt(e, (i) => Object.assign(Object.assign({}, _r(i)), { expanded: i.optional.boolean, picker: i.optional.custom(Rp), readonly: i.optional.constant(false), x: i.optional.custom(rn), y: i.optional.object(Object.assign(Object.assign({}, _r(i)), { inverted: i.optional.boolean })) }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: () => QS, constraint: (s) => tE(s.params, s.initialValue), equals: hn.equals, writer: () => eE }, controller: (s) => {
  var e, t;
  const i = s.document, n = s.value, r = s.constraint, o = [s.params.x, s.params.y];
  return new JS(i, { axes: n.rawValue.getComponents().map((a, l) => {
    var c;
    return Dc({ constraint: r.components[l], initialValue: a, params: zn(s.params, (c = o[l]) !== null && c !== void 0 ? c : {}) });
  }), expanded: (e = s.params.expanded) !== null && e !== void 0 ? e : false, invertsY: nE(s.params), max: iE(s.params, n.rawValue), parser: Vi, pickerLayout: (t = s.params.picker) !== null && t !== void 0 ? t : "popup", value: n, viewProps: s.viewProps });
} });
class Ms {
  constructor(e = 0, t = 0, i = 0) {
    this.x = e, this.y = t, this.z = i;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(e) {
    if (ht(e)) return false;
    const t = e.x, i = e.y, n = e.z;
    return !(typeof t != "number" || typeof i != "number" || typeof n != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y && e.z === t.z;
  }
  toObject() {
    return { x: this.x, y: this.y, z: this.z };
  }
}
const Qp = { toComponents: (s) => s.getComponents(), fromComponents: (s) => new Ms(...s) };
function rE(s) {
  return Ms.isObject(s) ? new Ms(s.x, s.y, s.z) : new Ms();
}
function oE(s, e) {
  s.writeProperty("x", e.x), s.writeProperty("y", e.y), s.writeProperty("z", e.z);
}
function aE(s, e) {
  return new qc({ assembly: Qp, components: [Oi(Object.assign(Object.assign({}, s), s.x), e.x), Oi(Object.assign(Object.assign({}, s), s.y), e.y), Oi(Object.assign(Object.assign({}, s), s.z), e.z)] });
}
const lE = Gt({ id: "input-point3d", type: "input", accept: (s, e) => {
  if (!Ms.isObject(s)) return null;
  const t = vt(e, (i) => Object.assign(Object.assign({}, _r(i)), { readonly: i.optional.constant(false), x: i.optional.custom(rn), y: i.optional.custom(rn), z: i.optional.custom(rn) }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => rE, constraint: (s) => aE(s.params, s.initialValue), equals: Ms.equals, writer: (s) => oE }, controller: (s) => {
  const e = s.value, t = s.constraint, i = [s.params.x, s.params.y, s.params.z];
  return new Kc(s.document, { assembly: Qp, axes: e.rawValue.getComponents().map((n, r) => {
    var o;
    return Dc({ constraint: t.components[r], initialValue: n, params: zn(s.params, (o = i[r]) !== null && o !== void 0 ? o : {}) });
  }), parser: Vi, value: e, viewProps: s.viewProps });
} });
class Cs {
  constructor(e = 0, t = 0, i = 0, n = 0) {
    this.x = e, this.y = t, this.z = i, this.w = n;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(e) {
    if (ht(e)) return false;
    const t = e.x, i = e.y, n = e.z, r = e.w;
    return !(typeof t != "number" || typeof i != "number" || typeof n != "number" || typeof r != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
  }
  toObject() {
    return { x: this.x, y: this.y, z: this.z, w: this.w };
  }
}
const ef = { toComponents: (s) => s.getComponents(), fromComponents: (s) => new Cs(...s) };
function cE(s) {
  return Cs.isObject(s) ? new Cs(s.x, s.y, s.z, s.w) : new Cs();
}
function hE(s, e) {
  s.writeProperty("x", e.x), s.writeProperty("y", e.y), s.writeProperty("z", e.z), s.writeProperty("w", e.w);
}
function dE(s, e) {
  return new qc({ assembly: ef, components: [Oi(Object.assign(Object.assign({}, s), s.x), e.x), Oi(Object.assign(Object.assign({}, s), s.y), e.y), Oi(Object.assign(Object.assign({}, s), s.z), e.z), Oi(Object.assign(Object.assign({}, s), s.w), e.w)] });
}
const uE = Gt({ id: "input-point4d", type: "input", accept: (s, e) => {
  if (!Cs.isObject(s)) return null;
  const t = vt(e, (i) => Object.assign(Object.assign({}, _r(i)), { readonly: i.optional.constant(false), w: i.optional.custom(rn), x: i.optional.custom(rn), y: i.optional.custom(rn), z: i.optional.custom(rn) }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => cE, constraint: (s) => dE(s.params, s.initialValue), equals: Cs.equals, writer: (s) => hE }, controller: (s) => {
  const e = s.value, t = s.constraint, i = [s.params.x, s.params.y, s.params.z, s.params.w];
  return new Kc(s.document, { assembly: ef, axes: e.rawValue.getComponents().map((n, r) => {
    var o;
    return Dc({ constraint: t.components[r], initialValue: n, params: zn(s.params, (o = i[r]) !== null && o !== void 0 ? o : {}) });
  }), parser: Vi, value: e, viewProps: s.viewProps });
} });
function pE(s) {
  const e = [], t = Vc(s.options);
  return t && e.push(t), new Dr(e);
}
const fE = Gt({ id: "input-string", type: "input", accept: (s, e) => {
  if (typeof s != "string") return null;
  const t = vt(e, (i) => ({ readonly: i.optional.constant(false), options: i.optional.custom(Ir) }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => Cp, constraint: (s) => pE(s.params), writer: (s) => kr }, controller: (s) => {
  const e = s.document, t = s.value, i = s.constraint, n = i && qo(i, Lr);
  return n ? new mn(e, { props: new $e({ options: n.values.value("options") }), value: t, viewProps: s.viewProps }) : new gr(e, { parser: (r) => r, props: $e.fromObject({ formatter: oc }), value: t, viewProps: s.viewProps });
}, api(s) {
  return typeof s.controller.value.rawValue != "string" ? null : s.controller.valueController instanceof mn ? new zc(s.controller) : null;
} }), Ur = { monitor: { defaultInterval: 200, defaultRows: 3 } }, Xd = Ze("mll");
class mE {
  constructor(e, t) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(Xd()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("textarea");
    i.classList.add(Xd("i")), i.style.height = `calc(var(${Pp("containerUnitSize")}) * ${t.rows})`, i.readOnly = true, t.viewProps.bindDisabled(i), this.element.appendChild(i), this.textareaElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  update_() {
    const e = this.textareaElem_, t = e.scrollTop === e.scrollHeight - e.clientHeight, i = [];
    this.value.rawValue.forEach((n) => {
      n !== void 0 && i.push(this.formatter_(n));
    }), e.textContent = i.join(`
`), t && (e.scrollTop = e.scrollHeight);
  }
  onValueUpdate_() {
    this.update_();
  }
}
class Zc {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new mE(e, { formatter: t.formatter, rows: t.rows, value: this.value, viewProps: this.viewProps });
  }
}
const jd = Ze("sgl");
class gE {
  constructor(e, t) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(jd()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("input");
    i.classList.add(jd("i")), i.readOnly = true, i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  update_() {
    const e = this.value.rawValue, t = e[e.length - 1];
    this.inputElement.value = t !== void 0 ? this.formatter_(t) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
}
class Jc {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new gE(e, { formatter: t.formatter, value: this.value, viewProps: this.viewProps });
  }
}
const vE = Gt({ id: "monitor-bool", type: "monitor", accept: (s, e) => {
  if (typeof s != "boolean") return null;
  const t = vt(e, (i) => ({ readonly: i.required.constant(true), rows: i.optional.number }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => Mp }, controller: (s) => {
  var e;
  return s.value.rawValue.length === 1 ? new Jc(s.document, { formatter: zd, value: s.value, viewProps: s.viewProps }) : new Zc(s.document, { formatter: zd, rows: (e = s.params.rows) !== null && e !== void 0 ? e : Ur.monitor.defaultRows, value: s.value, viewProps: s.viewProps });
} });
class _E extends mr {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(e) {
    this.controller.valueController.props.set("max", e);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(e) {
    this.controller.valueController.props.set("min", e);
  }
}
const Qi = Ze("grl");
class bE {
  constructor(e, t) {
    this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(Qi()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.props_ = t.props, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
    const i = e.createElementNS(yi, "svg");
    i.classList.add(Qi("g")), i.style.height = `calc(var(${Pp("containerUnitSize")}) * ${t.rows})`, this.element.appendChild(i), this.svgElem_ = i;
    const n = e.createElementNS(yi, "polyline");
    this.svgElem_.appendChild(n), this.lineElem_ = n;
    const r = e.createElement("div");
    r.classList.add(Qi("t"), Ze("tt")()), this.element.appendChild(r), this.tooltipElem_ = r, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const { clientWidth: e, clientHeight: t } = this.element, i = this.value.rawValue.length - 1, n = this.props_.get("min"), r = this.props_.get("max"), o = [];
    this.value.rawValue.forEach((d, u) => {
      if (d === void 0) return;
      const f = nt(u, 0, i, 0, e), m = nt(d, n, r, t, 0);
      o.push([f, m].join(","));
    }), this.lineElem_.setAttributeNS(null, "points", o.join(" "));
    const a = this.tooltipElem_, l = this.value.rawValue[this.cursor_.rawValue];
    if (l === void 0) {
      a.classList.remove(Qi("t", "a"));
      return;
    }
    const c = nt(this.cursor_.rawValue, 0, i, 0, e), h = nt(l, n, r, t, 0);
    a.style.left = `${c}px`, a.style.top = `${h}px`, a.textContent = `${this.formatter_(l)}`, a.classList.contains(Qi("t", "a")) || (a.classList.add(Qi("t", "a"), Qi("t", "in")), Yo(a), a.classList.remove(Qi("t", "in")));
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
}
class tf {
  constructor(e, t) {
    if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = mt(-1), this.view = new bE(e, { cursor: this.cursor_, formatter: t.formatter, rows: t.rows, props: this.props, value: this.value, viewProps: this.viewProps }), !Lc(e)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    else {
      const i = new Wn(this.view.element);
      i.emitter.on("down", this.onGraphPointerDown_), i.emitter.on("move", this.onGraphPointerMove_), i.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(e) {
    return ii(e, null, (t) => ({ max: t.required.number, min: t.required.number }), (t) => (this.props.set("max", t.max), this.props.set("min", t.min), true));
  }
  exportProps() {
    return ni(null, { max: this.props.get("max"), min: this.props.get("min") });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(e) {
    const { clientWidth: t } = this.view.element;
    this.cursor_.rawValue = Math.floor(nt(e.offsetX, 0, t, 0, this.value.rawValue.length));
  }
  onGraphPointerDown_(e) {
    this.onGraphPointerMove_(e);
  }
  onGraphPointerMove_(e) {
    if (!e.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(nt(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length));
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
}
function ac(s) {
  return ht(s.format) ? Zt(2) : s.format;
}
function xE(s) {
  var e;
  return s.value.rawValue.length === 1 ? new Jc(s.document, { formatter: ac(s.params), value: s.value, viewProps: s.viewProps }) : new Zc(s.document, { formatter: ac(s.params), rows: (e = s.params.rows) !== null && e !== void 0 ? e : Ur.monitor.defaultRows, value: s.value, viewProps: s.viewProps });
}
function wE(s) {
  var e, t, i;
  return new tf(s.document, { formatter: ac(s.params), rows: (e = s.params.rows) !== null && e !== void 0 ? e : Ur.monitor.defaultRows, props: $e.fromObject({ max: (t = s.params.max) !== null && t !== void 0 ? t : 100, min: (i = s.params.min) !== null && i !== void 0 ? i : 0 }), value: s.value, viewProps: s.viewProps });
}
function Yd(s) {
  return s.view === "graph";
}
const yE = Gt({ id: "monitor-number", type: "monitor", accept: (s, e) => {
  if (typeof s != "number") return null;
  const t = vt(e, (i) => ({ format: i.optional.function, max: i.optional.number, min: i.optional.number, readonly: i.required.constant(true), rows: i.optional.number, view: i.optional.string }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { defaultBufferSize: (s) => Yd(s) ? 64 : 1, reader: (s) => sp }, controller: (s) => Yd(s.params) ? wE(s) : xE(s), api: (s) => s.controller.valueController instanceof tf ? new _E(s.controller) : null }), SE = Gt({ id: "monitor-string", type: "monitor", accept: (s, e) => {
  if (typeof s != "string") return null;
  const t = vt(e, (i) => ({ multiline: i.optional.boolean, readonly: i.required.constant(true), rows: i.optional.number }));
  return t ? { initialValue: s, params: t } : null;
}, binding: { reader: (s) => Cp }, controller: (s) => {
  var e;
  const t = s.value;
  return t.rawValue.length > 1 || s.params.multiline ? new Zc(s.document, { formatter: oc, rows: (e = s.params.rows) !== null && e !== void 0 ? e : Ur.monitor.defaultRows, value: t, viewProps: s.viewProps }) : new Jc(s.document, { formatter: oc, value: t, viewProps: s.viewProps });
} });
class EE {
  constructor() {
    this.map_ = /* @__PURE__ */ new Map();
  }
  get(e) {
    var t;
    return (t = this.map_.get(e)) !== null && t !== void 0 ? t : null;
  }
  has(e) {
    return this.map_.has(e);
  }
  add(e, t) {
    return this.map_.set(e, t), e.viewProps.handleDispose(() => {
      this.map_.delete(e);
    }), t;
  }
}
class ME {
  constructor(e) {
    this.target = e.target, this.reader_ = e.reader, this.writer_ = e.writer;
  }
  read() {
    return this.reader_(this.target.read());
  }
  write(e) {
    this.writer_(this.target, e);
  }
  inject(e) {
    this.write(this.reader_(e));
  }
}
function CE(s, e) {
  var t;
  const i = s.accept(e.target.read(), e.params);
  if (ht(i)) return null;
  const n = { target: e.target, initialValue: i.initialValue, params: i.params }, r = vt(e.params, (d) => ({ disabled: d.optional.boolean, hidden: d.optional.boolean, label: d.optional.string, tag: d.optional.string })), o = s.binding.reader(n), a = s.binding.constraint ? s.binding.constraint(n) : void 0, l = new ME({ reader: o, target: e.target, writer: s.binding.writer(n) }), c = new cw(mt(o(i.initialValue), { constraint: a, equals: s.binding.equals }), l), h = s.controller({ constraint: a, document: e.document, initialValue: i.initialValue, params: i.params, value: c, viewProps: Gi.create({ disabled: r == null ? void 0 : r.disabled, hidden: r == null ? void 0 : r.hidden }) });
  return new Ew(e.document, { blade: zs(), props: $e.fromObject({ label: "label" in e.params ? (t = r == null ? void 0 : r.label) !== null && t !== void 0 ? t : null : e.target.key }), tag: r == null ? void 0 : r.tag, value: c, valueController: h });
}
class TE {
  constructor(e) {
    this.target = e.target, this.reader_ = e.reader;
  }
  read() {
    return this.reader_(this.target.read());
  }
}
function AE(s, e) {
  return e === 0 ? new oy() : new ay(s, e ?? Ur.monitor.defaultInterval);
}
function PE(s, e) {
  var t, i, n;
  const r = s.accept(e.target.read(), e.params);
  if (ht(r)) return null;
  const o = { target: e.target, initialValue: r.initialValue, params: r.params }, a = vt(e.params, (u) => ({ bufferSize: u.optional.number, disabled: u.optional.boolean, hidden: u.optional.boolean, interval: u.optional.number, label: u.optional.string })), l = s.binding.reader(o), c = (i = (t = a == null ? void 0 : a.bufferSize) !== null && t !== void 0 ? t : s.binding.defaultBufferSize && s.binding.defaultBufferSize(r.params)) !== null && i !== void 0 ? i : 1, h = new Pw({ binding: new TE({ reader: l, target: e.target }), bufferSize: c, ticker: AE(e.document, a == null ? void 0 : a.interval) }), d = s.controller({ document: e.document, params: r.params, value: h, viewProps: Gi.create({ disabled: a == null ? void 0 : a.disabled, hidden: a == null ? void 0 : a.hidden }) });
  return d.viewProps.bindDisabled(h.ticker), d.viewProps.handleDispose(() => {
    h.ticker.dispose();
  }), new Dw(e.document, { blade: zs(), props: $e.fromObject({ label: "label" in e.params ? (n = a == null ? void 0 : a.label) !== null && n !== void 0 ? n : null : e.target.key }), value: h, valueController: d });
}
class RE {
  constructor(e) {
    this.pluginsMap_ = { blades: [], inputs: [], monitors: [] }, this.apiCache_ = e;
  }
  getAll() {
    return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
  }
  register(e, t) {
    if (!xy(t.core)) throw bt.notCompatible(e, t.id);
    t.type === "blade" ? this.pluginsMap_.blades.unshift(t) : t.type === "input" ? this.pluginsMap_.inputs.unshift(t) : t.type === "monitor" && this.pluginsMap_.monitors.unshift(t);
  }
  createInput_(e, t, i) {
    return this.pluginsMap_.inputs.reduce((n, r) => n ?? CE(r, { document: e, target: t, params: i }), null);
  }
  createMonitor_(e, t, i) {
    return this.pluginsMap_.monitors.reduce((n, r) => n ?? PE(r, { document: e, params: i, target: t }), null);
  }
  createBinding(e, t, i) {
    const n = t.read();
    if (ht(n)) throw new bt({ context: { key: t.key }, type: "nomatchingcontroller" });
    const r = this.createInput_(e, t, i);
    if (r) return r;
    const o = this.createMonitor_(e, t, i);
    if (o) return o;
    throw new bt({ context: { key: t.key }, type: "nomatchingcontroller" });
  }
  createBlade(e, t) {
    const i = this.pluginsMap_.blades.reduce((n, r) => n ?? ry(r, { document: e, params: t }), null);
    if (!i) throw new bt({ type: "nomatchingview", context: { params: t } });
    return i;
  }
  createInputBindingApi_(e) {
    const t = this.pluginsMap_.inputs.reduce((i, n) => {
      var r, o;
      return i || ((o = (r = n.api) === null || r === void 0 ? void 0 : r.call(n, { controller: e })) !== null && o !== void 0 ? o : null);
    }, null);
    return this.apiCache_.add(e, t ?? new mr(e));
  }
  createMonitorBindingApi_(e) {
    const t = this.pluginsMap_.monitors.reduce((i, n) => {
      var r, o;
      return i || ((o = (r = n.api) === null || r === void 0 ? void 0 : r.call(n, { controller: e })) !== null && o !== void 0 ? o : null);
    }, null);
    return this.apiCache_.add(e, t ?? new mr(e));
  }
  createBindingApi(e) {
    if (this.apiCache_.has(e)) return this.apiCache_.get(e);
    if (Mw(e)) return this.createInputBindingApi_(e);
    if (Lw(e)) return this.createMonitorBindingApi_(e);
    throw bt.shouldNeverHappen();
  }
  createApi(e) {
    if (this.apiCache_.has(e)) return this.apiCache_.get(e);
    if (Sw(e)) return this.createBindingApi(e);
    const t = this.pluginsMap_.blades.reduce((i, n) => i ?? n.api({ controller: e, pool: this }), null);
    if (!t) throw bt.shouldNeverHappen();
    return this.apiCache_.add(e, t);
  }
}
const DE = new EE();
function LE() {
  const s = new RE(DE);
  return [sE, lE, uE, fE, YS, GS, HS, US, Ey, vE, SE, yE, Uw, Kw, Sp].forEach((e) => {
    s.register("core", e);
  }), s;
}
class IE extends $n {
  constructor(e) {
    super(e), this.emitter_ = new Mt(), this.controller.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", new Pr(this, t.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(e) {
    this.controller.valueController.props.set("options", e);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(e) {
    this.controller.value.rawValue = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
class NE extends $n {
}
class kE extends $n {
  constructor(e) {
    super(e), this.emitter_ = new Mt(), this.controller.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", new Pr(this, t.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(e) {
    this.controller.valueController.sliderController.props.set("max", e);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(e) {
    this.controller.valueController.sliderController.props.set("min", e);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(e) {
    this.controller.value.rawValue = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
class OE extends $n {
  constructor(e) {
    super(e), this.emitter_ = new Mt(), this.controller.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", new Pr(this, t.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(e) {
    this.controller.labelController.props.set("label", e);
  }
  get formatter() {
    return this.controller.valueController.props.get("formatter");
  }
  set formatter(e) {
    this.controller.valueController.props.set("formatter", e);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(e) {
    this.controller.value.rawValue = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (n) => {
      i(n);
    }, { key: t }), this;
  }
  off(e, t) {
    return this.emitter_.off(e, t), this;
  }
}
const UE = /* @__PURE__ */ function() {
  return { id: "list", type: "blade", core: Fs, accept(s) {
    const e = vt(s, (t) => ({ options: t.required.custom(Ir), value: t.required.raw, view: t.required.constant("list"), label: t.optional.string }));
    return e ? { params: e } : null;
  }, controller(s) {
    const e = new Lr(Bc(s.params.options)), t = mt(s.params.value, { constraint: e }), i = new mn(s.document, { props: new $e({ options: e.values.value("options") }), value: t, viewProps: s.viewProps });
    return new Bn(s.document, { blade: s.blade, props: $e.fromObject({ label: s.params.label }), value: t, valueController: i });
  }, api(s) {
    return !(s.controller instanceof Bn) || !(s.controller.valueController instanceof mn) ? null : new IE(s.controller);
  } };
}();
class FE extends wp {
  constructor(e, t) {
    super(e, t);
  }
  get element() {
    return this.controller.view.element;
  }
}
class zE extends sc {
  constructor(e, t) {
    super(e, { expanded: t.expanded, blade: t.blade, props: t.props, root: true, viewProps: t.viewProps });
  }
}
const qd = Ze("spr");
class BE {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(qd()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("hr");
    i.classList.add(qd("r")), this.element.appendChild(i);
  }
}
class Kd extends ra {
  constructor(e, t) {
    super(Object.assign(Object.assign({}, t), { view: new BE(e, { viewProps: t.viewProps }) }));
  }
}
const VE = { id: "separator", type: "blade", core: Fs, accept(s) {
  const e = vt(s, (t) => ({ view: t.required.constant("separator") }));
  return e ? { params: e } : null;
}, controller(s) {
  return new Kd(s.document, { blade: s.blade, viewProps: s.viewProps });
}, api(s) {
  return s.controller instanceof Kd ? new NE(s.controller) : null;
} }, HE = { id: "slider", type: "blade", core: Fs, accept(s) {
  const e = vt(s, (t) => ({ max: t.required.number, min: t.required.number, view: t.required.constant("slider"), format: t.optional.function, label: t.optional.string, value: t.optional.number }));
  return e ? { params: e } : null;
}, controller(s) {
  var e, t;
  const i = (e = s.params.value) !== null && e !== void 0 ? e : 0, n = new Ar({ max: s.params.max, min: s.params.min }), r = mt(i, { constraint: n }), o = new Zo(s.document, Object.assign(Object.assign({}, Ap({ formatter: (t = s.params.format) !== null && t !== void 0 ? t : sw, keyScale: mt(1), max: n.values.value("max"), min: n.values.value("min"), pointerScale: ap(s.params, i) })), { parser: Vi, value: r, viewProps: s.viewProps }));
  return new Bn(s.document, { blade: s.blade, props: $e.fromObject({ label: s.params.label }), value: r, valueController: o });
}, api(s) {
  return !(s.controller instanceof Bn) || !(s.controller.valueController instanceof Zo) ? null : new kE(s.controller);
} }, GE = /* @__PURE__ */ function() {
  return { id: "text", type: "blade", core: Fs, accept(s) {
    const e = vt(s, (t) => ({ parse: t.required.function, value: t.required.raw, view: t.required.constant("text"), format: t.optional.function, label: t.optional.string }));
    return e ? { params: e } : null;
  }, controller(s) {
    var e;
    const t = mt(s.params.value), i = new gr(s.document, { parser: s.params.parse, props: $e.fromObject({ formatter: (e = s.params.format) !== null && e !== void 0 ? e : (n) => String(n) }), value: t, viewProps: s.viewProps });
    return new Bn(s.document, { blade: s.blade, props: $e.fromObject({ label: s.params.label }), value: t, valueController: i });
  }, api(s) {
    return !(s.controller instanceof Bn) || !(s.controller.valueController instanceof gr) ? null : new OE(s.controller);
  } };
}();
function $E(s) {
  const e = s.createElement("div");
  return e.classList.add(Ze("dfw")()), s.body && s.body.appendChild(e), e;
}
function WE(s, e, t) {
  if (s.querySelector(`style[data-tp-style=${e}]`)) return;
  const i = s.createElement("style");
  i.dataset.tpStyle = e, i.textContent = t, s.head.appendChild(i);
}
class XE extends FE {
  constructor(e) {
    var t, i;
    const n = e ?? {}, r = (t = n.document) !== null && t !== void 0 ? t : gw(), o = LE(), a = new zE(r, { expanded: n.expanded, blade: zs(), props: $e.fromObject({ title: n.title }), viewProps: Gi.create() });
    super(a, o), this.pool_ = o, this.containerElem_ = (i = n.container) !== null && i !== void 0 ? i : $E(r), this.containerElem_.appendChild(this.element), this.doc_ = r, this.usesDefaultWrapper_ = !n.container, this.setUpDefaultPlugins_();
  }
  get document() {
    if (!this.doc_) throw bt.alreadyDisposed();
    return this.doc_;
  }
  dispose() {
    const e = this.containerElem_;
    if (!e) throw bt.alreadyDisposed();
    if (this.usesDefaultWrapper_) {
      const t = e.parentElement;
      t && t.removeChild(e);
    }
    this.containerElem_ = null, this.doc_ = null, super.dispose();
  }
  registerPlugin(e) {
    e.css && WE(this.document, `plugin-${e.id}`, e.css), ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach((i) => {
      this.pool_.register(e.id, i);
    });
  }
  setUpDefaultPlugins_() {
    this.registerPlugin({ id: "default", css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{display:block;height:16px;inset:0;margin:auto;opacity:0;position:absolute;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{inset:0;position:absolute}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;inset:0;position:absolute}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);content:"";display:block;inset:0;position:absolute}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin:auto;position:absolute}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin-bottom:auto;margin-top:auto;position:absolute}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);content:"";inset:0 0 2px;pointer-events:none;position:absolute}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}', plugins: [UE, VE, HE, Sp, GE] });
  }
}
new xp("4.0.4");
function jE(s, e, t) {
  const i = document.createElement("div"), n = new XE({ title: "Settings", expanded: false, container: i });
  if (i.setAttribute("id", "settings"), (e == null ? void 0 : e.nodes) && (n.addBinding(s.displayScale, "val", { label: "Display scale", min: -10, max: 10, step: 1 }), n.addBinding(s.nodes, "val", { label: "Nodes" }), n.addBinding(s.elements, "val", { label: "Elements" }), n.addBinding(s.nodesIndexes, "val", { label: "Nodes indexes" }), n.addBinding(s.elementsIndexes, "val", { label: "Elements indexes" }), n.addBinding(s.orientations, "val", { label: "Orientations" })), (e == null ? void 0 : e.nodeInputs) || (e == null ? void 0 : e.elementInputs)) {
    const r = n.addFolder({ title: "Analysis Inputs" });
    r.addBinding(s.supports, "val", { label: "Supports" }), r.addBinding(s.loads, "val", { label: "Loads" });
  }
  if ((e == null ? void 0 : e.deformOutputs) || (e == null ? void 0 : e.analyzeOutputs)) {
    const r = n.addFolder({ title: "Analysis Outputs" });
    r.addBinding(s.elementResults, "val", { options: { none: "none", normals: "normals", shearsY: "shearsY", shearsZ: "shearsZ", torsions: "torsions", bendingsY: "bendingsY", bendingsZ: "bendingsZ" }, label: "Element results" }), r.addBinding(s.nodeResults, "val", { options: { none: "none", deformations: "deformations", reactions: "reactions" }, label: "Node results" }), r.addBinding(s.deformedShape, "val", { label: "Deformed shape" });
  }
  return t && n.addBinding(s.solids, "val", { label: "Solids" }), i;
}
function YE(s, e, t) {
  const i = new Kl(new ft(), new Xo()), n = 0.05 * s.gridSize.rawVal * 0.5;
  return i.frustumCulled = false, De.derive(() => {
    s.nodes.val && i.geometry.setAttribute("position", new lt(e.val.flat(), 3));
  }), De.derive(() => {
    t.val, s.nodes.rawVal && (i.material.size = n * t.rawVal);
  }), De.derive(() => {
    i.visible = s.nodes.val;
  }), i;
}
function qE(s, e, t) {
  const i = new yc(new ft(), new fn());
  return i.frustumCulled = false, i.material.depthTest = false, De.derive(() => {
    var _a2;
    if (e.deformedShape.val, !e.elements.val) return;
    const n = (_a2 = s.elements) == null ? void 0 : _a2.val.map((r) => KE(r).map((o) => [...t.val[o[0]], ...t.val[o[1]]]).flat()).flat();
    i.geometry.setAttribute("position", new lt(n, 3));
  }), De.derive(() => {
    i.visible = e.elements.val;
  }), i;
}
function KE(s) {
  if (s.length === 2) return [s];
  const e = [];
  for (let t = 0; t < s.length; t++) e.push([s[t], s[(t + 1) % s.length]]);
  return e;
}
function ZE(s) {
  const e = new lx(s, 20, 4210752, 4210752);
  return e.position.set(0.5 * s, 0.5 * s, 0), e.rotateX(Math.PI / 2), e;
}
function JE(s, e, t, i) {
  const n = new Bt(), r = new ks(0.5, 0.5, 0.5), o = new Fi({ color: 10166822 }), a = 0.05 * e.gridSize.rawVal * 0.6;
  return De.derive(() => {
    var _a2, _b2;
    e.deformedShape.val, e.supports.val && (n.clear(), (_b2 = (_a2 = s.nodeInputs) == null ? void 0 : _a2.val.supports) == null ? void 0 : _b2.forEach((l, c) => {
      const h = t.val[c];
      if (!h) return;
      const d = new Ut(r, o);
      d.position.set(...h);
      const u = a * i.rawVal;
      d.scale.set(u, u, u), n.add(d);
    }));
  }), De.derive(() => {
    if (i.val, !e.supports.rawVal) return;
    const l = a * i.rawVal;
    n.children.forEach((c) => c.scale.set(l, l, l));
  }), De.derive(() => {
    n.visible = e.supports.val;
  }), n;
}
function QE(s, e, t, i) {
  const n = new Bt(), r = 0.05 * e.gridSize.rawVal;
  return De.derive(() => {
    var _a2, _b2;
    e.deformedShape.val, e.loads.val && (n.children.forEach((o) => o.dispose()), n.clear(), (_b2 = (_a2 = s.nodeInputs) == null ? void 0 : _a2.val.loads) == null ? void 0 : _b2.forEach((o, a) => {
      const l = t.val[a];
      if (!l) return;
      const c = new Nn(new I(...o.slice(0, 3)).normalize(), new I(...l), 1, 15637248, 0.3, 0.3), h = r * i.rawVal;
      c.scale.set(h, h, h), n.add(c);
    }));
  }), De.derive(() => {
    if (i.val, !e.loads.rawVal) return;
    const o = r * i.rawVal;
    n.children.forEach((a) => a.scale.set(o, o, o));
  }), De.derive(() => {
    n.visible = e.loads.val;
  }), n;
}
let jt = class extends Eb {
  constructor(e, t, i) {
    super();
    const n = 30;
    this.fontHeightPx = n * devicePixelRatio, this.material.map = eM(e, this.fontHeightPx, t, i), this.material.depthTest = false, this.renderOrder = 99, this.scale.set(this.material.map.image.width / this.fontHeightPx, 1, 1);
  }
  updateScale(e) {
    var _a2, _b2;
    this.scale.set(((_b2 = (_a2 = this.material) == null ? void 0 : _a2.map) == null ? void 0 : _b2.image.width) / this.fontHeightPx * e, e, 1);
  }
  dispose() {
    var _a2;
    this.geometry.dispose(), (_a2 = this.material.map) == null ? void 0 : _a2.dispose(), this.material.dispose();
  }
};
function eM(s, e, t, i) {
  const n = document.createElement("canvas"), r = n.getContext("2d");
  if (r) {
    r.font = `${e}px Arial`, n.width = r.measureText(s).width, n.height = e, i != "transparent" && (r.fillStyle = i ?? "#0d0d0d"), r.fillRect(0, 0, n.width, n.height), r.textAlign = "center", r.textBaseline = "middle", r.fillStyle = t ?? "#bbbcc4";
    const a = 0.9;
    r.font = `${e * a}px Arial`;
    const l = 0.08 * n.height;
    r.fillText(s, n.width / 2, n.height / 2 + l);
  }
  const o = new Vt(n);
  return o.needsUpdate = true, o;
}
function tM(s, e, t) {
  const i = new Bt(), n = 0.05 * s.gridSize.rawVal * 0.6;
  return De.derive(() => {
    s.nodesIndexes.val && (i.children.forEach((r) => r.dispose()), i.clear(), e.val.forEach((r, o) => {
      const a = new jt(`${o}`);
      a.position.set(...r), a.updateScale(n * t.rawVal), i.add(a);
    }));
  }), De.derive(() => {
    t.val, s.nodesIndexes.rawVal && i.children.forEach((r) => r.updateScale(n * t.rawVal));
  }), De.derive(() => {
    i.visible = s.nodesIndexes.val;
  }), i;
}
function iM(s, e, t, i) {
  const n = new Bt(), r = 0.05 * e.gridSize.rawVal * 0.6;
  return De.derive(() => {
    var _a2;
    e.deformedShape.val, e.elementsIndexes.val && (n.children.forEach((o) => o.dispose()), n.clear(), (_a2 = s.elements) == null ? void 0 : _a2.val.forEach((o, a) => {
      const l = new jt(`${a}`, void 0, "#001219");
      l.position.set(...nM(o.map((c) => t.rawVal[c]))), l.updateScale(r * i.rawVal), n.add(l);
    }));
  }), De.derive(() => {
    i.val, e.elementsIndexes.rawVal && n.children.forEach((o) => o.updateScale(r * i.rawVal));
  }), De.derive(() => {
    n.visible = e.elementsIndexes.val;
  }), n;
}
function nM(s) {
  const e = s.reduce((i, n) => [i[0] + n[0], i[1] + n[1], i[2] + n[2]], [0, 0, 0]), t = s.length;
  return [e[0] / t, e[1] / t, e[2] / t];
}
function sM(s, e) {
  const t = new Bt(), i = 0.05 * s * 1, n = new jt("X", "red", "transparent"), r = new jt(e ? "Z" : "Y", "green", "transparent"), o = new jt(e ? "Y" : "Z", "blue", "transparent"), a = new Nn(new I(1, 0, 0), new I(0, 0, 0), 1, 6710886, 0.2, 0.2), l = new Nn(new I(0, 1, 0), new I(0, 0, 0), 1, 6710886, 0.2, 0.2), c = new Nn(new I(0, 0, 1), new I(0, 0, 0), 1, 6710886, 0.2, 0.2);
  return n.position.set(1.3 * i, 0, 0), r.position.set(0, 1.3 * i, 0), o.position.set(0, 0, 1.3 * i), n.updateScale(0.4 * i), r.updateScale(0.4 * i), o.updateScale(0.4 * i), a.scale.set(i, i, i), l.scale.set(i, i, i), c.scale.set(i, i, i), t.add(a, l, c, n, r, o), t;
}
function nf(s, e) {
  const t = new I(...s), n = new I(...e).clone().sub(t), r = n.length(), o = n.dot(new I(1, 0, 0)) / r, a = n.dot(new I(0, 1, 0)) / r, l = n.dot(new I(0, 0, 1)) / r, c = Math.sqrt(o ** 2 + a ** 2);
  let h = new Be().fromArray([[o, a, l], [-a / c, o / c, 0], [-o * l / c, -a * l / c, c]].flat());
  return l === 1 && (h = new Be().fromArray([[0, 0, 1], [0, 1, 0], [-1, 0, 0]].flat())), l === -1 && (h = new Be().fromArray([[0, 0, -1], [0, 1, 0], [1, 0, 0]].flat())), new rt().setFromMatrix3(h);
}
function lc(s, e) {
  return s == null ? void 0 : s.map((t, i) => (9 * t + e[i]) / 10);
}
function ar(s) {
  const e = s.reduce((i, n) => [i[0] + n[0], i[1] + n[1], i[2] + n[2]], [0, 0, 0]), t = s.length;
  return [e[0] / t, e[1] / t, e[2] / t];
}
function rM(s, e, t) {
  const i = ar([e, t]), n = ar([s, t]), r = ar([s, e]), o = new I(...i).sub(new I(...n)).normalize(), a = new I(...t).sub(new I(...r)).normalize(), l = o.clone().cross(a).normalize(), c = l.clone().cross(o).normalize();
  return new rt().makeBasis(o, c, l);
}
function oM(s, e, t, i) {
  const n = new Bt(), r = new ft(), o = new fn({ vertexColors: true }), a = 0.05 * e.gridSize.rawVal * 0.75, l = [0, 0, 0], c = [1, 0, 0], h = [0, 1, 0], d = [0, 0, 1];
  r.setAttribute("position", new lt([...l, ...c, ...l, ...h, ...l, ...d], 3));
  const u = [255, 0, 0], f = [0, 255, 0], m = [0, 0, 255];
  return r.setAttribute("color", new lt([...u, ...u, ...f, ...f, ...m, ...m], 3)), De.derive(() => {
    var _a2;
    e.deformedShape.val, e.orientations.val && (n.clear(), (_a2 = s.elements) == null ? void 0 : _a2.val.forEach((_) => {
      const g = new yc(r, o), v = t.rawVal[_[0]], y = t.rawVal[_[1]];
      if (_.length === 2 && (g.position.set(...lc(v, y)), g.rotation.setFromRotationMatrix(nf(v, y))), _.length === 3) {
        const S = t.rawVal[_[2]];
        g.position.set(...ar([v, y, S])), g.rotation.setFromRotationMatrix(rM(v, y, S));
      }
      const x = a * i.rawVal;
      g.scale.set(x, x, x), n.add(g);
    }));
  }), De.derive(() => {
    if (i.val, !e.orientations.rawVal) return;
    const _ = a * i.rawVal;
    n.children.forEach((g) => g.scale.set(_, _, _));
  }), De.derive(() => {
    n.visible = e.orientations.val;
  }), n;
}
class So extends Bt {
  constructor(e, t, i, n, r, o, a) {
    super();
    const l = new Ss().moveTo(0, 0).lineTo(0, o[1]).lineTo(i, o[1]).lineTo(i, 0).lineTo(0, 0), c = l.getPoints(), h = new ft().setFromPoints(c);
    this.lines = new ys(h, new fn({ color: "white" })), this.lines.position.set(...e), this.lines.rotation.setFromRotationMatrix(n), a && this.lines.rotateX(Math.PI / 2), this.add(this.lines);
    const d = new Es(l), u = new Fi({ color: o[1] > 0 ? 24435 : 11411474, side: Yt });
    this.mesh = new Ut(d, u), this.mesh.position.set(...e), this.mesh.rotation.setFromRotationMatrix(n), a && this.mesh.rotateX(Math.PI / 2), this.add(this.mesh), this.text = new jt(`${r[1].toFixed(4)}`), this.normalizedResult = o, this.textPosition = ar([e, t]), this.text.position.set(...this.textPosition), this.text.rotation.setFromRotationMatrix(n), this.add(this.text);
  }
  updateScale(e) {
    this.lines.scale.set(1, e * 2, 1), this.mesh.scale.set(1, e * 2, 1), this.text.updateScale(e * 0.6), this.text.position.set(...this.textPosition), this.text.translateZ(this.normalizedResult[1] * 2.5 * e);
  }
  dispose() {
    this.lines.geometry.dispose(), this.lines.material.dispose(), this.mesh.geometry.dispose(), this.mesh.material.dispose(), this.text.dispose();
  }
}
class Zd extends Bt {
  constructor(e, t, i, n, r, o, a) {
    super();
    const l = r[0] * i / (r[0] + r[1]), c = r[0] * r[1] > 0;
    if (this.text = new jt(`${r[0].toFixed(4)}`), this.text2 = new jt(`${(r[1] * -1).toFixed(4)}`), this.normalizedResult = o, this.textPosition = lc(e, t), this.text2Position = lc(t, e), this.text.position.set(...this.textPosition), this.text2.position.set(...this.text2Position), this.text.rotation.setFromRotationMatrix(n), this.text2.rotation.setFromRotationMatrix(n), this.add(this.text, this.text2), c) {
      const h = new Ss().moveTo(0, 0).lineTo(0, o[0]).lineTo(l, 0).lineTo(0, 0), d = new Ss().moveTo(l, 0).lineTo(i, -o[1]).lineTo(i, 0).lineTo(l, 0), u = h.getPoints(), f = d.getPoints(), m = new ft().setFromPoints(u), _ = new ft().setFromPoints(f), g = new fn({ color: "white" });
      this.lines = new ys(m, g), this.lines2 = new ys(_, g), this.lines.position.set(...e), this.lines2.position.set(...e), this.lines.rotation.setFromRotationMatrix(n), this.lines2.rotation.setFromRotationMatrix(n), a && this.lines.rotateX(Math.PI / 2), a && this.lines2.rotateX(Math.PI / 2), this.add(this.lines, this.lines2);
      const v = new Es(h), y = new Es(d), x = new Fi({ color: o[0] > 0 ? 24435 : 11411474, side: Yt }), S = new Fi({ color: -o[1] > 0 ? 24435 : 11411474, side: Yt });
      this.mesh = new Ut(v, x), this.mesh2 = new Ut(y, S), this.mesh.position.set(...e), this.mesh2.position.set(...e), this.mesh.rotation.setFromRotationMatrix(n), this.mesh2.rotation.setFromRotationMatrix(n), a && this.mesh.rotateX(Math.PI / 2), a && this.mesh2.rotateX(Math.PI / 2), this.add(this.mesh, this.mesh2);
    } else {
      const h = new Ss().moveTo(0, 0).lineTo(0, o[0]).lineTo(i, -o[1]).lineTo(i, 0).lineTo(0, 0), d = h.getPoints(), u = new ft().setFromPoints(d);
      this.lines = new ys(u, new fn({ color: "white" })), this.lines.position.set(...e), this.lines.rotation.setFromRotationMatrix(n), a && this.lines.rotateX(Math.PI / 2), this.add(this.lines);
      const f = new Es(h), m = new Fi({ color: o[0] > 0 ? 24435 : 11411474, side: Yt });
      this.mesh = new Ut(f, m), this.mesh.position.set(...e), this.mesh.rotation.setFromRotationMatrix(n), a && this.mesh.rotateX(Math.PI / 2), this.add(this.mesh);
    }
  }
  updateScale(e) {
    var _a2, _b2;
    this.lines.scale.set(1, e * 2, 1), (_a2 = this.lines2) == null ? void 0 : _a2.scale.set(1, e * 2, 1), this.mesh.scale.set(1, e * 2, 1), (_b2 = this.mesh2) == null ? void 0 : _b2.scale.set(1, e * 2, 1), this.text.updateScale(e * 0.6), this.text2.updateScale(e * 0.6), this.text.position.set(...this.textPosition), this.text2.position.set(...this.text2Position), this.text.translateZ(this.normalizedResult[0] * 2.5 * e), this.text2.translateZ(-this.normalizedResult[1] * 2.5 * e);
  }
  dispose() {
    var _a2, _b2, _c2, _d2, _e, _f2;
    this.lines.geometry.dispose(), (_a2 = this.lines2) == null ? void 0 : _a2.geometry.dispose(), this.lines.material.dispose(), (_c2 = (_b2 = this.lines2) == null ? void 0 : _b2.material) == null ? void 0 : _c2.dispose(), this.mesh.geometry.dispose(), (_d2 = this.mesh2) == null ? void 0 : _d2.geometry.dispose(), this.mesh.material.dispose(), (_f2 = (_e = this.mesh2) == null ? void 0 : _e.material) == null ? void 0 : _f2.dispose(), this.text.dispose(), this.text2.dispose();
  }
}
var sf = ((s) => (s.normals = "normals", s.shearsY = "shearsY", s.shearsZ = "shearsZ", s.torsions = "torsions", s.bendingsY = "bendingsY", s.bendingsZ = "bendingsZ", s))(sf || {});
function aM(s, e, t, i) {
  const n = new Bt(), r = 0.05 * e.gridSize.rawVal, o = { normals: So, shearsY: So, shearsZ: So, torsions: So, bendingsY: Zd, bendingsZ: Zd };
  return De.derive(() => {
    var _a2, _b2;
    if (e.deformedShape.val, e.elementResults.val == "none") return;
    n.children.forEach((l) => l.dispose()), n.clear();
    const a = sf[e.elementResults.rawVal];
    (_b2 = (_a2 = s.analyzeOutputs) == null ? void 0 : _a2.val[a]) == null ? void 0 : _b2.forEach((l, c) => {
      var _a3, _b3;
      const h = ((_a3 = s.elements) == null ? void 0 : _a3.rawVal[c]) ?? [0, 1], d = t.rawVal[h[0]], u = t.rawVal[h[1]], f = new I(...u).distanceTo(new I(...d)), m = lM((_b3 = s.analyzeOutputs) == null ? void 0 : _b3.rawVal[a]), _ = l == null ? void 0 : l.map((y) => y / (m === 0 ? 1 : m)), g = nf(d, u), v = new o[a](d, u, f, g, l ?? [0, 0], _ ?? [0, 0], !!["normals", "shearsZ", "torsions", "bendingsY"].includes(a));
      v.updateScale(r * i.rawVal), n.add(v);
    });
  }), De.derive(() => {
    i.val, e.elementResults.rawVal != "none" && n.children.forEach((a) => a.updateScale(r * i.rawVal));
  }), De.derive(() => {
    n.visible = e.elementResults.val != "none";
  }), n;
}
function lM(s) {
  let e = 0;
  return s == null ? void 0 : s.forEach((t) => {
    const i = Math.max(...t ?? [0, 0]);
    i > e && (e = i);
  }), e;
}
class cM extends Bt {
  constructor(e, t, i) {
    super();
    const n = t === Qc.reactions;
    i[0] && (this.xText1 = new jt(`${n ? "Fx" : "Dx"}: ` + i[0].toFixed(4))), i[3] && (this.xText2 = new jt(`${n ? "Mx" : "Rx"}: ` + i[3].toFixed(4))), i[1] && (this.yText1 = new jt(`${n ? "Fy" : "Dy"}: ` + i[1].toFixed(4))), i[4] && (this.yText2 = new jt(`${n ? "My" : "Ry"}: ` + i[4].toFixed(4))), i[2] && (this.zText1 = new jt(`${n ? "Fz" : "Dz"}: ` + i[2].toFixed(4))), i[5] && (this.zText2 = new jt(`${n ? "Mz" : "Rz"}: ` + i[5].toFixed(4))), (i[0] || i[3]) && (this.xArrow = new Nn(new I(1, 0, 0), new I(0, 0, 0), 1, 15637248, 0.3, 0.3)), (i[1] || i[4]) && (this.yArrow = new Nn(new I(0, 1, 0), new I(0, 0, 0), 1, 15637248, 0.3, 0.3)), (i[2] || i[5]) && (this.zArrow = new Nn(new I(0, 0, 1), new I(0, 0, 0), 1, 15637248, 0.3, 0.3)), this.position.set(...e), this.xArrow && this.add(this.xArrow), this.yArrow && this.add(this.yArrow), this.zArrow && this.add(this.zArrow), this.xText1 && this.add(this.xText1), this.xText2 && this.add(this.xText2), this.yText1 && this.add(this.yText1), this.yText2 && this.add(this.yText2), this.zText1 && this.add(this.zText1), this.zText2 && this.add(this.zText2);
  }
  updateScale(e) {
    var _a2, _b2, _c2, _d2, _e, _f2, _g2, _h2, _i2, _j, _k, _l2, _m2, _n, _o2;
    (_a2 = this.xArrow) == null ? void 0 : _a2.scale.set(e, e, e), (_b2 = this.yArrow) == null ? void 0 : _b2.scale.set(e, e, e), (_c2 = this.zArrow) == null ? void 0 : _c2.scale.set(e, e, e), (_d2 = this.xText1) == null ? void 0 : _d2.position.set(1.3 * e, 0, 0), (_e = this.xText2) == null ? void 0 : _e.position.set(1.3 * e, 0, 0.5 * e), (_f2 = this.yText1) == null ? void 0 : _f2.position.set(0, 1.3 * e, 0), (_g2 = this.yText2) == null ? void 0 : _g2.position.set(0, 1.3 * e, 0.5 * e), (_h2 = this.zText1) == null ? void 0 : _h2.position.set(0, 0, 1.3 * e), (_i2 = this.zText2) == null ? void 0 : _i2.position.set(0, 0, 1.3 * e + 0.5 * e), (_j = this.xText1) == null ? void 0 : _j.updateScale(0.4 * e), (_k = this.xText2) == null ? void 0 : _k.updateScale(0.4 * e), (_l2 = this.yText1) == null ? void 0 : _l2.updateScale(0.4 * e), (_m2 = this.yText2) == null ? void 0 : _m2.updateScale(0.4 * e), (_n = this.zText1) == null ? void 0 : _n.updateScale(0.4 * e), (_o2 = this.zText2) == null ? void 0 : _o2.updateScale(0.4 * e);
  }
  dispose() {
    var _a2, _b2, _c2, _d2, _e, _f2, _g2, _h2, _i2;
    (_a2 = this.xArrow) == null ? void 0 : _a2.dispose(), (_b2 = this.yArrow) == null ? void 0 : _b2.dispose(), (_c2 = this.zArrow) == null ? void 0 : _c2.dispose(), (_d2 = this.xText1) == null ? void 0 : _d2.dispose(), (_e = this.xText2) == null ? void 0 : _e.dispose(), (_f2 = this.yText1) == null ? void 0 : _f2.dispose(), (_g2 = this.yText2) == null ? void 0 : _g2.dispose(), (_h2 = this.zText1) == null ? void 0 : _h2.dispose(), (_i2 = this.zText2) == null ? void 0 : _i2.dispose();
  }
}
var Qc = ((s) => (s.deformations = "deformations", s.reactions = "reactions", s))(Qc || {});
function hM(s, e, t, i) {
  const n = new Bt(), r = 0.05 * e.gridSize.rawVal;
  return De.derive(() => {
    var _a2, _b2;
    if (e.deformedShape.val, e.nodeResults.val == "none") return;
    n.children.forEach((a) => a.dispose()), n.clear();
    const o = Qc[e.nodeResults.rawVal];
    (_b2 = (_a2 = s.deformOutputs) == null ? void 0 : _a2.val[o]) == null ? void 0 : _b2.forEach((a, l) => {
      const c = new cM(t.rawVal[l], o, a ?? [0, 0, 0, 0, 0, 0]);
      c.updateScale(r * i.rawVal), n.add(c);
    });
  }), De.derive(() => {
    i.val, e.nodeResults.rawVal != "none" && n.children.forEach((o) => o.updateScale(r * i.rawVal));
  }), De.derive(() => {
    n.visible = e.nodeResults.val != "none";
  }), n;
}
function dM({ drawingObj: s, gridObj: e, scene: t, camera: i, controls: n, gridSize: r, derivedDisplayScale: o, viewerRender: a }) {
  const l = new ax(), c = new re(), h = new Ut(new Tr(r, r), new Fi({ side: Yt })), d = new Kl(new ft(), new Xo()), u = new Kl(new ft(), new Xo({ color: "gray" }));
  d.geometry.setAttribute("position", new lt(s.points.rawVal.flat(), 3)), d.geometry.computeBoundingSphere(), d.frustumCulled = false, u.frustumCulled = false, t.add(u), h.position.set(0.5 * r, 0.5 * r, 0), h.rotateX(Math.PI / 2), h.geometry.rotateX(Math.PI / 2), h.updateMatrixWorld(), s.polylines && (s.polylines.val = [...s.polylines.rawVal, []]), De.derive(() => {
    s.gridTarget && (uM(e, { position: new I(...s.gridTarget.val.position), quaternion: new un().setFromEuler(new di(...s.gridTarget.val.rotation)) }, a), h.position.set(...s.gridTarget.val.position), h.quaternion.setFromEuler(new di(...s.gridTarget.val.rotation)), h.updateMatrixWorld());
  }), De.derive(() => {
    d.geometry.setAttribute("position", new lt(s.points.val.flat(), 3)), d.geometry.computeBoundingSphere();
  }), De.derive(() => {
    const v = 0.05 * r * 0.5 * o.val;
    u.material.size = v, l.params.Points.threshold = 0.4 * v;
  });
  let f = false, m = 0;
  window.addEventListener("pointerdown", () => {
    f = true;
  }), window.addEventListener("pointerup", () => {
    f = false;
  }), window.addEventListener("pointermove", () => {
    f && m++;
  }), window.addEventListener("click", (v) => {
    if (m > 5) {
      m = 0;
      return;
    }
    m = 0, c.x = v.clientX / window.innerWidth * 2 - 1, c.y = -(v.clientY / window.innerHeight) * 2 + 1, l.setFromCamera(c, i);
    const y = l.intersectObject(h);
    if (y.length) {
      let x = y[0].point;
      v.ctrlKey && (x = new I(Math.round(y[0].point.x), Math.round(y[0].point.y), Math.round(y[0].point.z))), s.points.val = [...s.points.rawVal, x.toArray()], s.polylines && (s.polylines.val = [...s.polylines.rawVal.slice(0, -1), [...s.polylines.rawVal.length ? s.polylines.rawVal.pop() : [], s.points.rawVal.length - 1]]);
    }
  }), window.addEventListener("contextmenu", () => {
    !s.polylines || s.polylines.rawVal[s.polylines.rawVal.length - 1].length === 0 || (s.polylines.val = [...s.polylines.rawVal, []]);
  }), window.addEventListener("pointermove", (v) => {
    c.x = v.clientX / window.innerWidth * 2 - 1, c.y = -(v.clientY / window.innerHeight) * 2 + 1, l.setFromCamera(c, i);
    const y = l.intersectObject(h);
    if (u.geometry.deleteAttribute("position"), y.length) {
      let x = y[0].point;
      v.ctrlKey && (x = new I(Math.round(y[0].point.x), Math.round(y[0].point.y), Math.round(y[0].point.z))), u.geometry.setAttribute("position", new lt(x.toArray(), 3));
    }
    a();
  }), window.addEventListener("pointermove", (v) => {
    var _a2;
    c.x = v.clientX / window.innerWidth * 2 - 1, c.y = -(v.clientY / window.innerHeight) * 2 + 1, l.setFromCamera(c, i);
    let y = false;
    const x = l.intersectObject(d), S = l.intersectObject(h);
    if (x.length && S.length) {
      const A = new I(...s.points.rawVal[x[0].index]), R = new I(...S[0].point), C = A.sub(R), P = (_a2 = S[0].face) == null ? void 0 : _a2.normal;
      P.transformDirection(h.matrixWorld), Math.abs(C.dot(P)) < 1e-4 && (y = true);
    }
    u.visible = !y;
  });
  let _ = false, g;
  window.addEventListener("pointermove", (v) => {
    var _a2;
    if (!m) return;
    c.x = v.clientX / window.innerWidth * 2 - 1, c.y = -(v.clientY / window.innerHeight) * 2 + 1, l.setFromCamera(c, i);
    let y = false;
    const x = l.intersectObject(d), S = l.intersectObject(h);
    if (x.length && S.length) {
      const R = new I(...s.points.rawVal[x[0].index]), C = new I(...S[0].point), P = R.sub(C), z = (_a2 = S[0].face) == null ? void 0 : _a2.normal;
      z.transformDirection(h.matrixWorld), Math.abs(P.dot(z)) < 1e-4 && (y = true);
    }
    if (y && m < 5 && (_ = true, n.enabled = false, g = x[0].index), !_ || m % 2 !== 0) return;
    const A = [...s.points.rawVal];
    g !== void 0 && (A[g] = S[0].point.toArray()), s.points.val = A;
  }), window.addEventListener("pointerup", () => {
    n.enabled = true, _ = false;
  }), window.addEventListener("contextmenu", (v) => {
    var _a2;
    c.x = v.clientX / window.innerWidth * 2 - 1, c.y = -(v.clientY / window.innerHeight) * 2 + 1, l.setFromCamera(c, i);
    let y = false;
    const x = l.intersectObject(d), S = l.intersectObject(h);
    if (x.length && S.length) {
      const C = new I(...s.points.rawVal[x[0].index]), P = new I(...S[0].point), z = C.sub(P), w = (_a2 = S[0].face) == null ? void 0 : _a2.normal;
      w.transformDirection(h.matrixWorld), Math.abs(z.dot(w)) < 1e-4 && (y = true);
    }
    if (!y) return;
    const A = [...s.points.rawVal];
    if (A.splice(x[0].index, 1), s.points.val = A, !s.polylines) return;
    const R = s.polylines.rawVal.map((C) => C.filter((P) => P !== x[0].index)).map((C) => C.map((P) => P > x[0].index ? P - 1 : P)).filter((C) => C.length);
    R.push([]), s.polylines.val = R;
  });
}
function uM(s, e, t) {
  const r = Math.round(14.999999999999998), o = { position: s.position.clone(), quaternion: s.quaternion.clone() }, a = setInterval(c, 1e3 / 30);
  let l = 0;
  function c() {
    l++;
    const h = l / r;
    s.position.lerpVectors(o.position, e.position, h), s.quaternion.slerpQuaternions(o.quaternion, e.quaternion, h), t && t(), l == r && clearInterval(a);
  }
}
function kM({ mesh: s, settingsObj: e, drawingObj: t, objects3D: i, solids: n }) {
  yt.DEFAULT_UP = new I(0, 0, 1);
  const r = document.createElement("div"), o = new wb(), a = new ai(45, 1, 0.1, 2 * 1e6), l = new xb({ antialias: true }), c = new dx(a, l.domElement), h = pM(e), d = De.derive(() => h.displayScale.val === 0 ? 1 : h.displayScale.val > 0 ? h.displayScale.val : -1 / h.displayScale.val), u = fM(s, h), f = ZE(h.gridSize.rawVal);
  r.appendChild(jE(h, s, n)), r.setAttribute("id", "viewer"), r.appendChild(l.domElement), l.setPixelRatio(window.devicePixelRatio), l.setClearColor(0, 1);
  const m = h.gridSize.rawVal, _ = m * 0.5 + m * 0.5 / Math.tan(45 * 0.5);
  a.position.set(0.5 * m, 0.8 * -_, 0.5 * m), c.target.set(0.5 * m, 0.5 * m, 0), c.minDistance = 1, c.maxDistance = _ * 2.5, c.zoomSpeed = 10, c.update(), o.add(f, sM(h.gridSize.rawVal, h.flipAxes.rawVal)), new ResizeObserver((y) => {
    var _a2, _b2;
    for (const x of y) {
      const S = (_a2 = x.target) == null ? void 0 : _a2.clientWidth, A = (_b2 = x.target) == null ? void 0 : _b2.clientHeight;
      a.aspect = S / A, a.updateProjectionMatrix(), l.setSize(S, A), v();
    }
  }).observe(r), c.addEventListener("change", v), De.derive(() => {
    var _a2, _b2, _c2, _d2, _e, _f2;
    (_a2 = s == null ? void 0 : s.nodes) == null ? void 0 : _a2.val, (_b2 = s == null ? void 0 : s.elements) == null ? void 0 : _b2.val, (_c2 = s == null ? void 0 : s.nodeInputs) == null ? void 0 : _c2.val, (_d2 = s == null ? void 0 : s.elementInputs) == null ? void 0 : _d2.val, (_e = s == null ? void 0 : s.deformOutputs) == null ? void 0 : _e.val, (_f2 = s == null ? void 0 : s.analyzeOutputs) == null ? void 0 : _f2.val, h.displayScale.val, h.nodes.val, h.elements.val, h.nodesIndexes.val, h.elementsIndexes.val, h.orientations.val, h.supports.val, h.loads.val, h.deformedShape.val, h.elementResults.val, h.nodeResults.val, setTimeout(v);
  });
  function v() {
    l.render(o, a);
  }
  if (n) {
    const y = new ox(16777215, 0.5);
    o.add(y);
    const x = new bd(16777215, 0.5);
    x.position.set(30, 25, -10), x.shadow.mapSize.width = 1024, x.shadow.mapSize.height = 1024, o.add(x);
    const S = 10;
    x.shadow.camera.left = -10, x.shadow.camera.right = S, x.shadow.camera.top = S, x.shadow.camera.bottom = -10, x.shadow.camera.far = 1e3;
    const A = new bd(16777215, 0.5);
    A.color.setHSL(11, 43, 96), A.position.set(-10, 0, 30), o.add(A), De.derive(() => {
      (n == null ? void 0 : n.val.length) && (o.remove(...n.oldVal), o.add(...n.rawVal), v());
    }), De.derive(() => {
      n.rawVal.forEach((R) => R.visible = h.solids.val), v();
    });
  }
  return i && De.derive(() => {
    (i == null ? void 0 : i.val.length) && (o.remove(...i.oldVal), o.add(...i.rawVal), v());
  }), s && o.add(YE(h, u, d), qE(s, h, u), tM(h, u, d), iM(s, h, u, d), JE(s, h, u, d), QE(s, h, u, d), oM(s, h, u, d), aM(s, h, u, d), hM(s, h, u, d)), t && dM({ drawingObj: t, gridObj: f, scene: o, camera: a, controls: c, gridSize: m, derivedDisplayScale: d, viewerRender: v }), r;
}
function pM(s) {
  return { gridSize: De.state((s == null ? void 0 : s.gridSize) ?? 20), displayScale: De.state((s == null ? void 0 : s.displayScale) ?? 1), nodes: De.state((s == null ? void 0 : s.nodes) ?? true), elements: De.state((s == null ? void 0 : s.elements) ?? true), nodesIndexes: De.state((s == null ? void 0 : s.nodesIndexes) ?? false), elementsIndexes: De.state((s == null ? void 0 : s.elementsIndexes) ?? false), orientations: De.state((s == null ? void 0 : s.orientations) ?? false), supports: De.state((s == null ? void 0 : s.supports) ?? true), loads: De.state((s == null ? void 0 : s.loads) ?? true), deformedShape: De.state((s == null ? void 0 : s.deformedShape) ?? false), elementResults: De.state((s == null ? void 0 : s.elementResults) ?? "none"), nodeResults: De.state((s == null ? void 0 : s.nodeResults) ?? "none"), flipAxes: De.state((s == null ? void 0 : s.flipAxes) ?? false), solids: De.state((s == null ? void 0 : s.solids) ?? true) };
}
function fM(s, e) {
  return De.derive(() => {
    var _a2, _b2;
    return e.deformedShape.val ? ((_a2 = s == null ? void 0 : s.nodes) == null ? void 0 : _a2.val.map((t, i) => {
      var _a3, _b3, _c2;
      const n = ((_c2 = (_b3 = (_a3 = s == null ? void 0 : s.deformOutputs) == null ? void 0 : _a3.val.deformations) == null ? void 0 : _b3.get(i)) == null ? void 0 : _c2.slice(0, 3)) ?? [0, 0, 0];
      return t.map((r, o) => r + n[o]);
    })) ?? [] : ((_b2 = s == null ? void 0 : s.nodes) == null ? void 0 : _b2.val) ?? [];
  });
}
class Jd {
  constructor(e, t) {
    Object.assign(this, { type: t.type ?? null, detail: t, owner: e, target: t.target ?? null, phase: t.phase ?? "before", object: t.object ?? null, execute: null, isStopped: false, isCancelled: false, onComplete: null, listeners: [] }), delete t.type, delete t.target, delete t.object, this.complete = new Promise((i, n) => {
      this._resolve = i, this._reject = n;
    }), this.complete.catch(() => {
    });
  }
  finish(e) {
    e && b.extend(this.detail, e), this.phase = "after", this.owner.trigger.call(this.owner, this);
  }
  done(e) {
    this.listeners.push(e);
  }
  preventDefault() {
    this._reject(), this.isCancelled = true;
  }
  stopPropagation() {
    this.isStopped = true;
  }
}
class Xn {
  constructor(e) {
    if (this.activeEvents = [], this.listeners = [], e !== void 0) {
      if (!b.checkName(e)) return;
      on[e] = this;
    }
    this.debug = false;
  }
  on(e, t) {
    return (e = typeof e == "string" ? e.split(/[,\s]+/) : [e]).forEach((i) => {
      var n, r, o, a = typeof i == "string" ? i : i.type + ":" + i.execute + "." + i.scope;
      typeof i == "string" && ([r, n] = i.split("."), [r, o] = r.replace(":complete", ":after").replace(":done", ":after").split(":"), i = { type: r, execute: o ?? "before", scope: n }), (i = b.extend({ type: null, execute: "before", onComplete: null }, i)).type ? t ? (Array.isArray(this.listeners) || (this.listeners = []), this.listeners.push({ name: a, edata: i, handler: t }), this.debug && console.log("w2base: add event", { name: a, edata: i, handler: t })) : console.log("ERROR: You must specify event handler function when calling .on() method of " + this.name) : console.log("ERROR: You must specify event type when calling .on() method of " + this.name);
    }), this;
  }
  off(e, t) {
    return (e = typeof e == "string" ? e.split(/[,\s]+/) : [e]).forEach((i) => {
      var n, r, o, a = typeof i == "string" ? i : i.type + ":" + i.execute + "." + i.scope;
      if (typeof i == "string" && ([r, n] = i.split("."), [r, o] = r.replace(":complete", ":after").replace(":done", ":after").split(":"), i = { type: r || "*", execute: o || "", scope: n || "" }), (i = b.extend({ type: null, execute: null, onComplete: null }, i)).type || i.scope) {
        t = t || null;
        let l = 0;
        this.listeners = this.listeners.filter((c) => i.type !== "*" && i.type !== c.edata.type || i.execute !== "" && i.execute !== c.edata.execute || i.scope !== "" && i.scope !== c.edata.scope || i.handler != null && i.handler !== c.edata.handler || (l++, false)), this.debug && console.log(`w2base: remove event (${l})`, { name: a, edata: i, handler: t });
      } else console.log("ERROR: You must specify event type when calling .off() method of " + this.name);
    }), this;
  }
  trigger(e, t) {
    if (arguments.length == 1 ? t = e : (t.type = e, t.target = t.target ?? this), b.isPlainObject(t) && t.phase == "after") {
      if (!(t = this.activeEvents.find((o) => o.type == t.type && o.target == t.target))) return void console.log(`ERROR: Cannot find even handler for "${t.type}" on "${t.target}".`);
      console.log(`NOTICE: This syntax "edata.trigger({ phase: 'after' })" is outdated. Use edata.finish() instead.`);
    } else t instanceof Jd || (t = new Jd(this, t), this.activeEvents.push(t));
    let i, n, r;
    Array.isArray(this.listeners) || (this.listeners = []), this.debug && console.log(`w2base: trigger "${t.type}:${t.phase}"`, t);
    for (let o = this.listeners.length - 1; 0 <= o; o--) {
      let a = this.listeners[o];
      if (!(a == null || a.edata.type !== t.type && a.edata.type !== "*" || a.edata.target !== t.target && a.edata.target != null || a.edata.execute !== t.phase && a.edata.execute !== "*" && a.edata.phase !== "*") && (Object.keys(a.edata).forEach((l) => {
        t[l] == null && a.edata[l] != null && (t[l] = a.edata[l]);
      }), i = [], r = new RegExp(/\((.*?)\)/).exec(String(a.handler).split("=>")[0]), (i = r ? r[1].split(/\s*,\s*/) : i).length === 2 ? (a.handler.call(this, t.target, t), this.debug && console.log(" - call (old)", a.handler)) : (a.handler.call(this, t), this.debug && console.log(" - call", a.handler)), t.isStopped === true || t.stop === true)) return t;
    }
    if (e = "on" + t.type.substr(0, 1).toUpperCase() + t.type.substr(1), !(t.phase === "before" && typeof this[e] == "function" && (n = this[e], i = [], r = new RegExp(/\((.*?)\)/).exec(String(n).split("=>")[0]), (i = r ? r[1].split(/\s*,\s*/) : i).length === 2 ? (n.call(this, t.target, t), this.debug && console.log(" - call: on[Event] (old)", n)) : (n.call(this, t), this.debug && console.log(" - call: on[Event]", n)), t.isStopped === true || t.stop === true) || t.object != null && t.phase === "before" && typeof t.object[e] == "function" && (n = t.object[e], i = [], r = new RegExp(/\((.*?)\)/).exec(String(n).split("=>")[0]), (i = r ? r[1].split(/\s*,\s*/) : i).length === 2 ? (n.call(this, t.target, t), this.debug && console.log(" - call: edata.object (old)", n)) : (n.call(this, t), this.debug && console.log(" - call: edata.object", n)), t.isStopped === true || t.stop === true) || t.phase !== "after")) {
      typeof t.onComplete == "function" && t.onComplete.call(this, t);
      for (let o = 0; o < t.listeners.length; o++) typeof t.listeners[o] == "function" && (t.listeners[o].call(this, t), this.debug) && console.log(" - call: done", n);
      t._resolve(t), this.debug && console.log(`w2base: trigger "${t.type}:${t.phase}"`, t);
    }
    return t;
  }
}
const sl = { locale: "en-US", dateFormat: "m/d/yyyy", timeFormat: "hh:mi pm", datetimeFormat: "m/d/yyyy|hh:mi pm", currencyPrefix: "$", currencySuffix: "", currencyPrecision: 2, groupSymbol: ",", decimalSymbol: ".", shortmonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], fullmonths: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortdays: ["M", "T", "W", "T", "F", "S", "S"], fulldays: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], weekStarts: "S", phrases: { "${count} letters or more...": "---", "Add new record": "---", "Add New": "---", "Advanced Search": "---", after: "---", "AJAX error. See console for more details.": "---", "All Fields": "---", All: "---", Any: "---", "Are you sure you want to delete ${count} ${records}?": "---", "Attach files by dragging and dropping or Click to Select": "---", before: "---", "begins with": "---", begins: "---", between: "---", buffered: "---", Cancel: "---", Close: "---", Column: "---", Confirmation: "---", contains: "---", Copied: "---", "Copy to clipboard": "---", "Current Date & Time": "---", "Delete selected records": "---", Delete: "---", 'Do you want to delete search item "${item}"?': "---", "Edit selected record": "---", Edit: "---", "Empty list": "---", "ends with": "---", ends: "---", "Field should be at least ${count} characters.": "---", Hide: "---", in: "---", "is not": "---", is: "---", "less than": "---", "Line #": "---", "Load ${count} more...": "---", "Loading...": "---", "Maximum number of files is ${count}": "---", "Maximum total size is ${count}": "---", Modified: "---", "more than": "---", "Multiple Fields": "---", Name: "---", "No items found": "---", "No matches": "---", No: "---", none: "---", "Not a float": "---", "Not a hex number": "---", "Not a valid date": "---", "Not a valid email": "---", "Not alpha-numeric": "---", "Not an integer": "---", "Not in money format": "---", "not in": "---", Notification: "---", of: "---", Ok: "---", Opacity: "---", "Record ID": "---", record: "---", records: "---", "Refreshing...": "---", "Reload data in the list": "---", Remove: "---", "Remove This Field": "---", "Request aborted.": "---", "Required field": "---", Reset: "---", "Restore Default State": "---", "Returned data is not in valid JSON format.": "---", "Save changed records": "---", "Save Grid State": "---", Save: "---", "Saved Searches": "---", "Saving...": "---", "Search took ${count} seconds": "---", Search: "---", "Select Hour": "---", "Select Minute": "---", selected: "---", "Server Response ${count} seconds": "---", "Show/hide columns": "---", Show: "---", Size: "---", Skip: "---", "Sorting took ${count} seconds": "---", "Type to search...": "---", Type: "---", Yes: "---", Yesterday: "---", "Your remote data source record count has changed, reloading from the first record.": "---" } };
const _ut = class _ut {
  constructor(e, t, i) {
    this.context = t ?? document, this.previous = i ?? null;
    let n = [];
    if (Array.isArray(e)) n = e;
    else if (e instanceof Node || e instanceof Window) n = [e];
    else if (e instanceof _ut) n = e.nodes;
    else if (typeof e == "string") {
      if (typeof this.context.querySelector != "function") throw new Error("Invalid context");
      n = Array.from(this.context.querySelectorAll(e));
    } else if (e == null) n = [];
    else {
      if (t = Array.from(e ?? []), typeof e != "object" || !Array.isArray(t)) throw new Error(`Invalid selector "${e}"`);
      n = t;
    }
    this.nodes = n, this.length = n.length, this.each((r, o) => {
      this[o] = r;
    });
  }
  static _fragment(e) {
    let t = document.createElement("template");
    return t.innerHTML = e, t.content.childNodes.forEach((i) => {
      var n = _ut._scriptConvert(i);
      n != i && t.content.replaceChild(n, i);
    }), t.content;
  }
  static _scriptConvert(e) {
    let t = (i) => {
      var n = i.ownerDocument.createElement("script"), r = (n.text = i.text, i.attributes);
      for (let o = 0; o < r.length; o++) n.setAttribute(r[o].name, r[o].value);
      return n;
    };
    return (e = e.tagName == "SCRIPT" ? t(e) : e).querySelectorAll && e.querySelectorAll("script").forEach((i) => {
      i.parentNode.replaceChild(t(i), i);
    }), e;
  }
  static _fixProp(e) {
    var t = { cellpadding: "cellPadding", cellspacing: "cellSpacing", class: "className", colspan: "colSpan", contenteditable: "contentEditable", for: "htmlFor", frameborder: "frameBorder", maxlength: "maxLength", readonly: "readOnly", rowspan: "rowSpan", tabindex: "tabIndex", usemap: "useMap" };
    return t[e] || e;
  }
  _insert(e, t) {
    let i = [], n = this.length;
    if (!(n < 1)) {
      let r = this;
      if (typeof t == "string") this.each((o) => {
        var a = _ut._fragment(t);
        i.push(...a.childNodes), o[e](a);
      });
      else if (t instanceof _ut) {
        let o = n == 1;
        t.each((a) => {
          this.each((l) => {
            var c = o ? a : a.cloneNode(true);
            i.push(c), l[e](c), _ut._scriptConvert(c);
          });
        }), o || t.remove();
      } else {
        if (!(t instanceof Node)) throw new Error(`Incorrect argument for "${e}(html)". It expects one string argument.`);
        this.each((o) => {
          var a = n === 1 ? t : _ut._fragment(t.outerHTML);
          i.push(...n === 1 ? [t] : a.childNodes), o[e](a);
        }), 1 < n && t.remove();
      }
      return r = e == "replaceWith" ? new _ut(i, this.context, this) : r;
    }
  }
  _save(e, t, i) {
    e._mQuery = e._mQuery ?? {}, Array.isArray(i) ? (e._mQuery[t] = e._mQuery[t] ?? [], e._mQuery[t].push(...i)) : i != null ? e._mQuery[t] = i : delete e._mQuery[t];
  }
  get(e) {
    var t = this[e = e < 0 ? this.length + e : e];
    return t || (e != null ? null : this.nodes);
  }
  eq(e) {
    let t = [this[e = e < 0 ? this.length + e : e]];
    return t[0] == null && (t = []), new _ut(t, this.context, this);
  }
  then(e) {
    return e = e(this), e ?? this;
  }
  find(e) {
    let t = [];
    return this.each((i) => {
      i = Array.from(i.querySelectorAll(e)), 0 < i.length && t.push(...i);
    }), new _ut(t, this.context, this);
  }
  filter(e) {
    let t = [];
    return this.each((i) => {
      (i === e || typeof e == "string" && i.matches && i.matches(e) || typeof e == "function" && e(i)) && t.push(i);
    }), new _ut(t, this.context, this);
  }
  next() {
    let e = [];
    return this.each((t) => {
      t = t.nextElementSibling, t && e.push(t);
    }), new _ut(e, this.context, this);
  }
  prev() {
    let e = [];
    return this.each((t) => {
      t = t.previousElementSibling, t && e.push(t);
    }), new _ut(e, this.context, this);
  }
  shadow(e) {
    let t = [];
    this.each((n) => {
      n.shadowRoot && t.push(n.shadowRoot);
    });
    var i = new _ut(t, this.context, this);
    return e ? i.find(e) : i;
  }
  closest(e) {
    let t = [];
    return this.each((i) => {
      i = i.closest(e), i && t.push(i);
    }), new _ut(t, this.context, this);
  }
  host(e) {
    let t = [], i = (r) => r.parentNode ? i(r.parentNode) : r, n = (r) => {
      r = i(r), t.push(r.host || r), r.host && e && n(r.host);
    };
    return this.each((r) => {
      n(r);
    }), new _ut(t, this.context, this);
  }
  parent(e) {
    return this.parents(e, true);
  }
  parents(e, t) {
    let i = [], n = (o) => {
      if (i.indexOf(o) == -1 && i.push(o), !t && o.parentNode) return n(o.parentNode);
    };
    this.each((o) => {
      o.parentNode && n(o.parentNode);
    });
    var r = new _ut(i, this.context, this);
    return e ? r.filter(e) : r;
  }
  add(e) {
    return e = e instanceof _ut ? e.nodes : Array.isArray(e) ? e : [e], new _ut(this.nodes.concat(e), this.context, this);
  }
  each(e) {
    return this.nodes.forEach((t, i) => {
      e(t, i, this);
    }), this;
  }
  append(e) {
    return this._insert("append", e);
  }
  prepend(e) {
    return this._insert("prepend", e);
  }
  after(e) {
    return this._insert("after", e);
  }
  before(e) {
    return this._insert("before", e);
  }
  replace(e) {
    return this._insert("replaceWith", e);
  }
  remove() {
    return this.each((e) => {
      e.remove();
    }), this;
  }
  css(e, t) {
    let i = e;
    var n, r = arguments.length;
    return r === 0 || r === 1 && typeof e == "string" ? this[0] ? (r = this[0].style, typeof e == "string" ? (n = r.getPropertyPriority(e), r.getPropertyValue(e) + (n ? "!" + n : "")) : Object.fromEntries(this[0].style.cssText.split(";").filter((o) => !!o).map((o) => o.split(":").map((a) => a.trim())))) : void 0 : (typeof e != "object" && ((i = {})[e] = t), this.each((o, a) => {
      Object.keys(i).forEach((l) => {
        var c = String(i[l]).toLowerCase().includes("!important") ? "important" : "";
        o.style.setProperty(l, String(i[l]).replace(/\!important/i, ""), c);
      });
    }), this);
  }
  addClass(e) {
    return this.toggleClass(e, true), this;
  }
  removeClass(e) {
    return this.toggleClass(e, false), this;
  }
  toggleClass(e, t) {
    return typeof e == "string" && (e = e.split(/[,\s]+/)), this.each((i) => {
      let n = e;
      (n = n == null && t === false ? Array.from(i.classList) : n).forEach((r) => {
        if (r !== "") {
          let o = t != null ? t ? "add" : "remove" : "toggle";
          i.classList[o](r);
        }
      });
    }), this;
  }
  hasClass(e) {
    if ((e = typeof e == "string" ? e.split(/[,\s]+/) : e) == null && 0 < this.length) return Array.from(this[0].classList);
    let t = false;
    return this.each((i) => {
      t = t || e.every((n) => Array.from(i.classList ?? []).includes(n));
    }), t;
  }
  on(e, t, i) {
    typeof t == "function" && (i = t, t = void 0);
    let n;
    return (t == null ? void 0 : t.delegate) && (n = t.delegate, delete t.delegate), (e = e.split(/[,\s]+/)).forEach((r) => {
      let [o, a] = String(r).toLowerCase().split(".");
      if (n) {
        let l = i;
        i = (c) => {
          var h = p(c.target).parents(n);
          0 < h.length ? c.delegate = h[0] : c.delegate = c.target, (c.target.matches(n) || 0 < h.length) && l(c);
        };
      }
      this.each((l) => {
        this._save(l, "events", [{ event: o, scope: a, callback: i, options: t }]), l.addEventListener(o, i, t);
      });
    }), this;
  }
  off(e, t, i) {
    return typeof t == "function" && (i = t, t = void 0), (e = (e ?? "").split(/[,\s]+/)).forEach((n) => {
      let [r, o] = String(n).toLowerCase().split(".");
      this.each((a) => {
        var _a2;
        if (Array.isArray((_a2 = a._mQuery) == null ? void 0 : _a2.events)) for (let c = a._mQuery.events.length - 1; 0 <= c; c--) {
          var l = a._mQuery.events[c];
          o == null || o === "" ? l.event != r && r !== "" || l.callback != i && i != null || (a.removeEventListener(l.event, l.callback, l.options), a._mQuery.events.splice(c, 1)) : l.event != r && r !== "" || l.scope != o || (a.removeEventListener(l.event, l.callback, l.options), a._mQuery.events.splice(c, 1));
        }
      });
    }), this;
  }
  trigger(e, t) {
    let i;
    return i = e instanceof Event || e instanceof CustomEvent ? e : new (["click", "dblclick", "mousedown", "mouseup", "mousemove"].includes(e) ? MouseEvent : ["keydown", "keyup", "keypress"].includes(e) ? KeyboardEvent : Event)(e, t), this.each((n) => {
      n.dispatchEvent(i);
    }), this;
  }
  attr(e, t) {
    if (t === void 0 && typeof e == "string") return this[0] ? this[0].getAttribute(e) : void 0;
    {
      let i = {};
      return typeof e == "object" ? i = e : i[e] = t, this.each((n) => {
        Object.entries(i).forEach(([r, o]) => {
          n.setAttribute(r, o);
        });
      }), this;
    }
  }
  removeAttr() {
    return this.each((e) => {
      Array.from(arguments).forEach((t) => {
        e.removeAttribute(t);
      });
    }), this;
  }
  prop(e, t) {
    if (t === void 0 && typeof e == "string") return this[0] ? this[0][e] : void 0;
    {
      let i = {};
      return typeof e == "object" ? i = e : i[e] = t, this.each((n) => {
        Object.entries(i).forEach(([r, o]) => {
          r = _ut._fixProp(r), n[r] = o, r == "innerHTML" && _ut._scriptConvert(n);
        });
      }), this;
    }
  }
  removeProp() {
    return this.each((e) => {
      Array.from(arguments).forEach((t) => {
        delete e[_ut._fixProp(t)];
      });
    }), this;
  }
  data(e, t) {
    if (e instanceof Object) Object.entries(e).forEach((i) => {
      this.data(i[0], i[1]);
    });
    else {
      if (e && e.indexOf("-") != -1 && console.error(`Key "${e}" contains "-" (dash). Dashes are not allowed in property names. Use camelCase instead.`), !(arguments.length < 2)) return this.each((i) => {
        t != null ? i.dataset[e] = t instanceof Object ? JSON.stringify(t) : t : delete i.dataset[e];
      }), this;
      if (this[0]) {
        let i = Object.assign({}, this[0].dataset);
        return Object.keys(i).forEach((n) => {
          if (i[n].startsWith("[") || i[n].startsWith("{")) try {
            i[n] = JSON.parse(i[n]);
          } catch {
          }
        }), e ? i[e] : i;
      }
    }
  }
  removeData(e) {
    return typeof e == "string" && (e = e.split(/[,\s]+/)), this.each((t) => {
      e.forEach((i) => {
        delete t.dataset[i];
      });
    }), this;
  }
  show() {
    return this.toggle(true);
  }
  hide() {
    return this.toggle(false);
  }
  toggle(e) {
    return this.each((t) => {
      var _a2;
      var i, n = t.style.display, r = getComputedStyle(t).display, o = n == "none" || r == "none";
      !o || e != null && e !== true || (i = t instanceof HTMLTableRowElement ? "table-row" : t instanceof HTMLTableCellElement ? "table-cell" : "block", t.style.display = ((_a2 = t._mQuery) == null ? void 0 : _a2.prevDisplay) ?? (n == r && r != "none" ? "" : i), this._save(t, "prevDisplay", null)), o || e != null && e !== false || (r != "none" && this._save(t, "prevDisplay", r), t.style.setProperty("display", "none"));
    });
  }
  empty() {
    return this.html("");
  }
  html(e) {
    return this.prop("innerHTML", e);
  }
  text(e) {
    return this.prop("textContent", e);
  }
  val(e) {
    return this.prop("value", e);
  }
  change() {
    return this.trigger("change");
  }
  click() {
    return this.trigger("click");
  }
};
__publicField(_ut, "version", 0.7);
let ut = _ut;
let p = function(s, e) {
  if (typeof s != "function") return new ut(s, e);
  document.readyState == "complete" ? s() : window.addEventListener("load", s);
}, on = (p.html = (s) => (s = ut._fragment(s), p(s.children, s)), p.version = ut.version, {});
class mM {
  constructor() {
    this.version = "2.0.x", this.tmp = {}, this.settings = this.extend({}, { dataType: "HTTPJSON", dateStartYear: 1950, dateEndYear: 2030, macButtonOrder: false, warnNoPhrase: false }, sl, { phrases: null }), this.i18nCompare = Intl.Collator().compare, this.hasLocalStorage = function() {
      var e = "w2ui_test";
      try {
        return localStorage.setItem(e, e), localStorage.removeItem(e), true;
      } catch {
        return false;
      }
    }(), this.isMac = /Mac/i.test(navigator.platform), this.isMobile = /(iphone|ipod|ipad|mobile|android)/i.test(navigator.userAgent), this.isIOS = /(iphone|ipod|ipad)/i.test(navigator.platform), this.isAndroid = /(android)/i.test(navigator.userAgent), this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this.formatters = { number(e, t) {
      return 20 < parseInt(t) && (t = 20), parseInt(t) < 0 && (t = 0), e == null || e === "" ? "" : b.formatNumber(parseFloat(e), t, true);
    }, float(e, t) {
      return b.formatters.number(e, t);
    }, int(e, t) {
      return b.formatters.number(e, 0);
    }, money(e, t) {
      return e == null || e === "" ? "" : (e = b.formatNumber(Number(e), b.settings.currencyPrecision), (b.settings.currencyPrefix || "") + e + (b.settings.currencySuffix || ""));
    }, currency(e, t) {
      return b.formatters.money(e, t);
    }, percent(e, t) {
      return e == null || e === "" ? "" : b.formatNumber(e, t || 1) + "%";
    }, size(e, t) {
      return e == null || e === "" ? "" : b.formatSize(parseInt(e));
    }, date(e, t) {
      if (t === "" && (t = b.settings.dateFormat), e == null || e === 0 || e === "") return "";
      let i = b.isDateTime(e, t, true);
      return '<span title="' + (i = i === false ? b.isDate(e, t, true) : i) + '">' + b.formatDate(i, t) + "</span>";
    }, datetime(e, t) {
      if (t === "" && (t = b.settings.datetimeFormat), e == null || e === 0 || e === "") return "";
      let i = b.isDateTime(e, t, true);
      return '<span title="' + (i = i === false ? b.isDate(e, t, true) : i) + '">' + b.formatDateTime(i, t) + "</span>";
    }, time(e, t) {
      if (t === "" && (t = b.settings.timeFormat), e == null || e === 0 || e === "") return "";
      let i = b.isDateTime(e, t = (t = t === "h12" ? "hh:mi pm" : t) === "h24" ? "h24:mi" : t, true);
      return '<span title="' + (i = i === false ? b.isDate(e, t, true) : i) + '">' + b.formatTime(e, t) + "</span>";
    }, timestamp(e, t) {
      if (t === "" && (t = b.settings.datetimeFormat), e == null || e === 0 || e === "") return "";
      let i = b.isDateTime(e, t, true);
      return (i = i === false ? b.isDate(e, t, true) : i).toString ? i.toString() : "";
    }, gmt(e, t) {
      if (t === "" && (t = b.settings.datetimeFormat), e == null || e === 0 || e === "") return "";
      let i = b.isDateTime(e, t, true);
      return (i = i === false ? b.isDate(e, t, true) : i).toUTCString ? i.toUTCString() : "";
    }, age(e, t) {
      if (e == null || e === 0 || e === "") return "";
      let i = b.isDateTime(e, null, true);
      return '<span title="' + (i = i === false ? b.isDate(e, null, true) : i) + '">' + b.age(e) + (t ? " " + t : "") + "</span>";
    }, interval(e, t) {
      return e == null || e === 0 || e === "" ? "" : b.interval(e) + (t ? " " + t : "");
    }, toggle(e, t) {
      return e ? "Yes" : "";
    }, password(e, t) {
      let i = "";
      for (let n = 0; n < e.length; n++) i += "*";
      return i;
    } };
  }
  isBin(e) {
    return /^[0-1]+$/.test(e);
  }
  isInt(e) {
    return /^[-+]?[0-9]+$/.test(e);
  }
  isFloat(e) {
    return (typeof (e = typeof e == "string" ? e.replace(this.settings.groupSymbol, "").replace(this.settings.decimalSymbol, ".") : e) == "number" || typeof e == "string" && e !== "") && !isNaN(Number(e));
  }
  isMoney(e) {
    var t, i;
    return typeof e != "object" && e !== "" && (!!this.isFloat(e) || (t = this.settings, i = new RegExp("^" + (t.currencyPrefix ? "\\" + t.currencyPrefix + "?" : "") + "[-+]?" + (t.currencyPrefix ? "\\" + t.currencyPrefix + "?" : "") + "[0-9]*[\\" + t.decimalSymbol + "]?[0-9]+" + (t.currencySuffix ? "\\" + t.currencySuffix + "?" : "") + "$", "i"), typeof e == "string" && (e = e.replace(new RegExp(t.groupSymbol, "g"), "")), i.test(e)));
  }
  isHex(e) {
    return /^(0x)?[0-9a-fA-F]+$/.test(e);
  }
  isAlphaNumeric(e) {
    return /^[a-zA-Z0-9_-]+$/.test(e);
  }
  isEmail(e) {
    return /^[a-zA-Z0-9._%\-+]+@[а-яА-Яa-zA-Z0-9.-]+\.[а-яА-Яa-zA-Z]+$/.test(e);
  }
  isIpAddress(e) {
    return new RegExp("^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$").test(e);
  }
  isDate(e, t, i) {
    if (!e) return false;
    var n = "Invalid Date";
    let r, o, a;
    if (t == null && (t = this.settings.dateFormat), typeof e.getFullYear == "function") a = e.getFullYear(), r = e.getMonth() + 1, o = e.getDate();
    else if (parseInt(e) == e && 0 < parseInt(e)) e = new Date(parseInt(e)), a = e.getFullYear(), r = e.getMonth() + 1, o = e.getDate();
    else {
      if (e = String(e), new RegExp("mon", "ig").test(t)) {
        t = t.replace(/month/gi, "m").replace(/mon/gi, "m").replace(/dd/gi, "d").replace(/[, ]/gi, "/").replace(/\/\//g, "/").toLowerCase(), e = e.replace(/[, ]/gi, "/").replace(/\/\//g, "/").toLowerCase();
        for (let d = 0, u = this.settings.fullmonths.length; d < u; d++) {
          var l = this.settings.fullmonths[d];
          e = e.replace(new RegExp(l, "ig"), parseInt(d) + 1).replace(new RegExp(l.substr(0, 3), "ig"), parseInt(d) + 1);
        }
      }
      var c = e.replace(/-/g, "/").replace(/\./g, "/").toLowerCase().split("/"), t = t.replace(/-/g, "/").replace(/\./g, "/").toLowerCase();
      t === "mm/dd/yyyy" && (r = c[0], o = c[1], a = c[2]), t === "m/d/yyyy" && (r = c[0], o = c[1], a = c[2]), t === "dd/mm/yyyy" && (r = c[1], o = c[0], a = c[2]), t === "d/m/yyyy" && (r = c[1], o = c[0], a = c[2]), t === "yyyy/dd/mm" && (r = c[2], o = c[1], a = c[0]), t === "yyyy/d/m" && (r = c[2], o = c[1], a = c[0]), t === "yyyy/mm/dd" && (r = c[1], o = c[2], a = c[0]), t === "yyyy/m/d" && (r = c[1], o = c[2], a = c[0]), t === "mm/dd/yy" && (r = c[0], o = c[1], a = c[2]), t === "m/d/yy" && (r = c[0], o = c[1], a = parseInt(c[2]) + 1900), t === "dd/mm/yy" && (r = c[1], o = c[0], a = parseInt(c[2]) + 1900), t === "d/m/yy" && (r = c[1], o = c[0], a = parseInt(c[2]) + 1900), t === "yy/dd/mm" && (r = c[2], o = c[1], a = parseInt(c[0]) + 1900), t === "yy/d/m" && (r = c[2], o = c[1], a = parseInt(c[0]) + 1900), t === "yy/mm/dd" && (r = c[1], o = c[2], a = parseInt(c[0]) + 1900), t === "yy/m/d" && (r = c[1], o = c[2], a = parseInt(c[0]) + 1900);
    }
    return !!this.isInt(a) && !!this.isInt(r) && !!this.isInt(o) && (a = +a, r = +r, o = +o, (n = new Date(a, r - 1, o)).setFullYear(a), r != null) && String(n) !== "Invalid Date" && n.getMonth() + 1 === r && n.getDate() === o && n.getFullYear() === a && (i !== true || n);
  }
  isTime(a, t) {
    if (a == null) return false;
    let i, n, r;
    n = 0 <= (a = (a = String(a)).toUpperCase()).indexOf("AM");
    var o = (r = 0 <= a.indexOf("PM")) || n, a = (i = o ? 12 : 24, (a = a.replace("AM", "").replace("PM", "").trim()).split(":"));
    let l = parseInt(a[0] || 0), c = parseInt(a[1] || 0), h = parseInt(a[2] || 0);
    return (o && a.length === 1 || a.length === 2 || a.length === 3) && !(a[0] === "" || l < 0 || l > i || !this.isInt(a[0]) || 2 < a[0].length || 1 < a.length && (a[1] === "" || c < 0 || 59 < c || !this.isInt(a[1]) || a[1].length !== 2) || 2 < a.length && (a[2] === "" || h < 0 || 59 < h || !this.isInt(a[2]) || a[2].length !== 2) || !(o || i !== l || c === 0 && h === 0) || o && a.length === 1 && l === 0) && (t !== true || (r && l !== 12 && (l += 12), n && l === 12 && (l += 12), { hours: l, minutes: c, seconds: h }));
  }
  isDateTime(e, t, i) {
    var n;
    return typeof e.getFullYear == "function" ? i !== true || e : (n = parseInt(e)) === e ? !(n < 0) && (i !== true || new Date(n)) : (n = String(e).indexOf(" ")) < 0 ? !(String(e).indexOf("T") < 0 || String(new Date(e)) == "Invalid Date") && (i !== true || new Date(e)) : (t = (t = t ?? this.settings.datetimeFormat).split("|"), e = [e.substr(0, n), e.substr(n).trim()], t[0] = t[0].trim(), t[1] && (t[1] = t[1].trim()), n = this.isDate(e[0], t[0], true), t = this.isTime(e[1], true), n !== false && t !== false && (i !== true || (n.setHours(t.hours), n.setMinutes(t.minutes), n.setSeconds(t.seconds), n)));
  }
  age(e) {
    let t;
    if (e === "" || e == null || (t = typeof e.getFullYear == "function" ? e : parseInt(e) == e && 0 < parseInt(e) ? new Date(parseInt(e)) : new Date(e), String(t) === "Invalid Date")) return "";
    e = ((/* @__PURE__ */ new Date()).getTime() - t.getTime()) / 1e3;
    let i = "", n = "";
    return e < 0 ? (i = 0, n = "sec") : e < 60 ? (i = Math.floor(e), n = "sec", e < 0 && (i = 0, n = "sec")) : e < 3600 ? (i = Math.floor(e / 60), n = "min") : e < 86400 ? (i = Math.floor(e / 60 / 60), n = "hour") : e < 2592e3 ? (i = Math.floor(e / 24 / 60 / 60), n = "day") : e < 31536e3 ? (i = Math.floor(e / 30 / 24 / 60 / 60 * 10) / 10, n = "month") : e < 126144e3 ? (i = Math.floor(e / 365 / 24 / 60 / 60 * 10) / 10, n = "year") : 126144e3 <= e && (i = Math.floor(e / 365.25 / 24 / 60 / 60 * 10) / 10, n = "year"), i + " " + n + (1 < i ? "s" : "");
  }
  interval(e) {
    return e < 100 ? "< 0.01 sec" : e < 1e3 ? Math.floor(e / 10) / 100 + " sec" : e < 1e4 ? Math.floor(e / 100) / 10 + " sec" : e < 6e4 ? Math.floor(e / 1e3) + " secs" : e < 36e5 ? Math.floor(e / 6e4) + " mins" : e < 864e5 ? Math.floor(e / 36e5 * 10) / 10 + " hours" : e < 2628e6 ? Math.floor(e / 864e5 * 10) / 10 + " days" : e < 31536e6 ? Math.floor(e / 2628e6 * 10) / 10 + " months" : Math.floor(e / 31536e5) / 10 + " years";
  }
  date(r) {
    if (r === "" || r == null || typeof r == "object" && !r.getMonth) return "";
    let t = new Date(r);
    if (this.isInt(r) && (t = new Date(Number(r))), String(t) === "Invalid Date") return "";
    var r = this.settings.shortmonths, n = /* @__PURE__ */ new Date(), o = /* @__PURE__ */ new Date(), i = (o.setTime(o.getTime() - 864e5), r[t.getMonth()] + " " + t.getDate() + ", " + t.getFullYear()), n = r[n.getMonth()] + " " + n.getDate() + ", " + n.getFullYear(), r = r[o.getMonth()] + " " + o.getDate() + ", " + o.getFullYear(), o = t.getHours() - (12 < t.getHours() ? 12 : 0) + ":" + (t.getMinutes() < 10 ? "0" : "") + t.getMinutes() + " " + (12 <= t.getHours() ? "pm" : "am");
    let a = i == n ? o : i;
    return '<span title="' + i + " " + (t.getHours() - (12 < t.getHours() ? 12 : 0) + ":" + (t.getMinutes() < 10 ? "0" : "") + t.getMinutes() + ":" + (t.getSeconds() < 10 ? "0" : "") + t.getSeconds() + " " + (12 <= t.getHours() ? "pm" : "am")) + '">' + (a = i == r ? this.lang("Yesterday") : a) + "</span>";
  }
  formatSize(e) {
    var t;
    return this.isFloat(e) && e !== "" ? (e = parseFloat(e)) === 0 ? 0 : (t = parseInt(Math.floor(Math.log(e) / Math.log(1024))), (Math.floor(e / Math.pow(1024, t) * 10) / 10).toFixed(t === 0 ? 0 : 1) + " " + (["Bt", "KB", "MB", "GB", "TB", "PB", "EB", "ZB"][t] || "??")) : "";
  }
  formatNumber(e, t, i) {
    return e == null || e === "" || typeof e == "object" ? "" : (i = { minimumFractionDigits: parseInt(t), maximumFractionDigits: parseInt(t), useGrouping: !!i }, (t == null || t < 0) && (i.minimumFractionDigits = 0, i.maximumFractionDigits = 20), parseFloat(e).toLocaleString(this.settings.locale, i));
  }
  formatDate(e, t) {
    if (t = t || this.settings.dateFormat, e === "" || e == null || typeof e == "object" && !e.getMonth) return "";
    let i = new Date(e);
    var n, r;
    return this.isInt(e) && (i = new Date(Number(e))), String(i) === "Invalid Date" ? "" : (e = i.getFullYear(), n = i.getMonth(), r = i.getDate(), t.toLowerCase().replace("month", this.settings.fullmonths[n]).replace("mon", this.settings.shortmonths[n]).replace(/yyyy/g, ("000" + e).slice(-4)).replace(/yyy/g, ("000" + e).slice(-4)).replace(/yy/g, ("0" + e).slice(-2)).replace(/(^|[^a-z$])y/g, "$1" + e).replace(/mm/g, ("0" + (n + 1)).slice(-2)).replace(/dd/g, ("0" + r).slice(-2)).replace(/th/g, r == 1 ? "st" : "th").replace(/th/g, r == 2 ? "nd" : "th").replace(/th/g, r == 3 ? "rd" : "th").replace(/(^|[^a-z$])m/g, "$1" + (n + 1)).replace(/(^|[^a-z$])d/g, "$1" + r));
  }
  formatTime(e, t) {
    if (t = t || this.settings.timeFormat, e === "" || e == null || typeof e == "object" && !e.getMonth) return "";
    let i = new Date(e);
    if (this.isInt(e) && (i = new Date(Number(e))), this.isTime(e) && (e = this.isTime(e, true), (i = /* @__PURE__ */ new Date()).setHours(e.hours), i.setMinutes(e.minutes)), String(i) === "Invalid Date") return "";
    let n = "am", r = i.getHours();
    e = i.getHours();
    let o = i.getMinutes(), a = i.getSeconds();
    return o < 10 && (o = "0" + o), a < 10 && (a = "0" + a), t.indexOf("am") === -1 && t.indexOf("pm") === -1 || (12 <= r && (n = "pm"), 12 < r && (r -= 12), r === 0 && (r = 12)), t.toLowerCase().replace("am", n).replace("pm", n).replace("hhh", r < 10 ? "0" + r : r).replace("hh24", e < 10 ? "0" + e : e).replace("h24", e).replace("hh", r).replace("mm", o).replace("mi", o).replace("ss", a).replace(/(^|[^a-z$])h/g, "$1" + r).replace(/(^|[^a-z$])m/g, "$1" + o).replace(/(^|[^a-z$])s/g, "$1" + a);
  }
  formatDateTime(e, t) {
    let i;
    return e === "" || e == null || typeof e == "object" && !e.getMonth ? "" : (typeof t != "string" ? i = [this.settings.dateFormat, this.settings.timeFormat] : ((i = t.split("|"))[0] = i[0].trim(), i[1] = 1 < i.length ? i[1].trim() : this.settings.timeFormat), i[1] === "h12" && (i[1] = "h:m pm"), i[1] === "h24" && (i[1] = "h24:m"), this.formatDate(e, i[0]) + " " + this.formatTime(e, i[1]));
  }
  stripSpaces(e) {
    if (e != null) switch (typeof e) {
      case "number":
        break;
      case "string":
        e = String(e).replace(/(?:\r\n|\r|\n)/g, " ").replace(/\s\s+/g, " ").trim();
        break;
      case "object":
        Array.isArray(e) ? (e = this.extend([], e)).forEach((t, i) => {
          e[i] = this.stripSpaces(t);
        }) : (e = this.extend({}, e), Object.keys(e).forEach((t) => {
          e[t] = this.stripSpaces(e[t]);
        }));
    }
    return e;
  }
  stripTags(e) {
    if (e != null) switch (typeof e) {
      case "number":
        break;
      case "string":
        e = String(e).replace(/<(?:[^>=]|='[^']*'|="[^"]*"|=[^'"][^\s>]*)*>/gi, "");
        break;
      case "object":
        Array.isArray(e) ? (e = this.extend([], e)).forEach((t, i) => {
          e[i] = this.stripTags(t);
        }) : (e = this.extend({}, e), Object.keys(e).forEach((t) => {
          e[t] = this.stripTags(e[t]);
        }));
    }
    return e;
  }
  encodeTags(e) {
    if (e != null) switch (typeof e) {
      case "number":
        break;
      case "string":
        e = String(e).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
        break;
      case "object":
        Array.isArray(e) ? (e = this.extend([], e)).forEach((t, i) => {
          e[i] = this.encodeTags(t);
        }) : (e = this.extend({}, e), Object.keys(e).forEach((t) => {
          e[t] = this.encodeTags(e[t]);
        }));
    }
    return e;
  }
  decodeTags(e) {
    if (e != null) switch (typeof e) {
      case "number":
        break;
      case "string":
        e = String(e).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        break;
      case "object":
        Array.isArray(e) ? (e = this.extend([], e)).forEach((t, i) => {
          e[i] = this.decodeTags(t);
        }) : (e = this.extend({}, e), Object.keys(e).forEach((t) => {
          e[t] = this.decodeTags(e[t]);
        }));
    }
    return e;
  }
  escapeId(e) {
    return e === "" || e == null ? "" : (e + "").replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, (t, i) => i ? t === "\0" ? "\uFFFD" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t);
  }
  unescapeId(e) {
    return e === "" || e == null ? "" : e.replace(/\\[\da-fA-F]{1,6}[\x20\t\r\n\f]?|\\([^\r\n\f])/g, (t, i) => (t = "0x" + t.slice(1) - 65536, i || (t < 0 ? String.fromCharCode(65536 + t) : String.fromCharCode(t >> 10 | 55296, 1023 & t | 56320))));
  }
  base64encode(e) {
    return btoa(e);
  }
  base64decode(e) {
    return atob(e);
  }
  async sha256(e) {
    return e = new TextEncoder().encode(e), crypto.subtle.digest("SHA-256", e).then((t) => Array.from(new Uint8Array(t)).map((i) => i.toString(16).padStart(2, "0")).join(""));
  }
  transition(e, t, i, n) {
    return new Promise((r, o) => {
      var a = getComputedStyle(e);
      let l = parseInt(a.width), c = parseInt(a.height);
      if (e && t) {
        switch (e.parentNode.style.cssText += "perspective: 900px; overflow: hidden;", e.style.cssText += "; position: absolute; z-index: 1019; backface-visibility: hidden", t.style.cssText += "; position: absolute; z-index: 1020; backface-visibility: hidden", i) {
          case "slide-left":
            e.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0)", t.style.cssText += "overflow: hidden; transform: translate3d(" + l + "px, 0, 0)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: translate3d(0, 0, 0)", e.style.cssText += "transition: 0.5s; transform: translate3d(-" + l + "px, 0, 0)";
            }, 1);
            break;
          case "slide-right":
            e.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0)", t.style.cssText += "overflow: hidden; transform: translate3d(-" + l + "px, 0, 0)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: translate3d(0px, 0, 0)", e.style.cssText += "transition: 0.5s; transform: translate3d(" + l + "px, 0, 0)";
            }, 1);
            break;
          case "slide-down":
            e.style.cssText += "overflow: hidden; z-index: 1; transform: translate3d(0, 0, 0)", t.style.cssText += "overflow: hidden; z-index: 0; transform: translate3d(0, 0, 0)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: translate3d(0, 0, 0)", e.style.cssText += "transition: 0.5s; transform: translate3d(0, " + c + "px, 0)";
            }, 1);
            break;
          case "slide-up":
            e.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0)", t.style.cssText += "overflow: hidden; transform: translate3d(0, " + c + "px, 0)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: translate3d(0, 0, 0)", e.style.cssText += "transition: 0.5s; transform: translate3d(0, 0, 0)";
            }, 1);
            break;
          case "flip-left":
            e.style.cssText += "overflow: hidden; transform: rotateY(0deg)", t.style.cssText += "overflow: hidden; transform: rotateY(-180deg)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: rotateY(0deg)", e.style.cssText += "transition: 0.5s; transform: rotateY(180deg)";
            }, 1);
            break;
          case "flip-right":
            e.style.cssText += "overflow: hidden; transform: rotateY(0deg)", t.style.cssText += "overflow: hidden; transform: rotateY(180deg)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: rotateY(0deg)", e.style.cssText += "transition: 0.5s; transform: rotateY(-180deg)";
            }, 1);
            break;
          case "flip-down":
            e.style.cssText += "overflow: hidden; transform: rotateX(0deg)", t.style.cssText += "overflow: hidden; transform: rotateX(180deg)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: rotateX(0deg)", e.style.cssText += "transition: 0.5s; transform: rotateX(-180deg)";
            }, 1);
            break;
          case "flip-up":
            e.style.cssText += "overflow: hidden; transform: rotateX(0deg)", t.style.cssText += "overflow: hidden; transform: rotateX(-180deg)", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: rotateX(0deg)", e.style.cssText += "transition: 0.5s; transform: rotateX(180deg)";
            }, 1);
            break;
          case "pop-in":
            e.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0)", t.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0); transform: scale(.8); opacity: 0;", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; transform: scale(1); opacity: 1;", e.style.cssText += "transition: 0.5s;";
            }, 1);
            break;
          case "pop-out":
            e.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0); transform: scale(1); opacity: 1;", t.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0); opacity: 0;", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; opacity: 1;", e.style.cssText += "transition: 0.5s; transform: scale(1.7); opacity: 0;";
            }, 1);
            break;
          default:
            e.style.cssText += "overflow: hidden; transform: translate3d(0, 0, 0)", t.style.cssText += "overflow: hidden; translate3d(0, 0, 0); opacity: 0;", p(t).show(), setTimeout(() => {
              t.style.cssText += "transition: 0.5s; opacity: 1;", e.style.cssText += "transition: 0.5s";
            }, 1);
        }
        setTimeout(() => {
          i === "slide-down" && (p(e).css("z-index", "1019"), p(t).css("z-index", "1020")), t && p(t).css({ opacity: "1" }).css({ transition: "", transform: "" }), e && p(e).css({ opacity: "1" }).css({ transition: "", transform: "" }), typeof n == "function" && n(), r();
        }, 500);
      } else console.log("ERROR: Cannot do transition when one of the divs is null");
    });
  }
  lock(e, t = {}) {
    if (e != null) {
      typeof t == "string" && (t = { msg: t }), arguments[2] && (t.spinner = arguments[2]), t = this.extend({ spinner: false }, t), (e == null ? void 0 : e[0]) instanceof Node && (e = Array.isArray(e) ? e : e.get()), t.msg || t.msg === 0 || (t.msg = ""), this.unlock(e);
      var i = p(e).get(0);
      let n = i.scrollWidth, r = i.scrollHeight, o = (i.tagName == "BODY" && (n < innerWidth && (n = innerWidth), r < innerHeight) && (r = innerHeight), p(e).prepend(`<div class="w2ui-lock" style="height: ${r}px; width: ${n}px"></div><div class="w2ui-lock-msg"></div>`), p(e).find(".w2ui-lock"));
      i = p(e).find(".w2ui-lock-msg"), e = (t.msg || i.css({ "background-color": "transparent", "background-image": "none", border: "0px", "box-shadow": "none" }), t.spinner === true && (t.msg = `<div class="w2ui-spinner" ${t.msg ? "" : 'style="width: 35px; height: 35px"'}></div>` + t.msg), t.msg ? i.html(t.msg).css("display", "block") : i.remove(), t.opacity != null && o.css("opacity", t.opacity), o.css({ display: "block" }), t.bgColor && o.css({ "background-color": t.bgColor }), getComputedStyle(o.get(0)));
      let a = e.opacity ?? 0.15;
      o.on("mousedown", function() {
        typeof t.onClick == "function" ? t.onClick() : o.css({ transition: ".2s", opacity: 1.5 * a });
      }).on("mouseup", function() {
        typeof t.onClick != "function" && o.css({ transition: ".2s", opacity: a });
      }).on("mousewheel", function(l) {
        l && (l.stopPropagation(), l.preventDefault());
      });
    }
  }
  unlock(e, t) {
    var i;
    e != null && (clearTimeout(e._prevUnlock), (e == null ? void 0 : e[0]) instanceof Node && (e = Array.isArray(e) ? e : e.get()), this.isInt(t) && 0 < t ? (p(e).find(".w2ui-lock").css({ transition: t / 1e3 + "s", opacity: 0 }), i = p(e).get(0), clearTimeout(i._prevUnlock), i._prevUnlock = setTimeout(() => {
      p(e).find(".w2ui-lock").remove();
    }, t)) : p(e).find(".w2ui-lock").remove(), p(e).find(".w2ui-lock-msg").remove());
  }
  message(e, t) {
    var _a2, _b2;
    let i, n, r;
    var o = () => {
      var _a3;
      var m = p(e == null ? void 0 : e.box).find(".w2ui-message");
      m.length != 0 && typeof ((_a3 = t = m.get(0)._msg_options || {}) == null ? void 0 : _a3.close) == "function" && t.close();
    };
    let a = (m) => {
      var _a3, _b3;
      var _, g = m.box._msg_prevFocus;
      p(e.box).find(".w2ui-message").length <= 1 ? e.owner ? e.owner.unlock(e.param, 150) : this.unlock(e.box, 150) : p(e.box).find(`#w2ui-message-${(_a3 = e.owner) == null ? void 0 : _a3.name}-` + (m.msgIndex - 1)).css("z-index", 1500), g ? 0 < (_ = p(g).closest(".w2ui-message")).length ? _.get(0)._msg_options.setFocus(g) : g.focus() : typeof ((_b3 = e.owner) == null ? void 0 : _b3.focus) == "function" && e.owner.focus(), p(m.box).remove(), m.msgIndex === 0 && (f.css("z-index", m.tmp.zIndex), p(e.box).css("overflow", m.tmp.overflow)), m.trigger && r.finish();
    };
    if (typeof (t = typeof t != "string" && typeof t != "number" ? t : { width: String(t).length < 300 ? 350 : 550, height: String(t).length < 300 ? 170 : 250, text: String(t) }) != "object") return void o();
    t.text != null && (t.body = `<div class="w2ui-centered w2ui-msg-text">${t.text}</div>`), t.width == null && (t.width = 350), t.height == null && (t.height = 170), t.hideOn == null && (t.hideOn = ["esc"]), t.on == null && (h = t, t = new Xn(), b.extend(t, h)), t.on("open", (m) => {
      b.bindEvents(p(t.box).find(".w2ui-eaction"), t), p(m.detail.box).find("button, input, textarea, [name=hidden-first]").off(".message").on("keydown.message", function(_) {
        _.keyCode == 27 && t.hideOn.includes("esc") && (t.cancelAction ? t.action(t.cancelAction) : t.close());
      }), setTimeout(() => t.setFocus(t.focus), 300);
    }), t.off(".prom");
    let l = { self: t, action(m) {
      return t.on("action.prom", m), l;
    }, close(m) {
      return t.on("close.prom", m), l;
    }, open(m) {
      return t.on("open.prom", m), l;
    }, then(m) {
      return t.on("open:after.prom", m), l;
    } }, c = (t.actions == null && t.buttons == null && t.html == null && (t.actions = { Ok(m) {
      m.detail.self.close();
    } }), t.off(".buttons"), t.actions != null && (t.buttons = "", Object.keys(t.actions).forEach((m) => {
      var _ = t.actions[m];
      let g = m;
      typeof _ == "function" && (t.buttons += `<button class="w2ui-btn w2ui-eaction" data-click='["action","${m}","event"]' name="${m}">${m}</button>`), typeof _ == "object" && (t.buttons += `<button class="w2ui-btn w2ui-eaction ${_.class || ""}" name="${m}" data-click='["action","${m}","event"]'
                        style="${_.style ?? ""}" ${_.attrs ?? ""}>${_.text || m}</button>`, g = Array.isArray(t.actions) ? _.text : m), typeof _ == "string" && (t.buttons += `<button class="w2ui-btn w2ui-eaction" name="${_}" data-click='["action","${_}","event"]'>${_}</button>`, g = _), typeof g == "string" && (g = g[0].toLowerCase() + g.substr(1).replace(/\s+/g, "")), l[g] = function(v) {
        return t.on("action.buttons", (y) => {
          y.detail.action[0].toLowerCase() + y.detail.action.substr(1).replace(/\s+/g, "") == g && v(y);
        }), l;
      };
    })), Array("html", "body", "buttons").forEach((m) => {
      t[m] = String(t[m] ?? "").trim();
    }), t.body === "" && t.buttons === "" || (t.html = `
                <div class="w2ui-message-body">${t.body || ""}</div>
                <div class="w2ui-message-buttons">${t.buttons || ""}</div>
            `), getComputedStyle(p(e.box).get(0)));
    var h = parseFloat(c.width), d = parseFloat(c.height);
    let u = 0, f = (0 < p(e.after).length && (c = getComputedStyle(p(e.after).get(0)), u = parseInt(c.display != "none" ? parseInt(c.height) : 0)), t.width > h && (t.width = h - 10), t.height > d - u && (t.height = d - 10 - u), t.originalWidth = t.width, t.originalHeight = t.height, parseInt(t.width) < 0 && (t.width = h + t.width), parseInt(t.width) < 10 && (t.width = 10), parseInt(t.height) < 0 && (t.height = d + t.height - u), parseInt(t.height) < 10 && (t.height = 10), t.originalHeight < 0 && (t.height = d + t.originalHeight - u), t.originalWidth < 0 && (t.width = h + 2 * t.originalWidth), p(e.box).find(e.after));
    return t.tmp || (t.tmp = { zIndex: f.css("z-index"), overflow: c.overflow }), t.html === "" && t.body === "" && t.buttons === "" ? o() : (t.msgIndex = p(e.box).find(".w2ui-message").length, t.msgIndex === 0 && typeof this.lock == "function" && (p(e.box).css("overflow", "hidden"), e.owner ? e.owner.lock(e.param) : this.lock(e.box)), p(e.box).find(".w2ui-message").css("z-index", 1390), f.css("z-index", 1501), d = `
                <div id="w2ui-message-${(_a2 = e.owner) == null ? void 0 : _a2.name}-${t.msgIndex}" class="w2ui-message" data-mousedown="stop"
                    style="z-index: 1500; left: ${(h - t.width) / 2}px; top: ${u}px;
                        width: ${t.width}px; height: ${t.height}px; transform: translateY(-${t.height}px)"
                    ${t.hideOn.includes("click") ? e.param ? `data-click='["message", "${e.param}"]` : 'data-click="message"' : ""}>
                    <span name="hidden-first" tabindex="0" style="position: absolute; top: 0; outline: none"></span>
                    ${t.html}
                    <span name="hidden-last" tabindex="0" style="position: absolute; top: 0; outline: none"></span>
                </div>`, 0 < p(e.after).length ? p(e.box).find(e.after).after(d) : p(e.box).prepend(d), t.box = p(e.box).find(`#w2ui-message-${(_b2 = e.owner) == null ? void 0 : _b2.name}-` + t.msgIndex)[0], b.bindEvents(t.box, this), p(t.box).addClass("animating"), (t.box._msg_options = t).box._msg_prevFocus = document.activeElement, setTimeout(() => {
      var _a3;
      (r = t.trigger("open", { target: this.name, box: t.box, self: t })).isCancelled === true ? (p(e.box).find(`#w2ui-message-${(_a3 = e.owner) == null ? void 0 : _a3.name}-` + t.msgIndex).remove(), t.msgIndex === 0 && (f.css("z-index", t.tmp.zIndex), p(e.box).css("overflow", t.tmp.overflow))) : p(t.box).css({ transition: "0.3s", transform: "translateY(0px)" });
    }, 0), n = setTimeout(() => {
      var _a3;
      p(e.box).find(`#w2ui-message-${(_a3 = e.owner) == null ? void 0 : _a3.name}-` + t.msgIndex).removeClass("animating").css({ transition: "0s" }), r.finish();
    }, 300)), t.action = (m, _) => {
      let g = t.actions[m];
      g instanceof Object && g.onClick && (g = g.onClick), m = t.trigger("action", { target: this.name, action: m, self: t, originalEvent: _, value: t.input ? t.input.value : null }), m.isCancelled !== true && (typeof g == "function" && g(m), m.finish());
    }, t.close = () => {
      var _a3;
      (r = t.trigger("close", { target: "self", box: t.box, self: t })).isCancelled !== true && (clearTimeout(n), p(t.box).hasClass("animating") ? (clearTimeout(i), a(t)) : (p(t.box).addClass("w2ui-closing animating").css({ transition: "0.15s", transform: "translateY(-" + t.height + "px)" }), t.msgIndex !== 0 && p(e.box).find(`#w2ui-message-${(_a3 = e.owner) == null ? void 0 : _a3.name}-` + (t.msgIndex - 1)).css("z-index", 1499), i = setTimeout(() => {
        a(t);
      }, 150)));
    }, t.setFocus = (m) => {
      var _a3, _b3;
      var _ = p(e.box).find(".w2ui-message").length - 1;
      let g = p(e.box).find(`#w2ui-message-${(_a3 = e.owner) == null ? void 0 : _a3.name}-` + _), v = "input, button, select, textarea, [contentEditable], .w2ui-input";
      (_b3 = m != null ? isNaN(m) ? g.find(v).filter(m).get(0) : g.find(v).get(m) : g.find("[name=hidden-first]").get(0)) == null ? void 0 : _b3.focus(), p(e.box).find(".w2ui-message").find(v + ",[name=hidden-first],[name=hidden-last]").off(".keep-focus"), p(g).find(v + ",[name=hidden-first],[name=hidden-last]").on("blur.keep-focus", function(y) {
        setTimeout(() => {
          var _a4, _b4, _c2;
          var x = document.activeElement, S = 0 < p(g).find(v).filter(x).length, A = p(x).attr("name");
          !S && x && x !== document.body && ((_a4 = p(g).find(v).get(0)) == null ? void 0 : _a4.focus()), A == "hidden-last" && ((_b4 = p(g).find(v).get(0)) == null ? void 0 : _b4.focus()), A == "hidden-first" && ((_c2 = p(g).find(v).get(-1)) == null ? void 0 : _c2.focus());
        }, 1);
      });
    }, l;
  }
  notify(e, t) {
    return new Promise((i) => {
      if (typeof e == "object" && (e = (t = e).text), (t = t || {}).where = t.where ?? document.body, t.timeout = t.timeout ?? 15e3, typeof this.tmp.notify_resolve == "function" && (this.tmp.notify_resolve(), p(this.tmp.notify_where).find("#w2ui-notify").remove()), this.tmp.notify_resolve = i, this.tmp.notify_where = t.where, clearTimeout(this.tmp.notify_timer), e) {
        if (typeof t.actions == "object") {
          let r = {};
          Object.keys(t.actions).forEach((o) => {
            r[o] = `<a class="w2ui-notify-link" value="${o}">${o}</a>`;
          }), e = this.execTemplate(e, r);
        }
        var n = `
                    <div id="w2ui-notify">
                        <div class="${t.class} ${t.error ? "w2ui-notify-error" : ""}">
                            ${e}
                            <span class="w2ui-notify-close w2ui-icon-cross"></span>
                        </div>
                    </div>`;
        p(t.where).append(n), p(t.where).find("#w2ui-notify").find(".w2ui-notify-close").on("click", (r) => {
          p(t.where).find("#w2ui-notify").remove(), i();
        }), t.actions && p(t.where).find("#w2ui-notify .w2ui-notify-link").on("click", (r) => {
          r = p(r.target).attr("value"), t.actions[r](), p(t.where).find("#w2ui-notify").remove(), i();
        }), 0 < t.timeout && (this.tmp.notify_timer = setTimeout(() => {
          p(t.where).find("#w2ui-notify").remove(), i();
        }, t.timeout));
      }
    });
  }
  confirm(e, t) {
    return b.normButtons(t = typeof t == "string" ? { text: t } : t, { yes: "Yes", no: "No" }), e = b.message(e, t), e && e.action((i) => {
      i.detail.self.close();
    }), e;
  }
  normButtons(e, t) {
    e.actions = e.actions ?? {};
    var i = Object.keys(t);
    return i.forEach((n) => {
      var r = e["btn_" + n];
      r && (t[n] = { text: b.lang(r.text ?? ""), class: r.class ?? "", style: r.style ?? "", attrs: r.attrs ?? "" }, delete e["btn_" + n]), Array("text", "class", "style", "attrs").forEach((o) => {
        e[n + "_" + o] && (typeof t[n] == "string" && (t[n] = { text: t[n] }), t[n][o] = e[n + "_" + o], delete e[n + "_" + o]);
      });
    }), i.includes("yes") && i.includes("no") && (b.settings.macButtonOrder ? b.extend(e.actions, { no: t.no, yes: t.yes }) : b.extend(e.actions, { yes: t.yes, no: t.no })), i.includes("ok") && i.includes("cancel") && (b.settings.macButtonOrder ? b.extend(e.actions, { cancel: t.cancel, ok: t.ok }) : b.extend(e.actions, { ok: t.ok, cancel: t.cancel })), e;
  }
  getSize(e, t) {
    let i = 0;
    if (0 < (e = p(e)).length) {
      e = e[0];
      var n = getComputedStyle(e);
      switch (t) {
        case "width":
          i = parseFloat(n.width), n.width === "auto" && (i = 0);
          break;
        case "height":
          i = parseFloat(n.height), n.height === "auto" && (i = 0);
          break;
        default:
          i = parseFloat(n[t] ?? 0) || 0;
      }
    }
    return i;
  }
  getStrWidth(e, t) {
    return p("body").append(`
            <div id="_tmp_width" style="position: absolute; top: -9000px; ${t || ""}">
                ${this.encodeTags(e)}
            </div>`), t = p("#_tmp_width")[0].clientWidth, p("#_tmp_width").remove(), t;
  }
  execTemplate(e, t) {
    return typeof e == "string" && t && typeof t == "object" ? e.replace(/\${([^}]+)?}/g, function(i, n) {
      return t[n] || n;
    }) : e;
  }
  marker(e, t, i = { onlyFirst: false, wholeWord: false }) {
    Array.isArray(t) || (t = t != null && t !== "" ? [t] : []);
    let n = i.wholeWord;
    p(e).each((r) => {
      for (var o = r, a = /\<span class=\"w2ui\-marker\"\>((.|\n|\r)*)\<\/span\>/gi; o.innerHTML.indexOf('<span class="w2ui-marker"') !== -1; ) o.innerHTML = o.innerHTML.replace(a, "$1");
      t.forEach((l) => {
        l = (l = typeof l != "string" ? String(l) : l).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&").replace(/&/g, "&amp;").replace(/</g, "&gt;").replace(/>/g, "&lt;"), l = new RegExp((n ? "\\b" : "") + l + (n ? "\\b" : "") + "(?!([^<]+)?>)", "i" + (i.onlyFirst ? "" : "g")), r.innerHTML = r.innerHTML.replace(l, (c) => '<span class="w2ui-marker">' + c + "</span>");
      });
    });
  }
  lang(e, t) {
    if (!e || this.settings.phrases == null || typeof e != "string" || "<=>=".includes(e)) return this.execTemplate(e, t);
    let i = this.settings.phrases[e];
    return i == null ? (i = e, this.settings.warnNoPhrase && (this.settings.missing || (this.settings.missing = {}), this.settings.missing[e] = "---", this.settings.phrases[e] = "---", console.log(`Missing translation for "%c${e}%c", see %c w2utils.settings.phrases %c with value "---"`, "color: orange", "", "color: #999", ""))) : i !== "---" || this.settings.warnNoPhrase || (i = e), i === "---" && (i = `<span ${this.tooltip(e)}>---</span>`), this.execTemplate(i, t);
  }
  locale(e, t, i) {
    return new Promise((n, r) => {
      if (Array.isArray(e)) {
        this.settings.phrases = {};
        let o = [], a = {};
        e.forEach((l, c) => {
          l.length === 5 && (l = "locale/" + l.toLowerCase() + ".json", e[c] = l), o.push(this.locale(l, true, false));
        }), Promise.allSettled(o).then((l) => {
          l.forEach((c) => {
            c.value && (a[c.value.file] = c.value.data);
          }), e.forEach((c) => {
            this.settings = this.extend({}, this.settings, a[c]);
          }), n();
        });
      } else (e = e || "en-us") instanceof Object ? this.settings = this.extend({}, this.settings, sl, e) : (e.length === 5 && (e = "locale/" + e.toLowerCase() + ".json"), fetch(e, { method: "GET" }).then((o) => o.json()).then((o) => {
        i !== true && (this.settings = t ? this.extend({}, this.settings, o) : this.extend({}, this.settings, sl, { phrases: {} }, o)), n({ file: e, data: o });
      }).catch((o) => {
        console.log("ERROR: Cannot load locale " + e), r(o);
      }));
    });
  }
  scrollBarSize() {
    return this.tmp.scrollBarSize || (p("body").append(`
            <div id="_scrollbar_width" style="position: absolute; top: -300px; width: 100px; height: 100px; overflow-y: scroll;">
                <div style="height: 120px">1</div>
            </div>
        `), this.tmp.scrollBarSize = 100 - p("#_scrollbar_width > div")[0].clientWidth, p("#_scrollbar_width").remove()), this.tmp.scrollBarSize;
  }
  checkName(e) {
    return e == null ? (console.log('ERROR: Property "name" is required but not supplied.'), false) : on[e] != null ? (console.log(`ERROR: Object named "${e}" is already registered as w2ui.${e}.`), false) : !!this.isAlphaNumeric(e) || (console.log('ERROR: Property "name" has to be alpha-numeric (a-z, 0-9, dash and underscore).'), false);
  }
  checkUniqueId(e, t, i, n) {
    Array.isArray(t) || (t = [t]);
    let r = true;
    return t.forEach((o) => {
      o.id === e && (console.log(`ERROR: The item id="${e}" is not unique within the ${i} "${n}".`, t), r = false);
    }), r;
  }
  encodeParams(e, t = "") {
    let i = "";
    return Object.keys(e).forEach((n) => {
      i != "" && (i += "&"), typeof e[n] == "object" ? i += this.encodeParams(e[n], t + n + (t ? "]" : "") + "[") : i += "" + t + n + (t ? "]" : "") + "=" + e[n];
    }), i;
  }
  parseRoute(e) {
    let t = [];
    return e = e.replace(/\/\(/g, "(?:/").replace(/\+/g, "__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, (i, n, r, o, a, l) => (t.push({ name: o, optional: !!l }), n = n || "", (l ? "" : n) + "(?:" + (l ? n : "") + (r || "") + (a || (r ? "([^/.]+?)" : "([^/]+?)")) + ")" + (l || ""))).replace(/([\/.])/g, "\\$1").replace(/__plus__/g, "(.+)").replace(/\*/g, "(.*)"), { path: new RegExp("^" + e + "$", "i"), keys: t };
  }
  getCursorPosition(e) {
    if (e == null) return null;
    let t = 0;
    var i, n = e.ownerDocument || e.document, r = n.defaultView || n.parentWindow;
    let o;
    return ["INPUT", "TEXTAREA"].includes(e.tagName) ? t = e.selectionStart : r.getSelection ? 0 < (o = r.getSelection()).rangeCount && ((i = (r = o.getRangeAt(0)).cloneRange()).selectNodeContents(e), i.setEnd(r.endContainer, r.endOffset), t = i.toString().length) : (o = n.selection) && o.type !== "Control" && (r = o.createRange(), (i = n.body.createTextRange()).moveToElementText(e), i.setEndPoint("EndToEnd", r), t = i.text.length), t;
  }
  setCursorPosition(e, t, i) {
    if (e != null) {
      var n = document.createRange();
      let r, o = window.getSelection();
      if (["INPUT", "TEXTAREA"].includes(e.tagName)) e.setSelectionRange(t, i ?? t);
      else {
        for (let a = 0; a < e.childNodes.length; a++) {
          let l = p(e.childNodes[a]).text();
          if (t <= (l = e.childNodes[a].tagName ? (l = p(e.childNodes[a]).html()).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&nbsp;/g, " ") : l).length) {
            (r = (r = e.childNodes[a]).childNodes && 0 < r.childNodes.length ? r.childNodes[0] : r).childNodes && 0 < r.childNodes.length && (r = r.childNodes[0]);
            break;
          }
          t -= l.length;
        }
        r != null && (t > r.length && (t = r.length), n.setStart(r, t), i ? n.setEnd(r, i) : n.collapse(true), o.removeAllRanges(), o.addRange(n));
      }
    }
  }
  parseColor(e) {
    if (typeof e != "string") return null;
    let t = {};
    if ((e = (e = e.trim().toUpperCase())[0] === "#" ? e.substr(1) : e).length === 3) t = { r: parseInt(e[0] + e[0], 16), g: parseInt(e[1] + e[1], 16), b: parseInt(e[2] + e[2], 16), a: 1 };
    else if (e.length === 6) t = { r: parseInt(e.substr(0, 2), 16), g: parseInt(e.substr(2, 2), 16), b: parseInt(e.substr(4, 2), 16), a: 1 };
    else if (e.length === 8) t = { r: parseInt(e.substr(0, 2), 16), g: parseInt(e.substr(2, 2), 16), b: parseInt(e.substr(4, 2), 16), a: Math.round(parseInt(e.substr(6, 2), 16) / 255 * 100) / 100 };
    else if (4 < e.length && e.substr(0, 4) === "RGB(") {
      var i = e.replace("RGB", "").replace(/\(/g, "").replace(/\)/g, "").split(",");
      t = { r: parseInt(i[0], 10), g: parseInt(i[1], 10), b: parseInt(i[2], 10), a: 1 };
    } else {
      if (!(5 < e.length && e.substr(0, 5) === "RGBA(")) return null;
      i = e.replace("RGBA", "").replace(/\(/g, "").replace(/\)/g, "").split(","), t = { r: parseInt(i[0], 10), g: parseInt(i[1], 10), b: parseInt(i[2], 10), a: parseFloat(i[3]) };
    }
    return t;
  }
  hsv2rgb(e, t, i, n) {
    let r, o, a, l, c, h, d, u;
    switch (arguments.length === 1 && (t = e.s, i = e.v, n = e.a, e = e.h), h = (i /= 100) * (1 - (t /= 100)), d = i * (1 - (c = 6 * (e /= 360) - (l = Math.floor(6 * e))) * t), u = i * (1 - (1 - c) * t), l % 6) {
      case 0:
        r = i, o = u, a = h;
        break;
      case 1:
        r = d, o = i, a = h;
        break;
      case 2:
        r = h, o = i, a = u;
        break;
      case 3:
        r = h, o = d, a = i;
        break;
      case 4:
        r = u, o = h, a = i;
        break;
      case 5:
        r = i, o = h, a = d;
    }
    return { r: Math.round(255 * r), g: Math.round(255 * o), b: Math.round(255 * a), a: n ?? 1 };
  }
  rgb2hsv(e, t, i, n) {
    arguments.length === 1 && (t = e.g, i = e.b, n = e.a, e = e.r);
    let r = Math.max(e, t, i), o = Math.min(e, t, i), a = r - o, l, c = r === 0 ? 0 : a / r, h = r / 255;
    switch (r) {
      case o:
        l = 0;
        break;
      case e:
        l = t - i + a * (t < i ? 6 : 0), l /= 6 * a;
        break;
      case t:
        l = i - e + 2 * a, l /= 6 * a;
        break;
      case i:
        l = e - t + 4 * a, l /= 6 * a;
    }
    return { h: Math.round(360 * l), s: Math.round(100 * c), v: Math.round(100 * h), a: n ?? 1 };
  }
  tooltip(e, t) {
    let i = "mouseenter", n = "mouseleave";
    return t = (t = typeof e == "object" ? e : t) || {}, typeof e == "string" && (t.html = e), t.showOn && (i = t.showOn, delete t.showOn), t.hideOn && (n = t.hideOn, delete t.hideOn), t.name || (t.name = "no-name"), ` on${i}="w2tooltip.show(this, JSON.parse(w2utils.base64decode('${this.base64encode(JSON.stringify(t))}')))" on${n}="w2tooltip.hide('${t.name}')"`;
  }
  isPlainObject(e) {
    return e != null && Object.prototype.toString.call(e) === "[object Object]" && (e.constructor === void 0 || (e = Object.getPrototypeOf(e)) === null || e === Object.prototype);
  }
  clone(e, t) {
    let i;
    return t = Object.assign({ functions: true, elements: true, events: true, exclude: [] }, t ?? {}), Array.isArray(e) ? (i = Array.from(e)).forEach((n, r) => {
      i[r] = this.clone(n, t);
    }) : this.isPlainObject(e) ? (i = {}, Object.assign(i, e), t.exclude && t.exclude.forEach((n) => {
      delete i[n];
    }), Object.keys(i).forEach((n) => {
      i[n] = this.clone(i[n], t), i[n] === void 0 && delete i[n];
    })) : e instanceof Function && !t.functions || e instanceof Node && !t.elements || e instanceof Event && !t.events || (i = e), i;
  }
  extend(e, t) {
    if (Array.isArray(e)) {
      if (!Array.isArray(t)) throw new Error("Arrays can be extended with arrays only");
      e.splice(0, e.length), t.forEach((i) => {
        e.push(this.clone(i));
      });
    } else {
      if (e instanceof Node || e instanceof Event) throw new Error("HTML elmenents and events cannot be extended");
      if (e && typeof e == "object" && t != null) {
        if (typeof t != "object") throw new Error("Object can be extended with other objects only.");
        Object.keys(t).forEach((i) => {
          var n;
          e[i] != null && typeof e[i] == "object" && t[i] != null && typeof t[i] == "object" ? (n = this.clone(t[i]), e[i] instanceof Node || e[i] instanceof Event ? e[i] = n : (Array.isArray(e[i]) && this.isPlainObject(n) && (e[i] = {}), this.extend(e[i], n))) : e[i] = this.clone(t[i]);
        });
      } else if (t != null) throw new Error("Object is not extendable, only {} or [] can be extended.");
    }
    if (2 < arguments.length) for (let i = 2; i < arguments.length; i++) this.extend(e, arguments[i]);
    return e;
  }
  naturalCompare(e, t) {
    let i, n, r = 1, o = 0, a = 0, l = String.alphabet;
    function c(h, d, u) {
      if (u) {
        for (i = d; (u = c(h, i)) < 76 && 65 < u; ) ++i;
        return +h.slice(d - 1, i);
      }
      return -1 < (u = l && l.indexOf(h.charAt(d))) ? u + 76 : (u = h.charCodeAt(d) || 0) < 45 || 127 < u ? u : u < 46 ? 65 : u < 48 ? u - 1 : u < 58 ? u + 18 : u < 65 ? u - 11 : u < 91 ? u + 11 : u < 97 ? u - 37 : u < 123 ? u + 5 : u - 63;
    }
    if ((e += "") != (t += "")) {
      for (; r; ) if (n = c(e, o++), r = c(t, a++), n < 76 && r < 76 && 66 < n && 66 < r && (n = c(e, o, o), r = c(t, a, o = i), a = i), n != r) return n < r ? -1 : 1;
    }
    return 0;
  }
  normMenu(e, t) {
    return Array.isArray(e) ? (e.forEach((i, n) => {
      typeof i == "string" || typeof i == "number" ? e[n] = { id: i, text: String(i) } : i != null ? (i.caption != null && i.text == null && (i.text = i.caption), i.text != null && i.id == null && (i.id = i.text), i.text == null && i.id != null && (i.text = i.id)) : e[n] = { id: null, text: "null" };
    }), e) : typeof e == "function" ? (t = e.call(this, e, t), b.normMenu.call(this, t)) : typeof e == "object" ? Object.keys(e).map((i) => ({ id: i, text: e[i] })) : void 0;
  }
  prepareParams(e, t, i) {
    i = i ?? b.settings.dataType;
    let n = t.body;
    switch (i) {
      case "HTTPJSON":
        n = { request: n }, ["PUT", "DELETE"].includes(t.method) && (t.method = "POST"), r();
        break;
      case "HTTP":
        ["PUT", "DELETE"].includes(t.method) && (t.method = "POST"), r();
        break;
      case "RESTFULL":
        ["PUT", "DELETE"].includes(t.method) ? t.headers["Content-Type"] = "application/json" : r();
        break;
      case "JSON":
        t.method == "GET" ? (n = { request: n }, r()) : (t.headers["Content-Type"] = "application/json", t.method = "POST");
    }
    return t.body = typeof t.body == "string" ? t.body : JSON.stringify(t.body), t;
    function r() {
      Object.keys(n).forEach((o) => {
        let a = n[o];
        typeof a == "object" && (a = JSON.stringify(a)), e.searchParams.append(o, a);
      }), delete t.body;
    }
  }
  bindEvents(e, t) {
    e.length != 0 && ((e == null ? void 0 : e[0]) instanceof Node && (e = Array.isArray(e) ? e : e.get()), p(e).each((i) => {
      let n = p(i).data();
      Object.keys(n).forEach((r) => {
        if (["click", "dblclick", "mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mousemove", "mouseup", "contextmenu", "focus", "focusin", "focusout", "blur", "input", "change", "keydown", "keyup", "keypress"].indexOf(String(r).toLowerCase()) != -1) {
          let o = n[r], a = (o = typeof o == "string" ? o.split("|").map((l) => {
            (l = (l = (l = l === "true" ? true : l) === "false" ? false : l) === "undefined" ? void 0 : l) === "null" && (l = null);
            var c = ["'", '"', "`"];
            return l = typeof (l = parseFloat(l) == l ? parseFloat(l) : l) == "string" && c.includes(l[0]) && c.includes(l[l.length - 1]) ? l.substring(1, l.length - 1) : l;
          }) : o)[0];
          o = o.slice(1), p(i).off(r + ".w2utils-bind").on(r + ".w2utils-bind", function(l) {
            switch (a) {
              case "alert":
                alert(o[0]);
                break;
              case "stop":
                l.stopPropagation();
                break;
              case "prevent":
                l.preventDefault();
                break;
              case "stopPrevent":
                return l.stopPropagation(), l.preventDefault(), false;
              default:
                if (t[a] == null) throw new Error(`Cannot dispatch event as the method "${a}" does not exist.`);
                t[a].apply(t, o.map((c, h) => {
                  switch (String(c).toLowerCase()) {
                    case "event":
                      return l;
                    case "this":
                      return this;
                    default:
                      return c;
                  }
                }));
            }
          });
        }
      });
    }));
  }
  debounce(e, t = 250) {
    let i;
    return (...n) => {
      clearTimeout(i), i = setTimeout(() => {
        e(...n);
      }, t);
    };
  }
}
var b = new mM();
class gM extends Xn {
  constructor() {
    super(), this.defaults = { title: "", text: "", body: "", buttons: "", width: 450, height: 250, focus: null, actions: null, style: "", speed: 0.3, modal: false, maximized: false, keyboard: true, showClose: true, showMax: false, transition: null, openMaximized: false, moved: false }, this.name = "popup", this.status = "closed", this.onOpen = null, this.onClose = null, this.onMax = null, this.onMin = null, this.onToggle = null, this.onKeydown = null, this.onAction = null, this.onMove = null, this.tmp = {}, this.handleResize = (e) => {
      this.options.moved || this.center(void 0, void 0, true);
    };
  }
  open(e) {
    let t = this;
    this.status != "closing" && !p("#w2ui-popup").hasClass("animating") || this.close(true);
    var i = this.options;
    (e = ["string", "number"].includes(typeof e) ? b.extend({ title: "Notification", body: `<div class="w2ui-centered">${e}</div>`, actions: { Ok() {
      t.close();
    } }, cancelAction: "ok" }, arguments[1] ?? {}) : e).text != null && (e.body = `<div class="w2ui-centered w2ui-msg-text">${e.text}</div>`), e = Object.assign({}, this.defaults, i, { title: "", body: "" }, e, { maximized: false }), this.options = e, p("#w2ui-popup").length === 0 && (this.off("*"), Object.keys(this).forEach((h) => {
      h.startsWith("on") && h != "on" && (this[h] = null);
    })), Object.keys(e).forEach((h) => {
      h.startsWith("on") && h != "on" && e[h] && (this[h] = e[h]);
    }), e.width = parseInt(e.width), e.height = parseInt(e.height);
    let n, r, o;
    var { top: a, left: l } = this.center();
    let c = { self: this, action(h) {
      return t.on("action.prom", h), c;
    }, close(h) {
      return t.on("close.prom", h), c;
    }, then(h) {
      return t.on("open:after.prom", h), c;
    } };
    if (e.actions == null || e.buttons || (e.buttons = "", Object.keys(e.actions).forEach((h) => {
      var d = e.actions[h];
      let u = h;
      typeof d == "function" && (e.buttons += `<button class="w2ui-btn w2ui-eaction" data-click='["action","${h}","event"]'>${h}</button>`), typeof d == "object" && (e.buttons += `<button class="w2ui-btn w2ui-eaction ${d.class || ""}" name="${h}" data-click='["action","${h}","event"]'
                        style="${d.style}" ${d.attrs}>${d.text || h}</button>`, u = Array.isArray(e.actions) ? d.text : h), typeof d == "string" && (e.buttons += `<button class="w2ui-btn w2ui-eaction" data-click='["action","${d}","event"]'>${d}</button>`, u = d), typeof u == "string" && (u = u[0].toLowerCase() + u.substr(1).replace(/\s+/g, "")), c[u] = function(f) {
        return t.on("action.buttons", (m) => {
          m.detail.action[0].toLowerCase() + m.detail.action.substr(1).replace(/\s+/g, "") == u && f(m);
        }), c;
      };
    })), p("#w2ui-popup").length === 0) {
      if ((n = this.trigger("open", { target: "popup", present: false })).isCancelled === true) return;
      this.status = "opening", b.lock(document.body, { opacity: 0.3, onClick: e.modal ? null : () => {
        this.close();
      } });
      let h = "";
      e.showClose && (h += `<div class="w2ui-popup-button w2ui-popup-close">
                            <span class="w2ui-icon w2ui-icon-cross w2ui-eaction" data-mousedown="stop" data-click="close"></span>
                        </div>`), e.showMax && (h += `<div class="w2ui-popup-button w2ui-popup-max">
                            <span class="w2ui-icon w2ui-icon-box w2ui-eaction" data-mousedown="stop" data-click="toggle"></span>
                        </div>`), l = `
                left: ${l}px;
                top: ${a}px;
                width: ${parseInt(e.width)}px;
                height: ${parseInt(e.height)}px;
                transition: ${e.speed}s
            `, r = `<div id="w2ui-popup" class="w2ui-popup w2ui-anim-open animating" style="${b.stripSpaces(l)}"></div>`, p("body").append(r), p("#w2ui-popup")[0]._w2popup = { self: this, created: new Promise((d) => {
        this._promCreated = d;
      }), opened: new Promise((d) => {
        this._promOpened = d;
      }), closing: new Promise((d) => {
        this._promClosing = d;
      }), closed: new Promise((d) => {
        this._promClosed = d;
      }) }, l = `${e.title ? "" : "top: 0px !important;"} ` + (e.buttons ? "" : "bottom: 0px !important;"), r = `
                <span name="hidden-first" tabindex="0" style="position: absolute; top: -100px"></span>
                <div class="w2ui-popup-title-btns">${h}</div>
                <div class="w2ui-popup-title" style="${e.title ? "" : "display: none"}"></div>
                <div class="w2ui-box" style="${l}">
                    <div class="w2ui-popup-body ${!e.title || " w2ui-popup-no-title"}
                        ${!e.buttons || " w2ui-popup-no-buttons"}" style="${e.style}">
                    </div>
                </div>
                <div class="w2ui-popup-buttons" style="${e.buttons ? "" : "display: none"}"></div>
                <span name="hidden-last" tabindex="0" style="position: absolute; top: -100px"></span>
            `, p("#w2ui-popup").html(r), e.title && p("#w2ui-popup .w2ui-popup-title").append(b.lang(e.title)), e.buttons && p("#w2ui-popup .w2ui-popup-buttons").append(e.buttons), e.body && p("#w2ui-popup .w2ui-popup-body").append(e.body), setTimeout(() => {
        p("#w2ui-popup").css("transition", e.speed + "s").removeClass("w2ui-anim-open"), b.bindEvents("#w2ui-popup .w2ui-eaction", this), p("#w2ui-popup").find(".w2ui-popup-body").show(), this._promCreated();
      }, 1), clearTimeout(this._timer), this._timer = setTimeout(() => {
        this.status = "open", t.setFocus(e.focus), n.finish(), this._promOpened(), p("#w2ui-popup").removeClass("animating");
      }, 1e3 * e.speed);
    } else {
      if ((n = this.trigger("open", { target: "popup", present: true })).isCancelled === true) return;
      this.status = "opening", i != null && (i.maximized || i.width == e.width && i.height == e.height || this.resize(e.width, e.height), e.prevSize = e.width + "px:" + e.height + "px", e.maximized = i.maximized), a = p("#w2ui-popup .w2ui-box").get(0).cloneNode(true), p(a).removeClass("w2ui-box").addClass("w2ui-box-temp").find(".w2ui-popup-body").empty().append(e.body), p("#w2ui-popup .w2ui-box").after(a), e.buttons ? (p("#w2ui-popup .w2ui-popup-buttons").show().html("").append(e.buttons), p("#w2ui-popup .w2ui-popup-body").removeClass("w2ui-popup-no-buttons"), p("#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp").css("bottom", "")) : (p("#w2ui-popup .w2ui-popup-buttons").hide().html(""), p("#w2ui-popup .w2ui-popup-body").addClass("w2ui-popup-no-buttons"), p("#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp").css("bottom", "0px")), e.title ? (p("#w2ui-popup .w2ui-popup-title").show().html((e.showClose ? `<div class="w2ui-popup-button w2ui-popup-close">
                                <span class="w2ui-icon w2ui-icon-cross w2ui-eaction" data-mousedown="stop" data-click="close"></span>
                            </div>` : "") + (e.showMax ? `<div class="w2ui-popup-button w2ui-popup-max">
                                <span class="w2ui-icon w2ui-icon-box w2ui-eaction" data-mousedown="stop" data-click="toggle"></span>
                            </div>` : "")).append(e.title), p("#w2ui-popup .w2ui-popup-body").removeClass("w2ui-popup-no-title"), p("#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp").css("top", "")) : (p("#w2ui-popup .w2ui-popup-title").hide().html(""), p("#w2ui-popup .w2ui-popup-body").addClass("w2ui-popup-no-title"), p("#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp").css("top", "0px"));
      let h = p("#w2ui-popup .w2ui-box")[0], d = p("#w2ui-popup .w2ui-box-temp")[0];
      p("#w2ui-popup").addClass("animating"), b.transition(h, d, e.transition, () => {
        p(h).remove(), p(d).removeClass("w2ui-box-temp").addClass("w2ui-box");
        var u = p(d).find(".w2ui-popup-body");
        u.length == 1 && (u[0].style.cssText = e.style, u.show()), t.setFocus(e.focus), p("#w2ui-popup").removeClass("animating");
      }), this.status = "open", n.finish(), b.bindEvents("#w2ui-popup .w2ui-eaction", this), p("#w2ui-popup").find(".w2ui-popup-body").show();
    }
    return e.openMaximized && this.max(), e._last_focus = document.activeElement, e.keyboard && p(document.body).on("keydown", (h) => {
      this.keydown(h);
    }), p(window).on("resize", this.handleResize), o = { resizing: false, mvMove: function(h) {
      o.resizing == 1 && (h = h || window.event, o.div_x = h.screenX - o.x, o.div_y = h.screenY - o.y, (h = t.trigger("move", { target: "popup", div_x: o.div_x, div_y: o.div_y, originalEvent: h })).isCancelled !== true) && (p("#w2ui-popup").css({ transition: "none", transform: "translate3d(" + o.div_x + "px, " + o.div_y + "px, 0px)" }), t.options.moved = true, h.finish());
    }, mvStop: function(h) {
      o.resizing != 1 || (h = h || window.event, t.status = "open", o.div_x = h.screenX - o.x, o.div_y = h.screenY - o.y, p("#w2ui-popup").css({ left: o.pos_x + o.div_x + "px", top: o.pos_y + o.div_y + "px" }).css({ transition: "none", transform: "translate3d(0px, 0px, 0px)" }), o.resizing = false, p(document.body).off(".w2ui-popup"), o.isLocked) || t.unlock();
    } }, p("#w2ui-popup .w2ui-popup-title").on("mousedown", function(h) {
      var d;
      t.options.maximized || (h = (h = h) || window.event, t.status = "moving", d = p("#w2ui-popup").get(0).getBoundingClientRect(), Object.assign(o, { resizing: true, isLocked: p("#w2ui-popup > .w2ui-lock").length == 1, x: h.screenX, y: h.screenY, pos_x: d.x, pos_y: d.y }), o.isLocked || t.lock({ opacity: 0 }), p(document.body).on("mousemove.w2ui-popup", o.mvMove).on("mouseup.w2ui-popup", o.mvStop), h.stopPropagation ? h.stopPropagation() : h.cancelBubble = true, h.preventDefault && h.preventDefault());
    }), c;
  }
  load(e) {
    return new Promise((t, i) => {
      if ((e = typeof e == "string" ? { url: e } : e).url == null) console.log("ERROR: The url is not defined."), i("The url is not defined");
      else {
        this.status = "loading";
        let [n, r] = String(e.url).split("#");
        n && fetch(n).then((o) => o.text()).then((o) => {
          t(this.template(o, r, e));
        });
      }
    });
  }
  template(e, t, i = {}) {
    let n;
    try {
      n = p(e);
    } catch {
      n = p.html(e);
    }
    return t && (n = n.filter("#" + t)), Object.assign(i, { width: parseInt(p(n).css("width")), height: parseInt(p(n).css("height")), title: p(n).find("[rel=title]").html(), body: p(n).find("[rel=body]").html(), buttons: p(n).find("[rel=buttons]").html(), style: p(n).find("[rel=body]").get(0).style.cssText }), this.open(i);
  }
  action(e, t) {
    let i = this.options.actions[e];
    i instanceof Object && i.onClick && (i = i.onClick), e = this.trigger("action", { action: e, target: "popup", self: this, originalEvent: t, value: this.input ? this.input.value : null }), e.isCancelled !== true && (typeof i == "function" && i.call(this, t), e.finish());
  }
  keydown(e) {
    var t;
    this.options && !this.options.keyboard || (t = this.trigger("keydown", { target: "popup", originalEvent: e })).isCancelled !== true && (e.keyCode === 27 && (e.preventDefault(), p("#w2ui-popup .w2ui-message").length == 0) && (this.options.cancelAction ? this.action(this.options.cancelAction) : this.close()), t.finish());
  }
  close(e) {
    let t = this.trigger("close", { target: "popup" });
    var i;
    t.isCancelled !== true && (i = () => {
      p("#w2ui-popup").remove(), this.options._last_focus && 0 < this.options._last_focus.length && this.options._last_focus.focus(), this.status = "closed", this.options = {}, t.finish(), this._promClosed();
    }, p("#w2ui-popup").length !== 0) && this.status != "closed" && (this.status == "opening" && (e = true), this.status == "closing" && e === true ? (i(), clearTimeout(this.tmp.closingTimer), b.unlock(document.body, 0)) : (this.status = "closing", p("#w2ui-popup").css("transition", this.options.speed + "s").addClass("w2ui-anim-close animating"), b.unlock(document.body, 300), this._promClosing(), e ? i() : this.tmp.closingTimer = setTimeout(i, 1e3 * this.options.speed), this.options.keyboard && p(document.body).off("keydown", this.keydown), p(window).off("resize", this.handleResize)));
  }
  toggle() {
    let e = this.trigger("toggle", { target: "popup" });
    e.isCancelled !== true && (this.options.maximized === true ? this.min() : this.max(), setTimeout(() => {
      e.finish();
    }, 1e3 * this.options.speed + 50));
  }
  max() {
    if (this.options.maximized !== true) {
      let t = this.trigger("max", { target: "popup" });
      var e;
      t.isCancelled !== true && (this.status = "resizing", e = p("#w2ui-popup").get(0).getBoundingClientRect(), this.options.prevSize = e.width + ":" + e.height, this.resize(1e4, 1e4, () => {
        this.status = "open", this.options.maximized = true, t.finish();
      }));
    }
  }
  min() {
    if (this.options.maximized === true) {
      var e = this.options.prevSize.split(":");
      let t = this.trigger("min", { target: "popup" });
      t.isCancelled !== true && (this.status = "resizing", this.options.maximized = false, this.resize(parseInt(e[0]), parseInt(e[1]), () => {
        this.status = "open", this.options.prevSize = null, t.finish();
      }));
    }
  }
  clear() {
    p("#w2ui-popup .w2ui-popup-title").html(""), p("#w2ui-popup .w2ui-popup-body").html(""), p("#w2ui-popup .w2ui-popup-buttons").html("");
  }
  reset() {
    this.open(this.defaults);
  }
  message(e) {
    return b.message({ owner: this, box: p("#w2ui-popup").get(0), after: ".w2ui-popup-title" }, e);
  }
  confirm(e) {
    return b.confirm({ owner: this, box: p("#w2ui-popup"), after: ".w2ui-popup-title" }, e);
  }
  setFocus(e) {
    var _a2;
    let t = p("#w2ui-popup"), i = "input, button, select, textarea, [contentEditable], .w2ui-input";
    e != null ? (_a2 = isNaN(e) ? t.find(i).filter(e).get(0) : t.find(i).get(e)) == null ? void 0 : _a2.focus() : (e = t.find("[name=hidden-first]").get(0)) && e.focus(), p(t).find(i + ",[name=hidden-first],[name=hidden-last]").off(".keep-focus").on("blur.keep-focus", function(n) {
      setTimeout(() => {
        var _a3, _b2, _c2;
        var r = document.activeElement, o = 0 < p(t).find(i).filter(r).length, a = p(r).attr("name");
        !o && r && r !== document.body && ((_a3 = p(t).find(i).get(0)) == null ? void 0 : _a3.focus()), a == "hidden-last" && ((_b2 = p(t).find(i).get(0)) == null ? void 0 : _b2.focus()), a == "hidden-first" && ((_c2 = p(t).find(i).get(-1)) == null ? void 0 : _c2.focus());
      }, 1);
    });
  }
  lock(e, t) {
    var i = Array.from(arguments);
    i.unshift(p("#w2ui-popup")), b.lock(...i);
  }
  unlock(e) {
    b.unlock(p("#w2ui-popup"), e);
  }
  center(e, t, i) {
    let n, r;
    r = window.innerHeight == null ? (n = parseInt(document.documentElement.offsetWidth), parseInt(document.documentElement.offsetHeight)) : (n = parseInt(window.innerWidth), parseInt(window.innerHeight)), e = parseInt(e ?? this.options.width), t = parseInt(t ?? this.options.height), this.options.maximized === true && (e = n, t = r), n - 10 < e && (e = n - 10), r - 10 < t && (t = r - 10);
    var o = (r - t) / 2, a = (n - e) / 2;
    return i && (p("#w2ui-popup").css({ transition: "none", top: o + "px", left: a + "px", width: e + "px", height: t + "px" }), this.resizeMessages()), { top: o, left: a, width: e, height: t };
  }
  resize(r, o, i) {
    let n = this;
    this.options.speed == null && (this.options.speed = 0);
    var { top: r, left: o, width: a, height: l } = this.center(r, o), c = this.options.speed;
    p("#w2ui-popup").css({ transition: c + `s width, ${c}s height, ${c}s left, ${c}s top`, top: r + "px", left: o + "px", width: a + "px", height: l + "px" });
    let h = setInterval(() => {
      n.resizeMessages();
    }, 10);
    setTimeout(() => {
      clearInterval(h), n.resizeMessages(), typeof i == "function" && i();
    }, 1e3 * this.options.speed + 50);
  }
  resizeMessages() {
    p("#w2ui-popup .w2ui-message").each((e) => {
      var t = e._msg_options, i = p("#w2ui-popup"), r = (parseInt(t.width) < 10 && (t.width = 10), parseInt(t.height) < 10 && (t.height = 10), i[0].getBoundingClientRect()), i = parseInt(i.find(".w2ui-popup-title")[0].clientHeight), n = parseInt(r.width), r = parseInt(r.height);
      t.width = t.originalWidth, t.width > n - 10 && (t.width = n - 10), t.height = t.originalHeight, t.height > r - i - 5 && (t.height = r - i - 5), t.originalHeight < 0 && (t.height = r + t.originalHeight - i), t.originalWidth < 0 && (t.width = n + 2 * t.originalWidth), p(e).css({ left: (n - t.width) / 2 + "px", width: t.width + "px", height: t.height + "px" });
    });
  }
}
new gM();
const _qe = class _qe {
  constructor() {
    this.defaults = { name: null, html: "", style: "", class: "", position: "top|bottom", align: "", anchor: null, anchorClass: "", anchorStyle: "", autoShow: false, autoShowOn: null, autoHideOn: null, arrowSize: 8, margin: 0, margin: 1, screenMargin: 2, autoResize: true, offsetX: 0, offsetY: 0, maxWidth: null, maxHeight: null, watchScroll: null, watchResize: null, hideOn: null, onThen: null, onShow: null, onHide: null, onUpdate: null, onMove: null };
  }
  trigger(e, t) {
    var i;
    if (arguments.length == 2 && (i = e, (e = t).type = i), e.overlay) return e.overlay.trigger(e);
    console.log("ERROR: cannot find overlay where to trigger events");
  }
  get(e) {
    return arguments.length == 0 ? Object.keys(_qe.active) : e === true ? _qe.active : _qe.active[e.replace(/[\s\.#]/g, "_")];
  }
  attach(e, t) {
    let i, n, r = this;
    if (arguments.length != 0) {
      arguments.length == 1 && e.anchor ? e = (i = e).anchor : arguments.length === 2 && typeof t == "string" ? t = (i = { anchor: e, html: t }).html : arguments.length === 2 && t != null && typeof t == "object" && (t = (i = t).html), i = b.extend({}, this.defaults, i || {}), !(t = !t && i.text ? i.text : t) && i.html && (t = i.html), delete i.anchor;
      let o = i.name || e.id;
      e != document && e != document.body || (e = document.body, o = "context-menu"), o || (o = "noname-" + Object.keys(_qe.active).length, console.log("NOTICE: name property is not defined for tooltip, could lead to too many instances")), o = o.replace(/[\s\.#]/g, "_"), _qe.active[o] ? ((n = _qe.active[o]).prevOptions = n.options, n.options = i, n.anchor = e, n.prevOptions.html == n.options.html && n.prevOptions.class == n.options.class && n.prevOptions.style == n.options.style || (n.needsUpdate = true), i = n.options) : (n = new Xn(), Object.assign(n, { id: "w2overlay-" + o, name: o, options: i, anchor: e, displayed: false, tmp: { observeResize: new ResizeObserver(() => {
        this.resize(n.name);
      }) }, hide() {
        r.hide(o);
      } }), _qe.active[o] = n), Object.keys(n.options).forEach((l) => {
        var c = n.options[l];
        l.startsWith("on") && typeof c == "function" && (n[l] = c, delete n.options[l]);
      }), i.autoShow === true && (i.autoShowOn = i.autoShowOn ?? "mouseenter", i.autoHideOn = i.autoHideOn ?? "mouseleave", i.autoShow = false), i.autoShowOn && (t = "autoShow-" + n.name, p(e).off("." + t).on(i.autoShowOn + "." + t, (l) => {
        r.show(n.name), l.stopPropagation();
      }), delete i.autoShowOn), i.autoHideOn && (t = "autoHide-" + n.name, p(e).off("." + t).on(i.autoHideOn + "." + t, (l) => {
        r.hide(n.name), l.stopPropagation();
      }), delete i.autoHideOn), n.off(".attach");
      let a = { overlay: n, then: (l) => (n.on("show:after.attach", (c) => {
        l(c);
      }), a), show: (l) => (n.on("show.attach", (c) => {
        l(c);
      }), a), hide: (l) => (n.on("hide.attach", (c) => {
        l(c);
      }), a), update: (l) => (n.on("update.attach", (c) => {
        l(c);
      }), a), move: (l) => (n.on("move.attach", (c) => {
        l(c);
      }), a) };
      return a;
    }
  }
  update(e, t) {
    var i = _qe.active[e];
    i ? (i.needsUpdate = true, i.options.html = t, this.show(e)) : console.log(`Tooltip "${e}" is not displayed. Cannot update it.`);
  }
  show(e) {
    if (e instanceof HTMLElement || e instanceof Object) {
      let a = e, l = (e instanceof HTMLElement && ((a = arguments[1] || {}).anchor = e), this.attach(a));
      return p(l.overlay.anchor).off(".autoShow-" + l.overlay.name).off(".autoHide-" + l.overlay.name), setTimeout(() => {
        this.show(l.overlay.name), this.initControls && this.initControls(l.overlay);
      }, 1), l;
    }
    let t, i = this, n = _qe.active[e.replace(/[\s\.#]/g, "_")];
    if (n) {
      let a = n.options;
      if (!n || n.displayed && !n.needsUpdate) this.resize(n == null ? void 0 : n.name);
      else {
        var r = a.position.split("|"), r = ["top", "bottom"].includes(r[0]);
        let l = a.align == "both" && r ? "" : "white-space: nowrap;";
        if (a.maxWidth && b.getStrWidth(a.html, "") > a.maxWidth && (l = "width: " + a.maxWidth + "px; white-space: inherit; overflow: auto;"), l += " max-height: " + (a.maxHeight || window.innerHeight - 40) + "px;", a.html !== "" && a.html != null) {
          if (n.box) {
            if ((t = this.trigger("update", { target: e, overlay: n })).isCancelled === true) return void (n.prevOptions && (n.options = n.prevOptions, delete n.prevOptions));
            p(n.box).find(".w2ui-overlay-body").attr("style", (a.style || "") + "; " + l).removeClass().addClass("w2ui-overlay-body " + a.class).html(a.html);
          } else {
            if ((t = this.trigger("show", { target: e, overlay: n })).isCancelled === true) return;
            p("body").append(`<div id="${n.id}" name="${e}" style="display: none; pointer-events: none" class="w2ui-overlay"
                        data-click="stop" data-focusin="stop">
                    <style></style>
                    <div class="w2ui-overlay-body ${a.class}" style="${a.style || ""}; ${l}">
                        ${a.html}
                    </div>
                </div>`), n.box = p("#" + b.escapeId(n.id))[0], n.displayed = true, r = p(n.anchor).data("tooltipName") ?? [], r.push(e), p(n.anchor).data("tooltipName", r), b.bindEvents(n.box, {}), n.tmp.originalCSS = "", 0 < p(n.anchor).length && (n.tmp.originalCSS = p(n.anchor)[0].style.cssText);
          }
          this.resize(n.name), a.anchorStyle && (n.anchor.style.cssText += ";" + a.anchorStyle), !a.anchorClass || a.anchorClass == "w2ui-focus" && n.anchor == document.body || p(n.anchor).addClass(a.anchorClass), typeof a.hideOn == "string" && (a.hideOn = [a.hideOn]), Array.isArray(a.hideOn) || (a.hideOn = []), Object.assign(n.tmp, { scrollLeft: document.body.scrollLeft, scrollTop: document.body.scrollTop });
          {
            let c = (u) => {
              i.hide(n.name);
            }, h = p(n.anchor), d = "tooltip-" + n.name;
            p("body").off("." + d), a.hideOn.includes("doc-click") && (["INPUT", "TEXTAREA"].includes(n.anchor.tagName) && h.off(`.${d}-doc`).on(`click.${d}-doc`, (u) => {
              u.stopPropagation();
            }), p("body").on("click." + d, c)), a.hideOn.includes("focus-change") && p("body").on("focusin." + d, (u) => {
              document.activeElement != n.anchor && i.hide(n.name);
            }), ["INPUT", "TEXTAREA"].includes(n.anchor.tagName) && (h.off("." + d), a.hideOn.forEach((u) => {
              ["doc-click", "focus-change"].indexOf(u) == -1 && h.on(u + "." + d, { once: true }, c);
            }));
          }
          {
            var o = document.body;
            let c = "tooltip-" + n.name, h = o;
            o.tagName == "BODY" && (h = o.ownerDocument), p(h).off("." + c).on("scroll." + c, (d) => {
              Object.assign(n.tmp, { scrollLeft: o.scrollLeft, scrollTop: o.scrollTop }), i.resize(n.name);
            });
          }
          return p(n.box).show(), n.tmp.observeResize.observe(n.box), _qe.observeRemove.observe(document.body, { subtree: true, childList: true }), p(n.box).css("opacity", 1).find(".w2ui-overlay-body").html(a.html), setTimeout(() => {
            p(n.box).css({ "pointer-events": "auto" }).data("ready", "yes");
          }, 100), delete n.needsUpdate, n.box.overlay = n, t && t.finish(), { overlay: n };
        }
        i.hide(e);
      }
    }
  }
  hide(e) {
    var _a2;
    let t;
    if (arguments.length == 0) Object.keys(_qe.active).forEach((r) => {
      this.hide(r);
    });
    else if (e instanceof HTMLElement) (p(e).data("tooltipName") ?? []).forEach((r) => {
      this.hide(r);
    });
    else if (typeof e == "string" && (e = e.replace(/[\s\.#]/g, "_"), t = _qe.active[e]), t && t.box && (delete _qe.active[e], e = this.trigger("hide", { target: e, overlay: t }), e.isCancelled !== true)) {
      var i = "tooltip-" + t.name;
      (_a2 = t.tmp.observeResize) == null ? void 0 : _a2.disconnect(), t.options.watchScroll && p(t.options.watchScroll).off(".w2scroll-" + t.name);
      let r = 0;
      Object.keys(_qe.active).forEach((o) => {
        _qe.active[o].displayed && r++;
      }), r == 0 && _qe.observeRemove.disconnect(), p("body").off("." + i), p(document).off("." + i), t.box.remove(), t.box = null, t.displayed = false;
      var n = p(t.anchor).data("tooltipName") ?? [];
      n.indexOf(t.name) != -1 && n.splice(n.indexOf(t.name), 1), n.length == 0 ? p(t.anchor).removeData("tooltipName") : p(t.anchor).data("tooltipName", n), t.anchor.style.cssText = t.tmp.originalCSS, p(t.anchor).off("." + i).removeClass(t.options.anchorClass), e.finish();
    }
  }
  resize(e) {
    if (arguments.length == 0) Object.keys(_qe.active).forEach((n) => {
      n = _qe.active[n], n.displayed && this.resize(n.name);
    });
    else {
      var t = _qe.active[e.replace(/[\s\.#]/g, "_")];
      let n = this.getPosition(t.name);
      var i = n.left + "x" + n.top;
      let r;
      t.tmp.lastPos != i && (r = this.trigger("move", { target: e, overlay: t, pos: n })), p(t.box).css({ left: n.left + "px", top: n.top + "px" }).then((o) => {
        n.width != null && o.css("width", n.width + "px").find(".w2ui-overlay-body").css("width", "100%"), n.height != null && o.css("height", n.height + "px").find(".w2ui-overlay-body").css("height", "100%");
      }).find(".w2ui-overlay-body").removeClass("w2ui-arrow-right w2ui-arrow-left w2ui-arrow-top w2ui-arrow-bottom").addClass(n.arrow.class).closest(".w2ui-overlay").find("style").text(n.arrow.style), t.tmp.lastPos != i && r && (t.tmp.lastPos = i, r.finish());
    }
  }
  getPosition(e) {
    let t = _qe.active[e.replace(/[\s\.#]/g, "_")];
    if (t && t.box) {
      let d = t.options;
      (t.tmp.resizedY || t.tmp.resizedX) && p(t.box).css({ width: "", height: "", scroll: "auto" });
      var e = b.scrollBarSize(), i = document.body.scrollWidth != document.body.clientWidth, n = document.body.scrollHeight != document.body.clientHeight;
      let f = { width: window.innerWidth - (n ? e : 0), height: window.innerHeight - (i ? e : 0) };
      var r, o = (d.position == "auto" ? "top|bottom|right|left" : d.position).split("|");
      let m = ["top", "bottom"].includes(o[0]), _ = t.box.getBoundingClientRect(), g = t.anchor.getBoundingClientRect(), v = (t.anchor == document.body && ({ x: a, y: l, width: c, height: h } = d.originalEvent, g = { left: a - 2, top: l - 4, width: c, height: h, arrow: "none" }), d.arrowSize), y = (g.arrow == "none" && (v = 0), { top: g.top, bottom: f.height - (g.top + g.height) - +(i ? e : 0), left: g.left, right: f.width - (g.left + g.width) + (n ? e : 0) });
      _.width < 22 && (_.width = 22), _.height < 14 && (_.height = 14);
      let x, S, A, R, C = "", P = { offset: 0, class: "", style: `#${t.id} { --tip-size: ${v}px; }` }, z = { left: 0, top: 0 }, w = { posX: "", x: 0, posY: "", y: 0 };
      o.forEach((E) => {
        ["top", "bottom"].includes(E) && (!C && _.height + v / 1.893 < y[E] && (C = E), y[E] > w.y) && Object.assign(w, { posY: E, y: y[E] }), ["left", "right"].includes(E) && (!C && _.width + v / 1.893 < y[E] && (C = E), y[E] > w.x) && Object.assign(w, { posX: E, x: y[E] });
      }), C = C || (m ? w.posY : w.posX), d.autoResize && (["top", "bottom"].includes(C) && (_.height > y[C] ? (R = y[C], t.tmp.resizedY = true) : t.tmp.resizedY = false), ["left", "right"].includes(C)) && (_.width > y[C] ? (A = y[C], t.tmp.resizedX = true) : t.tmp.resizedX = false);
      var a = C;
      switch (P.class = g.arrow || "w2ui-arrow-" + a, a) {
        case "top":
          x = g.left + (g.width - (A ?? _.width)) / 2, S = g.top - (R ?? _.height) - v / 1.5 + 1;
          break;
        case "bottom":
          x = g.left + (g.width - (A ?? _.width)) / 2, S = g.top + g.height + v / 1.25 + 1;
          break;
        case "left":
          x = g.left - (A ?? _.width) - v / 1.2 - 1, S = g.top + (g.height - (R ?? _.height)) / 2;
          break;
        case "right":
          x = g.left + g.width + v / 1.2 + 1, S = g.top + (g.height - (R ?? _.height)) / 2;
      }
      m && (d.align == "left" && (z.left = g.left - x, x = g.left), d.align == "right" && (z.left = g.left + g.width - (A ?? _.width) - x, x = g.left + g.width - (A ?? _.width)), ["top", "bottom"].includes(C) && d.align.startsWith("both") && (r = d.align.split(":")[1] ?? 50, g.width >= r) && (x = g.left, A = g.width), d.align == "top" && (z.top = g.top - S, S = g.top), d.align == "bottom" && (z.top = g.top + g.height - (R ?? _.height) - S, S = g.top + g.height - (R ?? _.height)), ["left", "right"].includes(C) && d.align.startsWith("both") && (r = d.align.split(":")[1] ?? 50, g.height >= r) && (S = g.top, R = g.height));
      {
        let E;
        (["left", "right"].includes(d.align) && g.width < (A ?? _.width) || ["top", "bottom"].includes(d.align) && g.height < (R ?? _.height)) && (E = true);
        var l = C == "right" ? v : d.screenMargin, c = C == "bottom" ? v : d.screenMargin, h = f.width - (A ?? _.width) - (C == "left" ? v : d.screenMargin), i = f.height - (R ?? _.height) - (C == "top" ? v : d.screenMargin) + 3;
        (["top", "bottom"].includes(C) || d.autoResize) && (x < l && (E = true, z.left -= x, x = l), x > h) && (E = true, z.left -= x - h, x += h - x), (["left", "right"].includes(C) || d.autoResize) && (S < c && (E = true, z.top -= S, S = c), S > i) && (E = true, z.top -= S - i, S += i - S), E && (l = m ? "left" : "top", h = m ? "width" : "height", P.offset = -z[l], c = _[h] / 2 - v, Math.abs(P.offset) > c + v && (P.class = ""), Math.abs(P.offset) > c && (P.offset = P.offset < 0 ? -c : c), P.style = b.stripSpaces(`#${t.id} .w2ui-overlay-body:after,
                            #${t.id} .w2ui-overlay-body:before {
                                --tip-size: ${v}px;
                                margin-${l}: ${P.offset}px;
                            }`));
      }
      return n = C == "top" ? -d.margin : C == "bottom" ? d.margin : 0, e = C == "left" ? -d.margin : C == "right" ? d.margin : 0, S = Math.floor(100 * (S + parseFloat(d.offsetY) + parseFloat(n))) / 100, { left: x = Math.floor(100 * (x + parseFloat(d.offsetX) + parseFloat(e))) / 100, top: S, arrow: P, adjust: z, width: A, height: R, pos: C };
    }
  }
};
__publicField(_qe, "active", {});
__publicField(_qe, "observeRemove", new MutationObserver((e) => {
  let t = 0;
  Object.keys(_qe.active).forEach((i) => {
    i = _qe.active[i], i.displayed && (i.anchor && i.anchor.isConnected ? t++ : i.hide());
  }), t === 0 && _qe.observeRemove.disconnect();
}));
let qe = _qe;
class vM extends qe {
  constructor() {
    super(), this.palette = [["000000", "333333", "555555", "777777", "888888", "999999", "AAAAAA", "CCCCCC", "DDDDDD", "EEEEEE", "F7F7F7", "FFFFFF"], ["FF011B", "FF9838", "FFC300", "FFFD59", "86FF14", "14FF7A", "2EFFFC", "2693FF", "006CE7", "9B24F4", "FF21F5", "FF0099"], ["FFEAEA", "FCEFE1", "FCF4DC", "FFFECF", "EBFFD9", "D9FFE9", "E0FFFF", "E8F4FF", "ECF4FC", "EAE6F4", "FFF5FE", "FCF0F7"], ["F4CCCC", "FCE5CD", "FFF1C2", "FFFDA1", "D5FCB1", "B5F7D0", "BFFFFF", "D6ECFF", "CFE2F3", "D9D1E9", "FFE3FD", "FFD9F0"], ["EA9899", "F9CB9C", "FFE48C", "F7F56F", "B9F77E", "84F0B1", "83F7F7", "B5DAFF", "9FC5E8", "B4A7D6", "FAB9F6", "FFADDE"], ["E06666", "F6B26B", "DEB737", "E0DE51", "8FDB48", "52D189", "4EDEDB", "76ACE3", "6FA8DC", "8E7CC3", "E07EDA", "F26DBD"], ["CC0814", "E69138", "AB8816", "B5B20E", "6BAB30", "27A85F", "1BA8A6", "3C81C7", "3D85C6", "674EA7", "A14F9D", "BF4990"], ["99050C", "B45F17", "80650E", "737103", "395E14", "10783D", "13615E", "094785", "0A5394", "351C75", "780172", "782C5A"]], this.defaults = b.extend({}, this.defaults, { advanced: false, transparent: true, position: "top|bottom", class: "w2ui-white", color: "", liveUpdate: true, arrowSize: 12, autoResize: false, anchorClass: "w2ui-focus", autoShowOn: "focus", hideOn: ["doc-click", "focus-change"], onSelect: null, onLiveUpdate: null });
  }
  attach(e, t) {
    let i;
    arguments.length == 1 && e.anchor ? e = (i = e).anchor : arguments.length === 2 && t != null && typeof t == "object" && ((i = t).anchor = e), t = i.hideOn, i = b.extend({}, this.defaults, i || {}), t && (i.hideOn = t), i.style += "; padding: 0;", i.transparent && this.palette[0][1] == "333333" && (this.palette[0].splice(1, 1), this.palette[0].push("")), i.transparent || this.palette[0][1] == "333333" || (this.palette[0].splice(1, 0, "333333"), this.palette[0].pop()), i.color && (i.color = String(i.color).toUpperCase()), typeof i.color == "string" && i.color.substr(0, 1) === "#" && (i.color = i.color.substr(1)), this.index = [-1, -1];
    let n = super.attach(i), r = n.overlay;
    return r.options.html = this.getColorHTML(r.name, i), r.on("show.attach", (a) => {
      var a = a.detail.overlay, l = a.anchor, c = a.options;
      ["INPUT", "TEXTAREA"].includes(l.tagName) && !c.color && l.value && (a.tmp.initColor = l.value), delete a.newColor;
    }), r.on("show:after.attach", (o) => {
      var _a2;
      var a;
      ((_a2 = n.overlay) == null ? void 0 : _a2.box) && (a = p(n.overlay.box).find(".w2ui-eaction"), b.bindEvents(a, this), this.initControls(n.overlay));
    }), r.on("update:after.attach", (o) => {
      var _a2;
      var a;
      ((_a2 = n.overlay) == null ? void 0 : _a2.box) && (a = p(n.overlay.box).find(".w2ui-eaction"), b.bindEvents(a, this), this.initControls(n.overlay));
    }), r.on("hide.attach", (a) => {
      var a = a.detail.overlay, c = a.anchor, l = a.newColor ?? a.options.color ?? "", c = (["INPUT", "TEXTAREA"].includes(c.tagName) && c.value != l && (c.value = l), this.trigger("select", { color: l, target: a.name, overlay: a }));
      c.isCancelled !== true && c.finish();
    }), n.liveUpdate = (o) => (r.on("liveUpdate.attach", (a) => {
      o(a);
    }), n), n.select = (o) => (r.on("select.attach", (a) => {
      o(a);
    }), n), n;
  }
  select(e, r) {
    let i;
    this.index = [-1, -1], typeof r != "string" && (i = r.target, this.index = p(i).attr("index").split(":"), r = p(i).closest(".w2ui-overlay").attr("name"));
    var n = this.get(r), r = this.trigger("liveUpdate", { color: e, target: r, overlay: n, param: arguments[1] });
    r.isCancelled !== true && (["INPUT", "TEXTAREA"].includes(n.anchor.tagName) && n.options.liveUpdate && p(n.anchor).val(e), n.newColor = e, p(n.box).find(".w2ui-selected").removeClass("w2ui-selected"), i && p(i).addClass("w2ui-selected"), r.finish());
  }
  nextColor(e) {
    var t = this.palette;
    switch (e) {
      case "up":
        this.index[0]--;
        break;
      case "down":
        this.index[0]++;
        break;
      case "right":
        this.index[1]++;
        break;
      case "left":
        this.index[1]--;
    }
    return this.index[0] < 0 && (this.index[0] = 0), this.index[0] > t.length - 2 && (this.index[0] = t.length - 2), this.index[1] < 0 && (this.index[1] = 0), this.index[1] > t[0].length - 1 && (this.index[1] = t[0].length - 1), t[this.index[0]][this.index[1]];
  }
  tabClick(e, i) {
    typeof i != "string" && (i = p(i.target).closest(".w2ui-overlay").attr("name"));
    var i = this.get(i), n = p(i.box).find(`.w2ui-color-tab:nth-child(${e})`);
    p(i.box).find(".w2ui-color-tab").removeClass("w2ui-selected"), p(n).addClass("w2ui-selected"), p(i.box).find(".w2ui-tab-content").hide().closest(".w2ui-colors").find(".tab-" + e).show();
  }
  getColorHTML(e, t) {
    let i = `
            <div class="w2ui-colors">
                <div class="w2ui-tab-content tab-1">`;
    for (let r = 0; r < this.palette.length; r++) {
      i += '<div class="w2ui-color-row">';
      for (let o = 0; o < this.palette[r].length; o++) {
        var n = this.palette[r][o];
        let a = n === "FFFFFF" ? "; border: 1px solid #efefef" : "";
        i += `
                    <div class="w2ui-color w2ui-eaction ${n === "" ? "w2ui-no-color" : ""} ${t.color == n ? "w2ui-selected" : ""}"
                        style="background-color: #${n + a};" name="${n}" index="${r}:${o}"
                        data-mousedown="select|'${n}'|event" data-mouseup="hide|${e}">&nbsp;
                    </div>`;
      }
      i += "</div>", r < 2 && (i += '<div style="height: 8px"></div>');
    }
    return i = (i = (i += "</div>") + `
            <div class="w2ui-tab-content tab-2" style="display: none">
                <div class="color-info">
                    <div class="color-preview-bg"><div class="color-preview"></div><div class="color-original"></div></div>
                    <div class="color-part">
                        <span>H</span> <input class="w2ui-input" name="h" maxlength="3" max="360" tabindex="101">
                        <span>R</span> <input class="w2ui-input" name="r" maxlength="3" max="255" tabindex="104">
                    </div>
                    <div class="color-part">
                        <span>S</span> <input class="w2ui-input" name="s" maxlength="3" max="100" tabindex="102">
                        <span>G</span> <input class="w2ui-input" name="g" maxlength="3" max="255" tabindex="105">
                    </div>
                    <div class="color-part">
                        <span>V</span> <input class="w2ui-input" name="v" maxlength="3" max="100" tabindex="103">
                        <span>B</span> <input class="w2ui-input" name="b" maxlength="3" max="255" tabindex="106">
                    </div>
                    <div class="color-part opacity">
                        <span>${b.lang("Opacity")}</span>
                        <input class="w2ui-input" name="a" maxlength="5" max="1" tabindex="107">
                    </div>
                </div>
                <div class="palette" name="palette">
                    <div class="palette-bg"></div>
                    <div class="value1 move-x move-y"></div>
                </div>
                <div class="rainbow" name="rainbow">
                    <div class="value2 move-x"></div>
                </div>
                <div class="alpha" name="alpha">
                    <div class="alpha-bg"></div>
                    <div class="value2 move-x"></div>
                </div>
            </div>`) + `
            <div class="w2ui-color-tabs">
                <div class="w2ui-color-tab selected w2ui-eaction" data-click="tabClick|1|event|this"><span class="w2ui-icon w2ui-icon-colors"></span></div>
                <div class="w2ui-color-tab w2ui-eaction" data-click="tabClick|2|event|this"><span class="w2ui-icon w2ui-icon-settings"></span></div>
                <div style="padding: 5px; width: 100%; text-align: right;">
                    ${typeof t.html == "string" ? t.html : ""}
                </div>
            </div>`;
  }
  initControls(e) {
    let t, i = this;
    var n = e.options;
    let r = b.parseColor(n.color || e.tmp.initColor), o = (r == null && (r = { r: 140, g: 150, b: 160, a: 1 }), b.rgb2hsv(r));
    n.advanced === true && this.tabClick(2, e.name), c(o, true, true), p(e.box).find("input").off(".w2color").on("change.w2color", (g) => {
      g = p(g.target);
      let m = parseFloat(g.val());
      var _ = parseFloat(g.attr("max")), _ = (isNaN(m) && (m = 0, g.val(0)), 1 < _ && (m = parseInt(m)), 0 < _ && m > _ && (g.val(_), m = _), m < 0 && (g.val(0), m = 0), g.attr("name")), g = {};
      ["r", "g", "b", "a"].indexOf(_) !== -1 ? (r[_] = m, o = b.rgb2hsv(r)) : ["h", "s", "v"].indexOf(_) !== -1 && (g[_] = m), c(g, true);
    }), p(e.box).find(".color-original").off(".w2color").on("click.w2color", (f) => {
      f = b.parseColor(p(f.target).css("background-color")), f != null && (r = f, c(o = b.rgb2hsv(r), true));
    }), n = `${b.isIOS ? "touchstart" : "mousedown"}.w2color`;
    let a = `${b.isIOS ? "touchend" : "mouseup"}.w2color`, l = `${b.isIOS ? "touchmove" : "mousemove"}.w2color`;
    function c(f, m, _) {
      var _a2;
      f.h != null && (o.h = f.h), f.s != null && (o.s = f.s), f.v != null && (o.v = f.v), f.a != null && (r.a = f.a, o.a = f.a);
      let g = "rgba(" + (r = b.hsv2rgb(o)).r + "," + r.g + "," + r.b + "," + r.a + ")", v = [Number(r.r).toString(16).toUpperCase(), Number(r.g).toString(16).toUpperCase(), Number(r.b).toString(16).toUpperCase(), Math.round(255 * Number(r.a)).toString(16).toUpperCase()];
      var y, x;
      v.forEach((S, A) => {
        S.length === 1 && (v[A] = "0" + S);
      }), g = v[0] + v[1] + v[2] + v[3], r.a === 1 && (g = v[0] + v[1] + v[2]), p(e.box).find(".color-preview").css("background-color", "#" + g), p(e.box).find("input").each((S) => {
        S.name && (r[S.name] != null && (S.value = r[S.name]), o[S.name] != null && (S.value = o[S.name]), S.name === "a") && (S.value = r.a);
      }), _ ? (f = ((_a2 = e.tmp) == null ? void 0 : _a2.initColor) || g, p(e.box).find(".color-original").css("background-color", "#" + f), p(e.box).find(".w2ui-colors .w2ui-selected").removeClass("w2ui-selected"), p(e.box).find(`.w2ui-colors [name="${f}"]`).addClass("w2ui-selected"), g.length == 8 && i.tabClick(2, e.name)) : i.select(g, e.name), m && (_ = p(e.box).find(".palette .value1"), f = p(e.box).find(".rainbow .value2"), m = p(e.box).find(".alpha .value2"), y = parseInt(_[0].clientWidth) / 2, x = parseInt(f[0].clientWidth) / 2, _.css({ left: 150 * o.s / 100 - y + "px", top: 125 * (100 - o.v) / 100 - y + "px" }), f.css("left", o.h / 2.4 - x + "px"), m.css("left", 150 * r.a - x + "px"), h());
    }
    function h() {
      var f = b.hsv2rgb(o.h, 100, 100), f = `${f.r},${f.g},` + f.b;
      p(e.box).find(".palette").css("background-image", `linear-gradient(90deg, rgba(${f},0) 0%, rgba(${f},1) 100%)`);
    }
    function d(f) {
      p("body").off(".w2color");
    }
    function u(v) {
      var x = t.el, g = v.pageX - t.x, v = v.pageY - t.y;
      let m = t.left + g, _ = t.top + v;
      var g = parseInt(x.prop("clientWidth")) / 2, v = (m < -g && (m = -g), _ < -g && (_ = -g), m > t.width - g && (m = t.width - g), _ > t.height - g && (_ = t.height - g), x.hasClass("move-x") && x.css({ left: m + "px" }), x.hasClass("move-y") && x.css({ top: _ + "px" }), p(x.get(0).parentNode).attr("name")), y = parseInt(x.css("left")) + g, x = parseInt(x.css("top")) + g;
      v === "palette" && c({ s: Math.round(y / t.width * 100), v: Math.round(100 - x / t.height * 100) }), v === "rainbow" && (c({ h: Math.round(2.4 * y) }), h()), v === "alpha" && c({ a: parseFloat(Number(y / 150).toFixed(2)) });
    }
    p(e.box).find(".palette, .rainbow, .alpha").off(".w2color").on(n + ".w2color", function(f) {
      var m = p(this).find(".value1, .value2"), _ = parseInt(m.prop("clientWidth")) / 2;
      m.hasClass("move-x") && m.css({ left: f.offsetX - _ + "px" }), m.hasClass("move-y") && m.css({ top: f.offsetY - _ + "px" }), t = { el: m, x: f.pageX, y: f.pageY, width: m.prop("parentNode").clientWidth, height: m.prop("parentNode").clientHeight, left: parseInt(m.css("left")), top: parseInt(m.css("top")) }, u(f), p("body").off(".w2color").on(l, u).on(a, d);
    });
  }
}
class _M extends qe {
  constructor() {
    super(), this.defaults = b.extend({}, this.defaults, { type: "normal", items: [], index: null, render: null, spinner: false, msgNoItems: b.lang("No items found"), topHTML: "", menuStyle: "", filter: false, markSearch: false, match: "contains", search: false, altRows: false, arrowSize: 10, align: "left", position: "bottom|top", class: "w2ui-white", anchorClass: "w2ui-focus", autoShowOn: "focus", hideOn: ["doc-click", "focus-change", "select"], onSelect: null, onSubMenu: null, onRemove: null });
  }
  attach(e, t) {
    let i;
    arguments.length == 1 && e.anchor ? e = (i = e).anchor : arguments.length === 2 && t != null && typeof t == "object" && ((i = t).anchor = e), t = i.hideOn, i = b.extend({}, this.defaults, i || {}), t && (i.hideOn = t), i.style += "; padding: 0;", i.items == null && (i.items = []), i.html = this.getMenuHTML(i);
    let n = super.attach(i), r = n.overlay;
    return r.on("show:after.attach, update:after.attach", (o) => {
      var _a2;
      if ((_a2 = n.overlay) == null ? void 0 : _a2.box) {
        let l = "";
        r.selected = null, r.options.items = b.normMenu(r.options.items), ["INPUT", "TEXTAREA"].includes(r.anchor.tagName) && (l = r.anchor.value, r.selected = r.anchor.dataset.selectedIndex);
        var a = p(n.overlay.box).find(".w2ui-eaction");
        b.bindEvents(a, this), this.applyFilter(r.name, null, l).then((c) => {
          r.tmp.searchCount = c.count, r.tmp.search = c.search, this.refreshSearch(r.name), this.initControls(n.overlay), this.refreshIndex(r.name);
        });
      }
    }), r.on("hide:after.attach", (o) => {
      Ge.hide(r.name + "-tooltip");
    }), n.select = (o) => (r.on("select.attach", (a) => {
      o(a);
    }), n), n.remove = (o) => (r.on("remove.attach", (a) => {
      o(a);
    }), n), n.subMenu = (o) => (r.on("subMenu.attach", (a) => {
      o(a);
    }), n), n;
  }
  update(e, t) {
    var i, n = qe.active[e];
    n ? ((i = n.options).items != t && (i.items = t), t = this.getMenuHTML(i), i.html != t && (i.html = t, n.needsUpdate = true, this.show(e))) : console.log(`Tooltip "${e}" is not displayed. Cannot update it.`);
  }
  initControls(e) {
    p(e.box).find(".w2ui-menu:not(.w2ui-sub-menu)").off(".w2menu").on("mouseDown.w2menu", { delegate: ".w2ui-menu-item" }, (t) => {
      var i = t.delegate.dataset;
      this.menuDown(e, t, i.index, i.parents);
    }).on((b.isIOS ? "touchStart" : "click") + ".w2menu", { delegate: ".w2ui-menu-item" }, (t) => {
      var i = t.delegate.dataset;
      this.menuClick(e, t, parseInt(i.index), i.parents);
    }).find(".w2ui-menu-item").off(".w2menu").on("mouseEnter.w2menu", (t) => {
      var _a2;
      var i = t.target.dataset, i = (_a2 = e.options.items[i.index]) == null ? void 0 : _a2.tooltip;
      i && Ge.show({ name: e.name + "-tooltip", anchor: t.target, html: i, position: "right|left", hideOn: ["doc-click"] });
    }).on("mouseLeave.w2menu", (t) => {
      Ge.hide(e.name + "-tooltip");
    }), ["INPUT", "TEXTAREA"].includes(e.anchor.tagName) && p(e.anchor).off(".w2menu").on("input.w2menu", (t) => {
    }).on("keyup.w2menu", (t) => {
      t._searchType = "filter", this.keyUp(e, t);
    }), e.options.search && p(e.box).find("#menu-search").off(".w2menu").on("keyup.w2menu", (t) => {
      t._searchType = "search", this.keyUp(e, t);
    });
  }
  getCurrent(a, r) {
    var a = qe.active[a.replace(/[\s\.#]/g, "_")], i = a.options;
    let n = (r || (a.selected ?? "")).split("-");
    var r = n.length - 1, a = n[r], o = n.slice(0, n.length - 1).join("-"), a = b.isInt(a) ? parseInt(a) : 0;
    let l = i.items;
    return n.forEach((c, h) => {
      h < n.length - 1 && (l = l[c].items);
    }), { last: r, index: a, items: l, item: l[a], parents: o };
  }
  getMenuHTML(e, t, i, n) {
    if (e.spinner) return `
            <div class="w2ui-menu">
                <div class="w2ui-no-items">
                    <div class="w2ui-spinner"></div>
                    ${b.lang("Loading...")}
                </div>
            </div>`;
    n = n || [], t == null && (t = e.items), Array.isArray(t) || (t = []);
    let r = 0, o = null, a = "", l = (!i && e.search && (a += `
                <div class="w2ui-menu-search">
                    <span class="w2ui-icon w2ui-icon-search"></span>
                    <input id="menu-search" class="w2ui-input" type="text"/>
                </div>`, t.forEach((c) => c.hidden = false)), !i && e.topHTML && (a += `<div class="w2ui-menu-top">${e.topHTML}</div>`), `
            ${a}
            <div class="w2ui-menu ${i ? "w2ui-sub-menu" : ""}" ${i ? "" : `style="${e.menuStyle}"`}
                data-parent="${n}">
        `);
    return t.forEach((c, h) => {
      o = c.icon;
      var d = (0 < n.length ? n.join("-") + "-" : "") + h;
      if (o == null && (o = null), ["radio", "check"].indexOf(e.type) == -1 || Array.isArray(c.items) || c.group === false || (o = c.checked === true ? "w2ui-icon-check" : "w2ui-icon-empty"), c.hidden !== true) {
        let f = c.text, m = "", _ = "";
        if (typeof (f = typeof e.render == "function" ? e.render(c, e) : f) == "function" && (f = f(c, e)), o && (String(o).slice(0, 1) !== "<" && (o = `<span class="w2ui-icon ${o}"></span>`), m = `<div class="menu-icon">${o}</span></div>`), c.type !== "break" && f != null && f !== "" && String(f).substr(0, 2) != "--") {
          var u = ["w2ui-menu-item"];
          e.altRows == 1 && u.push(r % 2 == 0 ? "w2ui-even" : "w2ui-odd");
          let g = 1, v = (m === "" && g++, c.count == null && c.hotkey == null && c.remove !== true && c.items == null && g++, c.tooltip == null && c.hint != null && (c.tooltip = c.hint), "");
          if (c.remove === true) v = '<span class="remove">x</span>';
          else if (c.items != null) {
            let y = [];
            typeof c.items == "function" ? y = c.items(c) : Array.isArray(c.items) && (y = c.items), v = "<span></span>", _ = `
                            <div class="w2ui-sub-menu-box" style="${c.expanded ? "" : "display: none"}">
                                ${this.getMenuHTML(e, y, true, n.concat(h))}
                            </div>`;
          } else c.count != null && (v += "<span>" + c.count + "</span>"), c.hotkey != null && (v += '<span class="hotkey">' + c.hotkey + "</span>");
          c.disabled === true && u.push("w2ui-disabled"), c._noSearchInside === true && u.push("w2ui-no-search-inside"), _ !== "" && (u.push("has-sub-menu"), c.expanded ? u.push("expanded") : u.push("collapsed")), l += `
                        <div index="${d}" class="${u.join(" ")}" style="${c.style || ""}"
                            data-index="${h}" data-parents="${n.join("-")}">
                                <div style="width: ${(i ? 20 : 0) + parseInt(c.indent ?? 0)}px"></div>
                                ${m}
                                <div class="menu-text" colspan="${g}">${b.lang(f)}</div>
                                <div class="menu-extra">${v}</div>
                        </div>
                        ` + _, r++;
        } else u = (f ?? "").replace(/^-+/g, ""), l += `
                        <div index="${d}" class="w2ui-menu-divider ${u != "" ? "has-text" : ""}">
                            <div class="line"></div>
                            ${u ? `<div class="text">${u}</div>` : ""}
                        </div>`;
      }
      t[h] = c;
    }), r === 0 && e.msgNoItems && (l += `
                <div class="w2ui-no-items">
                    ${b.lang(e.msgNoItems)}
                </div>`), l += "</div>";
  }
  refreshIndex(n) {
    var t, i, n = qe.active[n.replace(/[\s\.#]/g, "_")];
    n && (n.displayed || this.show(n.name), t = p(n.box).find(".w2ui-overlay-body").get(0), i = p(n.box).find(".w2ui-menu-search, .w2ui-menu-top").get(0), p(n.box).find(".w2ui-menu-item.w2ui-selected").removeClass("w2ui-selected"), n = p(n.box).find(`.w2ui-menu-item[index="${n.selected}"]`).addClass("w2ui-selected").get(0)) && (n.offsetTop + n.clientHeight > t.clientHeight + t.scrollTop && n.scrollIntoView({ behavior: "smooth", block: "start", inline: "start" }), n.offsetTop < t.scrollTop + (i ? i.clientHeight : 0)) && n.scrollIntoView({ behavior: "smooth", block: "end", inline: "end" });
  }
  refreshSearch(e) {
    var _a2, _b2;
    let t = qe.active[e.replace(/[\s\.#]/g, "_")];
    t && (t.displayed || this.show(t.name), p(t.box).find(".w2ui-no-items").hide(), p(t.box).find(".w2ui-menu-item, .w2ui-menu-divider").each((i) => {
      var _a3, _b3;
      var n;
      ((_a3 = this.getCurrent(e, i.getAttribute("index")).item) == null ? void 0 : _a3.hidden) ? p(i).hide() : ((n = (_b3 = t.tmp) == null ? void 0 : _b3.search) && t.options.markSearch && b.marker(i, n, { onlyFirst: t.options.match == "begins" }), p(i).show());
    }), p(t.box).find(".w2ui-sub-menu").each((i) => {
      var n = p(i).find(".w2ui-menu-item").get().some((r) => r.style.display != "none");
      this.getCurrent(e, i.dataset.parent).item.expanded && (n ? p(i).parent().show() : p(i).parent().hide());
    }), t.tmp.searchCount != 0 && ((_b2 = (_a2 = t.options) == null ? void 0 : _a2.items) == null ? void 0 : _b2.length) != 0 || (p(t.box).find(".w2ui-no-items").length == 0 && p(t.box).find(".w2ui-menu:not(.w2ui-sub-menu)").append(`
                    <div class="w2ui-no-items">
                        ${b.lang(t.options.msgNoItems)}
                    </div>`), p(t.box).find(".w2ui-no-items").show()));
  }
  applyFilter(e, t, i, n) {
    var _a2;
    let r = 0;
    var o = qe.active[e.replace(/[\s\.#]/g, "_")];
    let a = o.options, l, c;
    var h = new Promise((f, m) => {
      l = f, c = m;
    });
    i == null && (i = ["INPUT", "TEXTAREA"].includes(o.anchor.tagName) ? o.anchor.value : "");
    let d = [];
    a.selected && (Array.isArray(a.selected) ? d = a.selected.map((f) => (f == null ? void 0 : f.id) ?? f) : ((_a2 = a.selected) == null ? void 0 : _a2.id) && (d = [a.selected.id])), o.tmp.activeChain = null;
    var u = o.tmp.remote ?? { hasMore: true, emtpySet: false, search: null, total: -1 };
    if (t == null && a.url && u.hasMore && u.search !== i) {
      let f = true, m = b.lang("Loading...");
      i.length < a.minLength && u.emptySet !== true && (m = b.lang("${count} letters or more...", { count: a.minLength }), f = false, i === "") && (m = b.lang(a.msgSearch)), p(o.box).find(".w2ui-no-items").html(m), u.search = i, a.items = [], o.tmp.remote = u, f && this.request(o, i, n).then((_) => {
        this.update(e, _), this.applyFilter(e, null, i).then((g) => {
          l(g);
        });
      }).catch((_) => {
        console.log("Server Request error", _);
      });
    } else {
      let f;
      t == null && (f = this.trigger("search", { search: i, overlay: o, prom: h, resolve: l, reject: c })).isCancelled === true || (t == null && (t = o.options.items), a.filter === false ? l({ count: -1, search: i }) : (t.forEach((m) => {
        let _ = "", g = "";
        ["is", "begins", "begins with"].indexOf(a.match) !== -1 && (_ = "^"), ["is", "ends", "ends with"].indexOf(a.match) !== -1 && (g = "$");
        try {
          new RegExp(_ + i + g, "i").test(m.text) || m.text === "..." ? m.hidden = false : m.hidden = true;
        } catch {
        }
        a.hideSelected && d.includes(m.id) && (m.hidden = true), Array.isArray(m.items) && 0 < m.items.length && (delete m._noSearchInside, this.applyFilter(e, m.items, i).then((v) => {
          v = v.count, 0 < v && (r += v, m.hidden && (m._noSearchInside = true), i && (m.expanded = true), m.hidden = false);
        })), m.hidden !== true && r++;
      }), l({ count: r, search: i }), f == null ? void 0 : f.finish()));
    }
    return h;
  }
  request(e, t, i) {
    let n = e.options, r = e.tmp.remote, o, a;
    return (n.items.length === 0 && r.total !== 0 || r.total == n.cacheMax && t.length > r.search.length || t.length >= r.search.length && t.substr(0, r.search.length) !== r.search || t.length < r.search.length) && (r.controller && r.controller.abort(), r.loading = true, clearTimeout(r.timeout), r.timeout = setTimeout(() => {
      var l = n.url;
      let c = { search: t, max: n.cacheMax };
      Object.assign(c, n.postData);
      var h, d = this.trigger("request", { search: t, overlay: e, url: l, postData: c, httpMethod: n.method ?? "GET", httpHeaders: {} });
      d.isCancelled !== true && (l = new URL(d.detail.url, location), h = b.prepareParams(l, { method: d.detail.httpMethod, headers: d.detail.httpHeaders, body: d.detail.postData }), r.controller = new AbortController(), h.signal = r.controller.signal, fetch(l, h).then((u) => u.json()).then((u) => {
        r.controller = null;
        var f = e.trigger("load", { search: c.search, overlay: e, data: u });
        f.isCancelled !== true && (typeof (u = f.detail.data) == "string" && (u = JSON.parse(u)), (u = Array.isArray(u) ? { records: u } : u).records == null && u.items != null && (u.records = u.items, delete u.items), u.error || u.records != null || (u.records = []), Array.isArray(u.records) ? (u.records.length >= n.cacheMax ? (u.records.splice(n.cacheMax, u.records.length), r.hasMore = true) : r.hasMore = false, n.recId == null && n.recid != null && (n.recId = n.recid), (n.recId || n.recText) && u.records.forEach((m) => {
          typeof n.recId == "string" && (m.id = m[n.recId]), typeof n.recId == "function" && (m.id = n.recId(m)), typeof n.recText == "string" && (m.text = m[n.recText]), typeof n.recText == "function" && (m.text = n.recText(m));
        }), r.loading = false, r.search = t, r.total = u.records.length, r.lastError = "", r.emptySet = t === "" && u.records.length === 0, f.finish(), o(b.normMenu(u.records))) : console.error("ERROR: server did not return proper data structure", `
`, " - it should return", { records: [{ id: 1, text: "item" }] }, `
`, " - or just an array ", [{ id: 1, text: "item" }], `
`, " - or if errorr ", { error: true, message: "error message" }));
      }).catch((u) => {
        var f = this.trigger("error", { overlay: e, search: t, error: u });
        f.isCancelled !== true && ((u == null ? void 0 : u.name) !== "AbortError" && console.error("ERROR: Server communication failed.", `
`, " - it should return", { records: [{ id: 1, text: "item" }] }, `
`, " - or just an array ", [{ id: 1, text: "item" }], `
`, " - or if errorr ", { error: true, message: "error message" }), r.loading = false, r.search = "", r.total = -1, r.emptySet = true, r.lastError = f.detail.error || "Server communication failed", n.items = [], f.finish(), a());
      }), d.finish());
    }, i ? n.debounce ?? 350 : 0)), new Promise((l, c) => {
      o = l, a = c;
    });
  }
  getActiveChain(e, t, i = [], n = [], r) {
    var o = qe.active[e.replace(/[\s\.#]/g, "_")];
    return o.tmp.activeChain != null ? o.tmp.activeChain : ((t = t ?? o.options.items).forEach((a, l) => {
      var _a2;
      a.hidden || a.disabled || ((_a2 = a == null ? void 0 : a.text) == null ? void 0 : _a2.startsWith("--")) || (n.push(i.concat([l]).join("-")), Array.isArray(a.items) && 0 < a.items.length && a.expanded && (i.push(l), this.getActiveChain(e, a.items, i, n, true), i.pop()));
    }), r == null && (o.tmp.activeChain = n), n);
  }
  menuDown(e, t, i, n) {
    e = e.options;
    let r = e.items;
    var o = p(t.delegate).find(".w2ui-icon");
    let a = p(t.target).closest(".w2ui-menu:not(.w2ui-sub-menu)"), l = (typeof n == "string" && n !== "" && n.split("-").forEach((c) => {
      r = r[c].items;
    }), r[i]);
    if (!l.disabled) {
      let c = (h, d) => {
        h.forEach((u, f) => {
          u.id != l.id && (u.group === l.group && u.checked && (a.find(`.w2ui-menu-item[index="${(d ? d + "-" : "") + f}"] .w2ui-icon`).removeClass("w2ui-icon-check").addClass("w2ui-icon-empty"), h[f].checked = false), Array.isArray(u.items)) && c(u.items, f);
        });
      };
      e.type !== "check" && e.type !== "radio" || l.group === false || p(t.target).hasClass("remove") || p(t.target).closest(".w2ui-menu-item").hasClass("has-sub-menu") || (l.checked = e.type == "radio" || !l.checked, l.checked ? (e.type === "radio" && p(t.target).closest(".w2ui-menu").find(".w2ui-icon").removeClass("w2ui-icon-check").addClass("w2ui-icon-empty"), e.type === "check" && l.group != null && c(e.items), o.removeClass("w2ui-icon-empty").addClass("w2ui-icon-check")) : e.type === "check" && o.removeClass("w2ui-icon-check").addClass("w2ui-icon-empty")), p(t.target).hasClass("remove") || (a.find(".w2ui-menu-item").removeClass("w2ui-selected"), p(t.delegate).addClass("w2ui-selected"));
    }
  }
  menuClick(e, t, i, n) {
    var r = e.options;
    let o = r.items;
    var a = p(t.delegate).closest(".w2ui-menu-item");
    let l = !r.hideOn.includes("select");
    (t.shiftKey || t.metaKey || t.ctrlKey) && (l = true), typeof n == "string" && n !== "" ? n.split("-").forEach((h) => {
      o = o[h].items;
    }) : n = null;
    var c = (o = typeof o == "function" ? o({ overlay: e, index: i, parentIndex: n, event: t }) : o)[i];
    if (!c.disabled || p(t.target).hasClass("remove")) {
      let h;
      if (p(t.target).hasClass("remove")) {
        if ((h = this.trigger("remove", { originalEvent: t, target: e.name, overlay: e, item: c, index: i, parentIndex: n, el: a[0] })).isCancelled === true) return;
        l = !r.hideOn.includes("item-remove"), a.remove();
      } else if (a.hasClass("has-sub-menu")) {
        if ((h = this.trigger("subMenu", { originalEvent: t, target: e.name, overlay: e, item: c, index: i, parentIndex: n, el: a[0] })).isCancelled === true) return;
        l = true, a.hasClass("expanded") ? (c.expanded = false, a.removeClass("expanded").addClass("collapsed"), p(a.get(0).nextElementSibling).hide()) : (c.expanded = true, a.addClass("expanded").removeClass("collapsed"), p(a.get(0).nextElementSibling).show()), e.selected = parseInt(a.attr("index"));
      } else {
        if (r = this.findChecked(r.items), e.selected = parseInt(a.attr("index")), (h = this.trigger("select", { originalEvent: t, target: e.name, overlay: e, item: c, index: i, parentIndex: n, selected: r, keepOpen: l, el: a[0] })).isCancelled === true) return;
        c.keepOpen != null && (l = c.keepOpen), ["INPUT", "TEXTAREA"].includes(e.anchor.tagName) && (e.anchor.dataset.selected = c.id, e.anchor.dataset.selectedIndex = e.selected);
      }
      l || this.hide(e.name), h.finish();
    }
  }
  findChecked(e) {
    let t = [];
    return e.forEach((i) => {
      i.checked && t.push(i), Array.isArray(i.items) && (t = t.concat(this.findChecked(i.items)));
    }), t;
  }
  keyUp(e, t) {
    var _a2, _b2;
    var i = e.options, n = t.target.value;
    let r = true, o = false;
    switch (t.keyCode) {
      case 46:
      case 8:
        n !== "" || e.displayed || (r = false);
        break;
      case 13:
        if (!e.displayed || !e.selected) return;
        var { index: l, parents: a } = this.getCurrent(e.name);
        t.delegate = p(e.box).find(".w2ui-selected").get(0), this.menuClick(e, t, parseInt(l), a), r = false;
        break;
      case 27:
        r = false, e.displayed ? this.hide(e.name) : (l = e.anchor, ["INPUT", "TEXTAREA"].includes(l.tagName) && (l.value = "", delete l.dataset.selected, delete l.dataset.selectedIndex));
        break;
      case 37: {
        if (!e.displayed) return;
        let { item: h, index: d, parents: u } = this.getCurrent(e.name);
        u && (h = i.items[u], d = parseInt(u), u = "", o = true), Array.isArray(h == null ? void 0 : h.items) && 0 < h.items.length && h.expanded && (t.delegate = p(e.box).find(`.w2ui-menu-item[index="${d}"]`).get(0), e.selected = d, this.menuClick(e, t, parseInt(d), u)), r = false;
        break;
      }
      case 39:
        if (!e.displayed) return;
        var { item: a, index: l, parents: c } = this.getCurrent(e.name);
        Array.isArray(a == null ? void 0 : a.items) && 0 < a.items.length && !a.expanded && (t.delegate = p(e.box).find(".w2ui-selected").get(0), this.menuClick(e, t, parseInt(l), c)), r = false;
        break;
      case 38:
        e.displayed && (a = this.getActiveChain(e.name), e.selected == null || ((_a2 = e.selected) == null ? void 0 : _a2.length) == 0 ? e.selected = a[a.length - 1] : ((l = a.indexOf(e.selected)) == -1 && (e.selected = a[a.length - 1]), 0 < l && (e.selected = a[l - 1])), r = false, o = true, t.preventDefault());
        break;
      case 40:
        e.displayed && (c = this.getActiveChain(e.name), e.selected == null || ((_b2 = e.selected) == null ? void 0 : _b2.length) == 0 ? e.selected = c[0] : ((a = c.indexOf(e.selected)) == -1 && (e.selected = c[0]), a < c.length - 1 && (e.selected = c[a + 1])), r = false, o = true, t.preventDefault());
    }
    r && e.displayed && (i.filter && t._searchType == "filter" || i.search && t._searchType == "search") && this.applyFilter(e.name, null, n, true).then((h) => {
      e.tmp.searchCount = h.count, e.tmp.search = h.search, h.count !== 0 && this.getActiveChain(e.name).includes(e.selected) || (e.selected = null), this.refreshSearch(e.name);
    }), o && this.refreshIndex(e.name);
  }
}
class bM extends qe {
  constructor() {
    super();
    var e = /* @__PURE__ */ new Date();
    this.daysCount = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], this.today = e.getFullYear() + "/" + (Number(e.getMonth()) + 1) + "/" + e.getDate(), this.defaults = b.extend({}, this.defaults, { position: "top|bottom", class: "w2ui-calendar", type: "date", format: "", value: "", start: null, end: null, blockDates: [], blockWeekdays: [], colored: {}, arrowSize: 12, autoResize: false, anchorClass: "w2ui-focus", autoShowOn: "focus", hideOn: ["doc-click", "focus-change"], onSelect: null });
  }
  attach(r, n) {
    let i;
    arguments.length == 1 && r.anchor ? r = (i = r).anchor : arguments.length === 2 && n != null && typeof n == "object" && ((i = n).anchor = r);
    var n = i.hideOn, r = (i = b.extend({}, this.defaults, i || {}), n && (i.hideOn = n), i.format || (r = b.settings.dateFormat, n = b.settings.timeFormat, i.type == "date" ? i.format = r : i.type == "time" ? i.format = n : i.format = r + "|" + n), i.type == "time" ? this.getHourHTML(i) : this.getMonthHTML(i));
    i.style += "; padding: 0;", i.html = r.html;
    let o = super.attach(i), a = o.overlay;
    return Object.assign(a.tmp, r), a.on("show.attach", (c) => {
      var c = c.detail.overlay, h = c.anchor, d = c.options;
      ["INPUT", "TEXTAREA"].includes(h.tagName) && !d.value && h.value && (c.tmp.initValue = h.value), delete c.newValue, delete c.newDate;
    }), a.on("show:after.attach", (l) => {
      var _a2;
      ((_a2 = o.overlay) == null ? void 0 : _a2.box) && this.initControls(o.overlay);
    }), a.on("update:after.attach", (l) => {
      var _a2;
      ((_a2 = o.overlay) == null ? void 0 : _a2.box) && this.initControls(o.overlay);
    }), a.on("hide.attach", (c) => {
      var c = c.detail.overlay, h = c.anchor;
      c.newValue != null && (c.newDate && (c.newValue = c.newDate + " " + c.newValue), ["INPUT", "TEXTAREA"].includes(h.tagName) && h.value != c.newValue && (h.value = c.newValue), (h = this.trigger("select", { date: c.newValue, target: c.name, overlay: c })).isCancelled !== true) && h.finish();
    }), o.select = (l) => (a.on("select.attach", (c) => {
      l(c);
    }), o), o;
  }
  initControls(e) {
    let t = e.options, i = (r) => {
      let { month: o, year: a } = e.tmp;
      12 < (o += r) && (o = 1, a++), o < 1 && (o = 12, a--), r = this.getMonthHTML(t, o, a), Object.assign(e.tmp, r), p(e.box).find(".w2ui-overlay-body").html(r.html), this.initControls(e);
    }, n = (r, o) => {
      p(r.target).parent().find(".w2ui-jump-month, .w2ui-jump-year").removeClass("w2ui-selected"), p(r.target).addClass("w2ui-selected"), r = /* @__PURE__ */ new Date();
      let { jumpMonth: a, jumpYear: l } = e.tmp;
      (a = o && (l == null && (l = r.getFullYear()), a == null) ? r.getMonth() + 1 : a) && l && (o = this.getMonthHTML(t, a, l), Object.assign(e.tmp, o), p(e.box).find(".w2ui-overlay-body").html(o.html), e.tmp.jump = false, this.initControls(e));
    };
    p(e.box).find(".w2ui-cal-title").off(".calendar").on("click.calendar", (r) => {
      var o, a;
      Object.assign(e.tmp, { jumpYear: null, jumpMonth: null }), e.tmp.jump ? ({ month: o, year: a } = e.tmp, o = this.getMonthHTML(t, o, a), p(e.box).find(".w2ui-overlay-body").html(o.html), e.tmp.jump = false) : (p(e.box).find(".w2ui-overlay-body .w2ui-cal-days").replace(this.getYearHTML()), (a = p(e.box).find(`[name="${e.tmp.year}"]`).get(0)) && a.scrollIntoView(true), e.tmp.jump = true), this.initControls(e), r.stopPropagation();
    }).find(".w2ui-cal-previous").off(".calendar").on("click.calendar", (r) => {
      i(-1), r.stopPropagation();
    }).parent().find(".w2ui-cal-next").off(".calendar").on("click.calendar", (r) => {
      i(1), r.stopPropagation();
    }), p(e.box).find(".w2ui-cal-now").off(".calendar").on("click.calendar", (r) => {
      t.type == "datetime" ? e.newDate ? e.newValue = b.formatTime(/* @__PURE__ */ new Date(), t.format.split("|")[1]) : e.newValue = b.formatDateTime(/* @__PURE__ */ new Date(), t.format) : t.type == "date" ? e.newValue = b.formatDate(/* @__PURE__ */ new Date(), t.format) : t.type == "time" && (e.newValue = b.formatTime(/* @__PURE__ */ new Date(), t.format)), this.hide(e.name);
    }), p(e.box).off(".calendar").on("click.calendar", { delegate: ".w2ui-day.w2ui-date" }, (r) => {
      t.type == "datetime" ? (e.newDate = p(r.target).attr("date"), p(e.box).find(".w2ui-overlay-body").html(this.getHourHTML(e.options).html), this.initControls(e)) : (e.newValue = p(r.target).attr("date"), this.hide(e.name));
    }).on("click.calendar", { delegate: ".w2ui-jump-month" }, (r) => {
      e.tmp.jumpMonth = parseInt(p(r.target).attr("name")), n(r);
    }).on("dblclick.calendar", { delegate: ".w2ui-jump-month" }, (r) => {
      e.tmp.jumpMonth = parseInt(p(r.target).attr("name")), n(r, true);
    }).on("click.calendar", { delegate: ".w2ui-jump-year" }, (r) => {
      e.tmp.jumpYear = parseInt(p(r.target).attr("name")), n(r);
    }).on("dblclick.calendar", { delegate: ".w2ui-jump-year" }, (r) => {
      e.tmp.jumpYear = parseInt(p(r.target).attr("name")), n(r, true);
    }).on("click.calendar", { delegate: ".w2ui-time.hour" }, (o) => {
      var o = p(o.target).attr("hour");
      let a = this.str2min(t.value) % 60;
      e.tmp.initValue && !t.value && (a = this.str2min(e.tmp.initValue) % 60), t.noMinutes ? (e.newValue = this.min2str(60 * o, t.format), this.hide(e.name)) : (e.newValue = o + ":" + a, o = this.getMinHTML(o, t).html, p(e.box).find(".w2ui-overlay-body").html(o), this.initControls(e));
    }).on("click.calendar", { delegate: ".w2ui-time.min" }, (r) => {
      r = 60 * Math.floor(this.str2min(e.newValue) / 60) + parseInt(p(r.target).attr("min")), e.newValue = this.min2str(r, t.format), this.hide(e.name);
    });
  }
  getMonthHTML(e, t, i) {
    var o = b.settings.fulldays.slice(), n = b.settings.shortdays.slice();
    b.settings.weekStarts !== "M" && (o.unshift(o.pop()), n.unshift(n.pop()));
    let r = /* @__PURE__ */ new Date();
    var o = e.type === "datetime" ? b.isDateTime(e.value, e.format, true) : b.isDate(e.value, e.format, true), a = b.formatDate(o);
    t != null && i != null || (i = (o || r).getFullYear(), t = o ? o.getMonth() + 1 : r.getMonth() + 1), 12 < t && (t -= 12, i++), (t < 1 || t === 0) && (t += 12, i--), i / 4 == Math.floor(i / 4) ? this.daysCount[1] = 29 : this.daysCount[1] = 28, e.current = t + "/" + i;
    let l = (r = new Date(i, t - 1, 1)).getDay(), c = "";
    var h = b.settings.weekStarts;
    for (let y = 0; y < n.length; y++) {
      var d = h == "M" && y == 5 || h != "M" && y == 6, u = h == "M" && y == 6 || h != "M" && y == 0;
      c += `<div class="w2ui-day w2ui-weekday ${d ? "w2ui-sunday" : ""} ${u ? "w2ui-saturday" : ""}">${n[y]}</div>`;
    }
    let f = `
            <div class="w2ui-cal-title">
                <div class="w2ui-cal-previous">
                    <div></div>
                </div>
                <div class="w2ui-cal-next">
                    <div></div>
                </div>
                ${b.settings.fullmonths[t - 1]}, ${i}
                <span class="arrow-down"></span>
            </div>
            <div class="w2ui-cal-days">
                ${c}
        `, m = /* @__PURE__ */ new Date(i + `/${t}/1`);
    o = (m = new Date(m.getTime() + 432e5)).getDay(), b.settings.weekStarts == "M" && l--, 0 < o && (m = new Date(m.getTime() - 864e5 * l));
    for (let y = 0; y < 42; y++) {
      var _ = [], g = `${m.getFullYear()}/${m.getMonth() + 1}/` + m.getDate(), v = (m.getDay() === 6 && _.push("w2ui-saturday"), m.getDay() === 0 && _.push("w2ui-sunday"), m.getMonth() + 1 !== t && _.push("outside"), g == this.today && _.push("w2ui-today"), m.getDate());
      let x = "", S = "", A, R;
      R = e.type === "datetime" ? (A = b.formatDateTime(g, e.format), b.formatDate(g, b.settings.dateFormat)) : A = b.formatDate(g, e.format), e.colored && e.colored[R] !== void 0 && (g = e.colored[R].split("|"), S = "background-color: " + g[0] + ";", x = "color: " + g[1] + ";"), f += `<div class="w2ui-day ${this.inRange(A, e, true) ? "w2ui-date " + (R == a ? "w2ui-selected" : "") : "w2ui-blocked"} ${_.join(" ")}"
                       style="${x + S}" date="${R}" data-date="${m.getTime()}">
                            ${v}
                    </div>`, m = new Date(m.getTime() + 864e5);
    }
    return f += "</div>", e.btnNow && (o = b.lang("Today" + (e.type == "datetime" ? " & Now" : "")), f += `<div class="w2ui-cal-now">${o}</div>`), { html: f, month: t, year: i };
  }
  getYearHTML() {
    let e = "", t = "";
    for (let i = 0; i < b.settings.fullmonths.length; i++) e += `<div class="w2ui-jump-month" name="${i + 1}">${b.settings.shortmonths[i]}</div>`;
    for (let i = b.settings.dateStartYear; i <= b.settings.dateEndYear; i++) t += `<div class="w2ui-jump-year" name="${i}">${i}</div>`;
    return `<div class="w2ui-cal-jump">
            <div id="w2ui-jump-month">${e}</div>
            <div id="w2ui-jump-year">${t}</div>
        </div>`;
  }
  getHourHTML(e) {
    (e = e ?? {}).format || (e.format = b.settings.timeFormat);
    var t = -1 < e.format.indexOf("h24"), i = e.value || (e.anchor ? e.anchor.value : ""), n = [];
    for (let a = 0; a < 24; a++) {
      let l = (12 <= a && !t ? a - 12 : a) + ":00" + (t ? "" : a < 12 ? " am" : " pm"), c = (a != 12 || t || (l = "12:00 pm"), n[Math.floor(a / 8)] || (n[Math.floor(a / 8)] = ""), this.min2str(this.str2min(l))), h = this.min2str(this.str2min(l) + 59);
      e.type === "datetime" && (o = b.isDateTime(i, e.format, true), r = e.format.split("|")[0].trim(), c = b.formatDate(o, r) + " " + c, h = b.formatDate(o, r) + " " + h);
      var r, o = this.inRange(c, e) || this.inRange(h, e);
      n[Math.floor(a / 8)] += `<span hour="${a}"
                class="hour ${o ? "w2ui-time " : "w2ui-blocked"}">${l}</span>`;
    }
    return { html: `<div class="w2ui-calendar">
            <div class="w2ui-time-title">${b.lang("Select Hour")}</div>
            <div class="w2ui-cal-time">
                <div class="w2ui-cal-column">${n[0]}</div>
                <div class="w2ui-cal-column">${n[1]}</div>
                <div class="w2ui-cal-column">${n[2]}</div>
            </div>
            ${e.btnNow ? `<div class="w2ui-cal-now">${b.lang("Now")}</div>` : ""}
        </div>` };
  }
  getMinHTML(e, t) {
    e == null && (e = 0), (t = t ?? {}).format || (t.format = b.settings.timeFormat);
    var i = -1 < t.format.indexOf("h24"), n = t.value || (t.anchor ? t.anchor.value : ""), r = [];
    for (let h = 0; h < 60; h += 5) {
      var o = (12 < e && !i ? e - 12 : e) + ":" + (h < 10 ? 0 : "") + h + " " + (i ? "" : e < 12 ? "am" : "pm");
      let d = o;
      var a, l, c = h < 20 ? 0 : h < 40 ? 1 : 2;
      r[c] || (r[c] = ""), t.type === "datetime" && (a = b.isDateTime(n, t.format, true), l = t.format.split("|")[0].trim(), d = b.formatDate(a, l) + " " + d), r[c] += `<span min="${h}" class="min ${this.inRange(d, t) ? "w2ui-time " : "w2ui-blocked"}">${o}</span>`;
    }
    return { html: `<div class="w2ui-calendar">
            <div class="w2ui-time-title">${b.lang("Select Minute")}</div>
            <div class="w2ui-cal-time">
                <div class="w2ui-cal-column">${r[0]}</div>
                <div class="w2ui-cal-column">${r[1]}</div>
                <div class="w2ui-cal-column">${r[2]}</div>
            </div>
            ${t.btnNow ? `<div class="w2ui-cal-now">${b.lang("Now")}</div>` : ""}
        </div>` };
  }
  inRange(e, t, i) {
    let n = false;
    if (t.type === "date") {
      var r = b.isDate(e, t.format, true);
      if (r) {
        if (t.start || t.end) {
          var o = typeof t.start == "string" ? t.start : p(t.start).val(), a = typeof t.end == "string" ? t.end : p(t.end).val();
          let l = b.isDate(o, t.format, true), c = b.isDate(a, t.format, true);
          o = new Date(r), l = l || o, c = c || o, o >= l && o <= c && (n = true);
        } else n = true;
        Array.isArray(t.blockDates) && t.blockDates.includes(e) && (n = false), Array.isArray(t.blockWeekdays) && t.blockWeekdays.includes(r.getDay()) && (n = false);
      }
    } else if (t.type === "time") if (t.start || t.end) {
      a = this.str2min(e);
      let l = this.str2min(t.start), c = this.str2min(t.end);
      l = l || a, c = c || a, a >= l && a <= c && (n = true);
    } else n = true;
    else t.type === "datetime" && (o = b.isDateTime(e, t.format, true)) && (r = t.format.split("|").map((l) => l.trim()), i ? (a = b.formatDate(o, r[0]), e = b.extend({}, t, { type: "date", format: r[0] }), this.inRange(a, e) && (n = true)) : (i = b.formatTime(o, r[1]), a = { type: "time", format: r[1], start: t.startTime, end: t.endTime }, this.inRange(i, a) && (n = true)));
    return n;
  }
  str2min(e) {
    var t;
    return typeof e != "string" || (t = e.split(":")).length !== 2 ? null : (t[0] = parseInt(t[0]), t[1] = parseInt(t[1]), e.indexOf("pm") !== -1 && t[0] !== 12 && (t[0] += 12), e.includes("am") && t[0] == 12 && (t[0] = 0), 60 * t[0] + t[1]);
  }
  min2str(n, t) {
    1440 <= n && (n %= 1440), n < 0 && (n = 1440 + n);
    var i = Math.floor(n / 60), n = (n % 60 < 10 ? "0" : "") + n % 60;
    return t = t || b.settings.timeFormat, t.indexOf("h24") !== -1 ? i + ":" + n : (i <= 12 ? i : i - 12) + ":" + n + " " + (12 <= i ? "pm" : "am");
  }
}
let Ge = new qe(), Ot = new _M(), rf = new vM(), er = new bM();
class xM extends Xn {
  constructor(e) {
    super(e.name), this.box = null, this.name = null, this.routeData = {}, this.items = [], this.right = "", this.tooltip = "top|left", this.onClick = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseEnter = null, this.onMouseLeave = null, this.onRender = null, this.onRefresh = null, this.onResize = null, this.onDestroy = null, this.item_template = { id: null, type: "button", text: null, html: "", tooltip: null, count: null, hidden: false, disabled: false, checked: false, icon: null, route: null, arrow: null, style: null, group: null, items: null, selected: null, color: null, overlay: { anchorClass: "" }, onClick: null, onRefresh: null }, this.last = { badge: {} };
    var t = e.items;
    delete e.items, Object.assign(this, e), Array.isArray(t) && this.add(t, true), e.items = t, typeof this.box == "string" && (this.box = p(this.box).get(0)), this.box && this.render(this.box);
  }
  add(e, t) {
    this.insert(null, e, t);
  }
  insert(e, t, i) {
    (t = Array.isArray(t) ? t : [t]).forEach((n, r, o) => {
      typeof n == "string" && (n = o[r] = { id: n, text: n });
      var a, l = ["button", "check", "radio", "drop", "menu", "menu-radio", "menu-check", "color", "text-color", "html", "break", "spacer", "new-line"];
      if (l.includes(String(n.type))) if (n.id != null || ["break", "spacer", "new-line"].includes(n.type)) {
        if (n.type == null) console.log('ERROR: The parameter "type" is required but not supplied.', n);
        else if (b.checkUniqueId(n.id, this.items, "toolbar", this.name)) {
          let c = b.extend({}, this.item_template, n);
          c.type == "menu-check" ? (Array.isArray(c.selected) || (c.selected = []), Array.isArray(c.items) && c.items.forEach((h) => {
            (h = typeof h == "string" ? o[r] = { id: h, text: h } : h).checked && !c.selected.includes(h.id) && c.selected.push(h.id), !h.checked && c.selected.includes(h.id) && (h.checked = true), h.checked == null && (h.checked = false);
          })) : c.type == "menu-radio" && Array.isArray(c.items) && c.items.forEach((h, d, u) => {
            (h = typeof h == "string" ? u[d] = { id: h, text: h } : h).checked && c.selected == null ? c.selected = h.id : h.checked = false, h.checked || c.selected != h.id || (h.checked = true), h.checked == null && (h.checked = false);
          }), e == null ? this.items.push(c) : (a = this.get(e, true), this.items = this.items.slice(0, a).concat([c], this.items.slice(a))), c.line = c.line ?? 1, i !== true && this.refresh(c.id);
        }
      } else console.log('ERROR: The parameter "id" is required but not supplied.', n);
      else console.log('ERROR: The parameter "type" should be one of the following:', l, `, but ${n.type} is supplied.`, n);
    }), i !== true && this.resize();
  }
  remove() {
    let e = 0;
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && String(t).indexOf(":") == -1 && (e++, p(this.box).find("#tb_" + this.name + "_item_" + b.escapeId(i.id)).remove(), (t = this.get(i.id, true)) != null) && this.items.splice(t, 1);
    }), this.resize(), e;
  }
  set(e, t) {
    var i = this.get(e);
    return i != null && (Object.assign(i, t), this.refresh(String(e).split(":")[0]), true);
  }
  get(e, t) {
    if (arguments.length === 0) {
      var i = [];
      for (let a = 0; a < this.items.length; a++) this.items[a].id != null && i.push(this.items[a].id);
      return i;
    }
    var n = String(e).split(":");
    for (let a = 0; a < this.items.length; a++) {
      var r = this.items[a];
      if (["menu", "menu-radio", "menu-check"].includes(r.type) && n.length == 2 && r.id == n[0]) {
        let l = r.items;
        typeof l == "function" && (l = l(this));
        for (let c = 0; c < l.length; c++) {
          var o = l[c];
          if (o.id == n[1] || o.id == null && o.text == n[1]) return t == 1 ? c : o;
          if (Array.isArray(o.items)) {
            for (let h = 0; h < o.items.length; h++) if (o.items[h].id == n[1] || o.items[h].id == null && o.items[h].text == n[1]) return t == 1 ? c : o.items[h];
          }
        }
      } else if (r.id == n[0]) return t == 1 ? a : r;
    }
    return null;
  }
  setCount(e, t, i, n) {
    var r = p(this.box).find(`#tb_${this.name}_item_${b.escapeId(e)} .w2ui-tb-count > span`);
    0 < r.length ? (r.removeClass().addClass(i ?? "").text(t).get(0).style.cssText = n ?? "", this.last.badge[e] = { className: i ?? "", style: n ?? "" }, this.get(e).count = t) : (this.set(e, { count: t }), this.setCount(...arguments));
  }
  show() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && (i.hidden = false, e.push(String(t).split(":")[0]));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t), this.resize();
      });
    }, 15), e;
  }
  hide() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && (i.hidden = true, e.push(String(t).split(":")[0]));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t), this.tooltipHide(t), this.resize();
      });
    }, 15), e;
  }
  enable() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && (i.disabled = false, e.push(String(t).split(":")[0]));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t);
      });
    }, 15), e;
  }
  disable() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && (i.disabled = true, e.push(String(t).split(":")[0]));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t), this.tooltipHide(t);
      });
    }, 15), e;
  }
  check() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && String(t).indexOf(":") == -1 && (i.checked = true, e.push(String(t).split(":")[0]));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t);
      });
    }, 15), e;
  }
  uncheck() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      var i = this.get(t);
      i && String(t).indexOf(":") == -1 && (["menu", "menu-radio", "menu-check", "drop", "color", "text-color"].includes(i.type) && i.checked && Ge.hide(this.name + "-drop"), i.checked = false, e.push(String(t).split(":")[0]));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t);
      });
    }, 15), e;
  }
  click(e, t) {
    var i = String(e).split(":");
    let n = this.get(i[0]), r = n && n.items ? b.normMenu.call(this, n.items, n) : [];
    if (1 < i.length) (i = this.get(e)) && !i.disabled && this.menuClick({ name: this.name, item: n, subItem: i, originalEvent: t });
    else if (n && !n.disabled && (i = this.trigger("click", { target: e ?? this.name, item: n, object: n, originalEvent: t }), i.isCancelled !== true)) {
      r = n && n.items ? b.normMenu.call(this, n.items, n) : [];
      let l = "#tb_" + this.name + "_item_" + b.escapeId(n.id);
      if (p(this.box).find(l).removeClass("down"), n.type == "radio") {
        for (let c = 0; c < this.items.length; c++) {
          var o = this.items[c];
          o != null && o.id != n.id && o.type === "radio" && o.group == n.group && o.checked && (o.checked = false, this.refresh(o.id));
        }
        n.checked = true, p(this.box).find(l).addClass("checked");
      }
      if (["menu", "menu-radio", "menu-check", "drop", "color", "text-color"].includes(n.type)) {
        if (this.tooltipHide(e), n.checked) return void Ge.hide(this.name + "-drop");
        setTimeout(() => {
          var c = (d, u) => {
            let f = this;
            return function() {
              f.set(d, { checked: false });
            };
          }, h = p(this.box).find("#tb_" + this.name + "_item_" + b.escapeId(n.id));
          if (b.isPlainObject(n.overlay) || (n.overlay = {}), n.type == "drop" && Ge.show(b.extend({ html: n.html, class: "w2ui-white", hideOn: ["doc-click"] }, n.overlay, { anchor: h[0], name: this.name + "-drop", data: { item: n, btn: l } })).hide(c(n.id)), ["menu", "menu-radio", "menu-check"].includes(n.type)) {
            let d = "normal";
            n.type == "menu-radio" && (d = "radio", r.forEach((u) => {
              n.selected == u.id ? u.checked = true : u.checked = false;
            })), n.type == "menu-check" && (d = "check", r.forEach((u) => {
              Array.isArray(n.selected) && n.selected.includes(u.id) ? u.checked = true : u.checked = false;
            })), Ot.show(b.extend({ items: r }, n.overlay, { type: d, name: this.name + "-drop", anchor: h[0], data: { item: n, btn: l } })).hide(c(n.id)).remove((u) => {
              this.menuClick({ name: this.name, remove: true, item: n, subItem: u.detail.item, originalEvent: u });
            }).select((u) => {
              this.menuClick({ name: this.name, item: n, subItem: u.detail.item, originalEvent: u });
            });
          }
          ["color", "text-color"].includes(n.type) && rf.show(b.extend({ color: n.color }, n.overlay, { anchor: h[0], name: this.name + "-drop", data: { item: n, btn: l } })).hide(c(n.id)).select((d) => {
            d.detail.color != null && this.colorClick({ name: this.name, item: n, color: d.detail.color });
          });
        }, 0);
      }
      if (["check", "menu", "menu-radio", "menu-check", "drop", "color", "text-color"].includes(n.type) && (n.checked = !n.checked, n.checked ? p(this.box).find(l).addClass("checked") : p(this.box).find(l).removeClass("checked")), n.route) {
        let c = ("/" + n.route).replace(/\/{2,}/g, "/");
        var a = b.parseRoute(c);
        if (0 < a.keys.length) for (let h = 0; h < a.keys.length; h++) c = c.replace(new RegExp(":" + a.keys[h].name, "g"), this.routeData[a.keys[h].name]);
        setTimeout(() => {
          window.location.hash = c;
        }, 1);
      }
      this.tooltipShow(e), i.finish();
    }
  }
  scroll(e, t, i) {
    return new Promise((n, r) => {
      var o = p(this.box).find(`.w2ui-tb-line:nth-child(${t}) .w2ui-scroll-wrapper`), a = o.get(0).scrollLeft, l = o.find(".w2ui-tb-right").get(0), c = o.parent().get(0).getBoundingClientRect().width, h = a + parseInt(l.offsetLeft) + parseInt(l.clientWidth);
      switch (e) {
        case "left":
          (scroll = a - c + 50) <= 0 && (scroll = 0), o.get(0).scrollTo({ top: 0, left: scroll, behavior: i ? "atuo" : "smooth" });
          break;
        case "right":
          (scroll = a + c - 50) >= h - c && (scroll = h - c), o.get(0).scrollTo({ top: 0, left: scroll, behavior: i ? "atuo" : "smooth" });
      }
      setTimeout(() => {
        this.resize(), n();
      }, i ? 0 : 500);
    });
  }
  render(e) {
    var t = Date.now(), i = (typeof e == "string" && (e = p(e).get(0)), this.trigger("render", { target: this.name, box: e ?? this.box }));
    if (i.isCancelled !== true && (e != null && (0 < p(this.box).find(".w2ui-scroll-wrapper .w2ui-tb-right").length && p(this.box).removeAttr("name").removeClass("w2ui-reset w2ui-toolbar").html(""), this.box = e), this.box)) {
      Array.isArray(this.right) || (this.right = [this.right]);
      let r = "", o = 0;
      for (let a = 0; a < this.items.length; a++) {
        var n = this.items[a];
        n != null && (n.id == null && (n.id = "item_" + a), n.caption != null && console.log("NOTICE: toolbar item.caption property is deprecated, please use item.text. Item -> ", n), n.hint != null && console.log("NOTICE: toolbar item.hint property is deprecated, please use item.tooltip. Item -> ", n), a !== 0 && n.type != "new-line" || (o++, r += `
                    <div class="w2ui-tb-line">
                        <div class="w2ui-scroll-wrapper w2ui-eaction" data-mousedown="resize">
                            <div class="w2ui-tb-right">${this.right[o - 1] ?? ""}</div>
                        </div>
                        <div class="w2ui-scroll-left w2ui-eaction" data-click='["scroll", "left", "${o}"]'></div>
                        <div class="w2ui-scroll-right w2ui-eaction" data-click='["scroll", "right", "${o}"]'></div>
                    </div>
                `), n.line = o);
      }
      return p(this.box).attr("name", this.name).addClass("w2ui-reset w2ui-toolbar").html(r), 0 < p(this.box).length && (p(this.box)[0].style.cssText += this.style), b.bindEvents(p(this.box).find(".w2ui-tb-line .w2ui-eaction"), this), this.last.observeResize = new ResizeObserver(() => {
        this.resize();
      }), this.last.observeResize.observe(this.box), this.refresh(), this.resize(), i.finish(), Date.now() - t;
    }
  }
  refresh(e) {
    var t = Date.now(), i = this.trigger("refresh", { target: e ?? this.name, item: this.get(e) });
    if (i.isCancelled !== true) {
      let l;
      if (e == null) for (let c = 0; c < this.items.length; c++) {
        var n = this.items[c];
        n.id == null && (n.id = "item_" + c), this.refresh(n.id);
      }
      else {
        var r = this.get(e);
        if (r == null) return false;
        if (typeof r.onRefresh != "function" || (l = this.trigger("refresh", { target: e, item: r, object: r })).isCancelled !== true) {
          var o = `#tb_${this.name}_item_` + b.escapeId(r.id);
          let c = p(this.box).find(o);
          var a = this.getItemHTML(r);
          if (this.tooltipHide(e), r.type == "spacer" && p(this.box).find(".w2ui-tb-line:nth-child(" + r.line).find(".w2ui-tb-right").css("width", "auto"), c.length === 0) {
            e = parseInt(this.get(e, true)) + 1;
            let h = p(this.box).find(`#tb_${this.name}_item_` + b.escapeId(this.items[e] ? this.items[e].id : ""));
            h.length == 0 ? h = p(this.box).find(".w2ui-tb-line:nth-child(" + r.line).find(".w2ui-tb-right").before(a) : h.after(a), b.bindEvents(p(this.box).find(o), this);
          } else {
            p(this.box).find(o).replace(p.html(a));
            let h = p(this.box).find(o).get(0), d = (b.bindEvents(h, this), Ge.get(true));
            Object.keys(d).forEach((u) => {
              d[u].anchor == c.get(0) && (d[u].anchor = h);
            });
          }
          if (["menu", "menu-radio", "menu-check"].includes(r.type) && r.checked) {
            let h = Array.isArray(r.selected) ? r.selected : [r.selected];
            r.items.forEach((d) => {
              h.includes(d.id) ? d.checked = true : d.checked = false;
            }), Ot.update(this.name + "-drop", r.items);
          }
          return typeof r.onRefresh == "function" && l.finish(), i.finish(), Date.now() - t;
        }
      }
    }
  }
  resize() {
    var e = Date.now(), t = this.trigger("resize", { target: this.name });
    if (t.isCancelled !== true) return p(this.box).find(".w2ui-tb-line").each((n) => {
      var n = p(n), r = (n.find(".w2ui-scroll-left, .w2ui-scroll-right").hide(), n.find(".w2ui-scroll-wrapper").get(0)), a = n.find(".w2ui-tb-right"), o = n.get(0).getBoundingClientRect().width, a = 0 < a.length ? a[0].offsetLeft + a[0].clientWidth : 0;
      o < a && (0 < r.scrollLeft && n.find(".w2ui-scroll-left").show(), o < a - r.scrollLeft) && n.find(".w2ui-scroll-right").show();
    }), t.finish(), Date.now() - e;
  }
  destroy() {
    var _a2;
    var e = this.trigger("destroy", { target: this.name });
    e.isCancelled !== true && (0 < p(this.box).find(".w2ui-scroll-wrapper  .w2ui-tb-right").length && p(this.box).removeAttr("name").removeClass("w2ui-reset w2ui-toolbar").html(""), p(this.box).html(""), (_a2 = this.last.observeResize) == null ? void 0 : _a2.disconnect(), delete on[this.name], e.finish());
  }
  getItemHTML(e) {
    let t = "", i = (e.caption != null && e.text == null && (e.text = e.caption), e.text == null && (e.text = ""), e.tooltip == null && e.hint != null && (e.tooltip = e.hint), e.tooltip == null && (e.tooltip = ""), typeof e.get == "function" || !Array.isArray(e.items) && typeof e.items != "function" || (e.get = function(a) {
      let l = e.items;
      return (l = typeof l == "function" ? e.items(e) : l).find((c) => c.id == a);
    }), ""), n = typeof e.text == "function" ? e.text.call(this, e) : e.text;
    e.icon && (i = e.icon, typeof e.icon == "function" && (i = e.icon.call(this, e)), i = `<div class="w2ui-tb-icon">${i = String(i).slice(0, 1) !== "<" ? `<span class="${i}"></span>` : i}</div>`);
    var r = ["w2ui-tb-button"];
    switch (e.checked && r.push("checked"), e.disabled && r.push("disabled"), e.hidden && r.push("hidden"), i || r.push("no-icon"), e.type) {
      case "color":
      case "text-color":
        typeof e.color == "string" && (e.color.slice(0, 1) == "#" && (e.color = e.color.slice(1)), [3, 6, 8].includes(e.color.length)) && (e.color = "#" + e.color), e.type == "color" && (n = `<span class="w2ui-tb-color-box" style="background-color: ${e.color != null ? e.color : "#fff"}"></span>
                           ` + (e.text ? `<div style="margin-left: 17px;">${b.lang(e.text)}</div>` : "")), e.type == "text-color" && (n = '<span style="color: ' + (e.color != null ? e.color : "#444") + ';">' + (e.text ? b.lang(e.text) : "<b>Aa</b>") + "</span>");
      case "menu":
      case "menu-check":
      case "menu-radio":
      case "button":
      case "check":
      case "radio":
      case "drop":
        var o = e.arrow === true || e.arrow !== false && ["menu", "menu-radio", "menu-check", "drop", "color", "text-color"].includes(e.type);
        t = `
                    <div id="tb_${this.name}_item_${e.id}" style="${e.hidden ? "display: none" : ""}"
                        class="${r.join(" ")} ${e.class || ""}"
                        ${e.disabled ? "" : `data-click='["click","${e.id}"]'
                               data-mouseenter='["mouseAction", "event", "this", "Enter", "${e.id}"]'
                               data-mouseleave='["mouseAction", "event", "this", "Leave", "${e.id}"]'
                               data-mousedown='["mouseAction", "event", "this", "Down", "${e.id}"]'
                               data-mouseup='["mouseAction", "event", "this", "Up", "${e.id}"]'`}
                    >
                        ${i}
                        ${n != "" ? `<div class="w2ui-tb-text" style="${e.style || ""}">
                                    ${b.lang(n)}
                                    ${e.count != null ? b.stripSpaces(`<span class="w2ui-tb-count">
                                                <span class="${this.last.badge[e.id] ? this.last.badge[e.id].className ?? "" : ""}"
                                                    style="${this.last.badge[e.id] ? this.last.badge[e.id].style ?? "" : ""}"
                                                >${e.count}</span>
                                           </span>`) : ""}
                                    ${o ? '<span class="w2ui-tb-down"><span></span></span>' : ""}
                                </div>` : ""}
                    </div>
                `;
        break;
      case "break":
        t = `<div id="tb_${this.name}_item_${e.id}" class="w2ui-tb-break"
                            style="${e.hidden ? "display: none" : ""}; ${e.style || ""}">
                            &#160;
                        </div>`;
        break;
      case "spacer":
        t = `<div id="tb_${this.name}_item_${e.id}" class="w2ui-tb-spacer"
                            style="${e.hidden ? "display: none" : ""}; ${e.style || ""}">
                        </div>`;
        break;
      case "html":
        t = `<div id="tb_${this.name}_item_${e.id}" class="w2ui-tb-html ${r.join(" ")}"
                            style="${e.hidden ? "display: none" : ""}; ${e.style || ""}">
                            ${typeof e.html == "function" ? e.html.call(this, e) : e.html}
                        </div>`;
    }
    return t;
  }
  tooltipShow(e) {
    if (this.tooltip != null) {
      var t = p(this.box).find("#tb_" + this.name + "_item_" + b.escapeId(e)).get(0), e = this.get(e), i = this.tooltip;
      let r = e.tooltip;
      typeof r == "function" && (r = r.call(this, e)), ["menu", "menu-radio", "menu-check", "drop", "color", "text-color"].includes(e.type) && e.checked == 1 || Ge.show({ anchor: t, name: this.name + "-tooltip", html: r, position: i });
    }
  }
  tooltipHide(e) {
    this.tooltip != null && Ge.hide(this.name + "-tooltip");
  }
  menuClick(e) {
    if (e.item && !e.item.disabled) {
      var t = this.trigger(e.remove !== true ? "click" : "remove", { target: e.item.id + ":" + e.subItem.id, item: e.item, subItem: e.subItem, originalEvent: e.originalEvent });
      if (t.isCancelled !== true) {
        let r = e.subItem, o = this.get(e.item.id), a = o.items;
        if (typeof a == "function" && (a = o.items()), o.type == "menu" && (o.selected = r.id), o.type == "menu-radio" && (o.selected = r.id, Array.isArray(a) && a.forEach((l) => {
          l.checked === true && delete l.checked, Array.isArray(l.items) && l.items.forEach((c) => {
            c.checked === true && delete c.checked;
          });
        }), r.checked = true), o.type == "menu-check") {
          if (Array.isArray(o.selected) || (o.selected = []), r.group == null) {
            var i = o.selected.indexOf(r.id);
            i == -1 ? (o.selected.push(r.id), r.checked = true) : (o.selected.splice(i, 1), r.checked = false);
          } else if (r.group !== false) {
            let l = [];
            i = o.selected.indexOf(r.id);
            let c = (h) => {
              h.forEach((d) => {
                var u;
                d.group === r.group && (u = o.selected.indexOf(d.id)) != -1 && (d.id != r.id && l.push(d.id), o.selected.splice(u, 1)), Array.isArray(d.items) && c(d.items);
              });
            };
            c(a), i == -1 && (o.selected.push(r.id), r.checked = true);
          }
        }
        if (typeof r.route == "string") {
          let l = r.route !== "" ? ("/" + r.route).replace(/\/{2,}/g, "/") : "";
          var n = b.parseRoute(l);
          if (0 < n.keys.length) for (let c = 0; c < n.keys.length; c++) this.routeData[n.keys[c].name] != null && (l = l.replace(new RegExp(":" + n.keys[c].name, "g"), this.routeData[n.keys[c].name]));
          setTimeout(() => {
            window.location.hash = l;
          }, 1);
        }
        this.refresh(e.item.id), t.finish();
      }
    }
  }
  colorClick(e) {
    var t;
    e.item && !e.item.disabled && (t = this.trigger("click", { target: e.item.id, item: e.item, color: e.color, final: e.final, originalEvent: e.originalEvent })).isCancelled !== true && (e.item.color = e.color, this.refresh(e.item.id), t.finish());
  }
  mouseAction(o, t, i, n) {
    var r = this.get(n), o = this.trigger("mouse" + i, { target: n, item: r, object: r, originalEvent: o });
    if (o.isCancelled !== true && !r.disabled && !r.hidden) {
      switch (i) {
        case "Enter":
          p(t).addClass("over"), this.tooltipShow(n);
          break;
        case "Leave":
          p(t).removeClass("over down"), this.tooltipHide(n);
          break;
        case "Down":
          p(t).addClass("down");
          break;
        case "Up":
          p(t).removeClass("down");
      }
      o.finish();
    }
  }
}
class OM extends Xn {
  constructor(e) {
    super(e.name), this.box = null, this.name = null, this.active = null, this.reorder = false, this.flow = "down", this.tooltip = "top|left", this.tabs = [], this.routeData = {}, this.last = {}, this.right = "", this.style = "", this.onClick = null, this.onMouseEnter = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onClose = null, this.onRender = null, this.onRefresh = null, this.onResize = null, this.onDestroy = null, this.tab_template = { id: null, text: null, route: null, hidden: false, disabled: false, closable: false, tooltip: null, style: "", onClick: null, onRefresh: null, onClose: null };
    var t = e.tabs;
    delete e.tabs, Object.assign(this, e), Array.isArray(t) && this.add(t), e.tabs = t, typeof this.box == "string" && (this.box = p(this.box).get(0)), this.box && this.render(this.box);
  }
  add(e) {
    return this.insert(null, e);
  }
  insert(e, t) {
    Array.isArray(t) || (t = [t]);
    let i = [];
    return t.forEach((n) => {
      var r, o;
      n.id == null ? console.log(`ERROR: The parameter "id" is required but not supplied. (obj: ${this.name})`) : b.checkUniqueId(n.id, this.tabs, "tabs", this.name) && (n = Object.assign({}, this.tab_template, n), e == null ? (this.tabs.push(n), i.push(this.animateInsert(null, n))) : (r = this.get(e, true), o = this.tabs[r].id, this.tabs.splice(r, 0, n), i.push(this.animateInsert(o, n))));
    }), Promise.all(i);
  }
  remove() {
    let e = 0;
    return Array.from(arguments).forEach((t) => {
      t = this.get(t), t && (e++, this.tabs.splice(this.get(t.id, true), 1), p(this.box).find(`#tabs_${this.name}_tab_` + b.escapeId(t.id)).remove());
    }), this.resize(), e;
  }
  select(e) {
    return this.active != e && this.get(e) != null && (this.active = e, this.refresh(), true);
  }
  set(e, t) {
    var i = this.get(e, true);
    return i != null && (b.extend(this.tabs[i], t), this.refresh(e), true);
  }
  get(e, t) {
    if (arguments.length === 0) {
      var i = [];
      for (let n = 0; n < this.tabs.length; n++) this.tabs[n].id != null && i.push(this.tabs[n].id);
      return i;
    }
    for (let n = 0; n < this.tabs.length; n++) if (this.tabs[n].id == e) return t === true ? n : this.tabs[n];
    return null;
  }
  show() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      t = this.get(t), t && t.hidden !== false && (t.hidden = false, e.push(t.id));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t), this.resize();
      });
    }, 15), e;
  }
  hide() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      t = this.get(t), t && t.hidden !== true && (t.hidden = true, e.push(t.id));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t), this.resize();
      });
    }, 15), e;
  }
  enable() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      t = this.get(t), t && t.disabled !== false && (t.disabled = false, e.push(t.id));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t);
      });
    }, 15), e;
  }
  disable() {
    let e = [];
    return Array.from(arguments).forEach((t) => {
      t = this.get(t), t && t.disabled !== true && (t.disabled = true, e.push(t.id));
    }), setTimeout(() => {
      e.forEach((t) => {
        this.refresh(t);
      });
    }, 15), e;
  }
  dragMove(e) {
    if (this.last.reordering) {
      let a = function(c, h) {
        c += h;
        let d = l.tabs[c];
        return d = d && d.hidden ? a(c, h) : d;
      }, l = this;
      var t = this.last.moving, r = this.tabs[t.index], i = a(t.index, 1), n = a(t.index, -1), r = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(r.id));
      if (0 < t.divX && i) {
        var o = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(i.id));
        let c = parseInt(r.get(0).clientWidth), h = parseInt(o.get(0).clientWidth);
        if (c = c < h ? Math.floor(c / 3) : Math.floor(h / 3), h -= c, t.divX > h) return i = this.tabs.indexOf(i), this.tabs.splice(t.index, 0, this.tabs.splice(i, 1)[0]), t.$tab.before(o.get(0)), t.$tab.css("opacity", 0), void Object.assign(this.last.moving, { index: i, divX: -c, x: e.pageX + c, left: t.left + t.divX + c });
      }
      if (t.divX < 0 && n) {
        o = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(n.id));
        let c = parseInt(r.get(0).clientWidth), h = parseInt(o.get(0).clientWidth);
        c = c < h ? Math.floor(c / 3) : Math.floor(h / 3), h -= c, Math.abs(t.divX) > h && (i = this.tabs.indexOf(n), this.tabs.splice(t.index, 0, this.tabs.splice(i, 1)[0]), o.before(t.$tab), t.$tab.css("opacity", 0), Object.assign(t, { index: i, divX: c, x: e.pageX - c, left: t.left + t.divX - c }));
      }
    }
  }
  mouseAction(e, t, i) {
    var n = this.get(t), r = this.trigger("mouse" + e, { target: t, tab: n, object: n, originalEvent: i });
    if (r.isCancelled !== true && !n.disabled && !n.hidden) {
      switch (e) {
        case "Enter":
          this.tooltipShow(t);
          break;
        case "Leave":
          this.tooltipHide(t);
          break;
        case "Down":
          this.initReorder(t, i);
      }
      r.finish();
    }
  }
  tooltipShow(i) {
    var t = this.get(i), i = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(i)).get(0);
    if (this.tooltip != null && !t.disabled && !this.last.reordering) {
      var n = this.tooltip;
      let r = t.tooltip;
      typeof r == "function" && (r = r.call(this, t)), Ge.show({ anchor: i, name: this.name + "_tooltip", html: r, position: n });
    }
  }
  tooltipHide(e) {
    this.tooltip != null && Ge.hide(this.name + "_tooltip");
  }
  getTabHTML(e) {
    if (e = this.get(e, true), e = this.tabs[e], e == null) return false;
    e.text == null && e.caption != null && (e.text = e.caption), e.tooltip == null && e.hint != null && (e.tooltip = e.hint), e.caption != null && console.log("NOTICE: tabs tab.caption property is deprecated, please use tab.text. Tab -> ", e), e.hint != null && console.log("NOTICE: tabs tab.hint property is deprecated, please use tab.tooltip. Tab -> ", e);
    let t = e.text, i = ((t = typeof t == "function" ? t.call(this, e) : t) == null && (t = ""), ""), n = "";
    return e.hidden && (n += "display: none;"), e.disabled && (n += "opacity: 0.2;"), e.closable && !e.disabled && (i = `<div class="w2ui-tab-close w2ui-eaction ${this.active === e.id ? "active" : ""}"
                data-mousedown="stop" data-mouseup="clickClose|${e.id}|event">
            </div>`), `
            <div id="tabs_${this.name}_tab_${e.id}" style="${n} ${e.style}"
                class="w2ui-tab w2ui-eaction ${this.active === e.id ? "active" : ""} ${e.closable ? "closable" : ""} ${e.class || ""}"
                data-mouseenter="mouseAction|Enter|${e.id}|event]"
                data-mouseleave="mouseAction|Leave|${e.id}|event]"
                data-mousedown="mouseAction|Down|${e.id}|event"
                data-mouseup="mouseAction|Up|${e.id}|event"
                data-click="click|${e.id}|event"
               >
                    ${b.lang(t) + i}
            </div>`;
  }
  refresh(e) {
    var t = Date.now(), i = (this.flow == "up" ? p(this.box).addClass("w2ui-tabs-up") : p(this.box).removeClass("w2ui-tabs-up"), this.trigger("refresh", { target: e ?? this.name, object: this.get(e) }));
    if (i.isCancelled !== true) {
      if (e == null) for (let o = 0; o < this.tabs.length; o++) this.refresh(this.tabs[o].id);
      else {
        var n = "#tabs_" + this.name + "_tab_" + b.escapeId(e), r = p(this.box).find(n), e = this.getTabHTML(e);
        r.length === 0 ? p(this.box).find("#tabs_" + this.name + "_right").before(e) : p(this.box).find(".tab-animate-insert").length == 0 && r.replace(e), b.bindEvents(p(this.box).find(n + `, ${n} .w2ui-eaction`), this);
      }
      return p(this.box).find("#tabs_" + this.name + "_right").html(this.right), i.finish(), Date.now() - t;
    }
  }
  render(e) {
    var t = Date.now(), i = (typeof e == "string" && (e = p(e).get(0)), this.trigger("render", { target: this.name, box: e ?? this.box }));
    if (i.isCancelled !== true) return e != null && (0 < p(this.box).find("#tabs_" + this.name + "_right").length && p(this.box).removeAttr("name").removeClass("w2ui-reset w2ui-tabs").html(""), this.box = e), !!this.box && (e = `
            <div class="w2ui-tabs-line"></div>
            <div class="w2ui-scroll-wrapper w2ui-eaction" data-mousedown="resize">
                <div id="tabs_${this.name}_right" class="w2ui-tabs-right">${this.right}</div>
            </div>
            <div class="w2ui-scroll-left w2ui-eaction" data-click='["scroll","left"]'></div>
            <div class="w2ui-scroll-right w2ui-eaction" data-click='["scroll","right"]'></div>`, p(this.box).attr("name", this.name).addClass("w2ui-reset w2ui-tabs").html(e), 0 < p(this.box).length && (p(this.box)[0].style.cssText += this.style), b.bindEvents(p(this.box).find(".w2ui-eaction"), this), this.last.observeResize = new ResizeObserver(() => {
      this.resize();
    }), this.last.observeResize.observe(this.box), i.finish(), this.refresh(), this.resize(), Date.now() - t);
  }
  initReorder(e, t) {
    if (this.reorder) {
      let i = this, n = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(e)), r = this.get(e, true), o = p(n.get(0).cloneNode(true)), a;
      o.attr("id", "#tabs_" + this.name + "_tab_ghost"), this.last.moving = { index: r, indexFrom: r, $tab: n, $ghost: o, divX: 0, left: n.get(0).getBoundingClientRect().left, parentX: p(this.box).get(0).getBoundingClientRect().left, x: t.pageX, opacity: n.css("opacity") }, p(document).off(".w2uiTabReorder").on("mousemove.w2uiTabReorder", function(l) {
        if (!i.last.reordering) {
          if ((a = i.trigger("reorder", { target: i.tabs[r].id, indexFrom: r, tab: i.tabs[r] })).isCancelled === true) return;
          Ge.hide(this.name + "_tooltip"), i.last.reordering = true, o.addClass("moving"), o.css({ "pointer-events": "none", position: "absolute", left: n.get(0).getBoundingClientRect().left }), n.css("opacity", 0), p(i.box).find(".w2ui-scroll-wrapper").append(o.get(0)), p(i.box).find(".w2ui-tab-close").hide();
        }
        i.last.moving.divX = l.pageX - i.last.moving.x, o.css("left", i.last.moving.left - i.last.moving.parentX + i.last.moving.divX + "px"), i.dragMove(l);
      }).on("mouseup.w2uiTabReorder", function() {
        p(document).off(".w2uiTabReorder"), o.css({ transition: "0.1s", left: i.last.moving.$tab.get(0).getBoundingClientRect().left - i.last.moving.parentX }), p(i.box).find(".w2ui-tab-close").show(), setTimeout(() => {
          o.remove(), n.css({ opacity: i.last.moving.opacity }), i.last.reordering && a.finish({ indexTo: i.last.moving.index }), i.last.reordering = false;
        }, 100);
      });
    }
  }
  scroll(e, t) {
    return new Promise((i, n) => {
      var r = p(this.box).find(".w2ui-scroll-wrapper"), o = r.get(0).scrollLeft, a = r.find(".w2ui-tabs-right").get(0), l = r.parent().get(0).getBoundingClientRect().width, c = o + parseInt(a.offsetLeft) + parseInt(a.clientWidth);
      switch (e) {
        case "left": {
          let h = o - l + 50;
          h <= 0 && (h = 0), r.get(0).scrollTo({ top: 0, left: h, behavior: t ? "atuo" : "smooth" });
          break;
        }
        case "right": {
          let h = o + l - 50;
          h >= c - l && (h = c - l), r.get(0).scrollTo({ top: 0, left: h, behavior: t ? "atuo" : "smooth" });
          break;
        }
      }
      setTimeout(() => {
        this.resize(), i();
      }, t ? 0 : 350);
    });
  }
  scrollIntoView(e, t) {
    return new Promise((i, n) => {
      e == null && (e = this.active), this.get(e) != null && (p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(e)).get(0).scrollIntoView({ block: "start", inline: "center", behavior: t ? "atuo" : "smooth" }), setTimeout(() => {
        this.resize(), i();
      }, t ? 0 : 500));
    });
  }
  resize() {
    var e = Date.now();
    if (this.box != null) {
      var t, i, n, r, o = this.trigger("resize", { target: this.name });
      if (o.isCancelled !== true) return (t = p(this.box)).find(".w2ui-scroll-left, .w2ui-scroll-right").hide(), i = t.find(".w2ui-scroll-wrapper").get(0), r = t.find(".w2ui-tabs-right"), (n = t.get(0).getBoundingClientRect().width) < (r = 0 < r.length ? r[0].offsetLeft + r[0].clientWidth : 0) && (0 < i.scrollLeft && t.find(".w2ui-scroll-left").show(), n < r - i.scrollLeft) && t.find(".w2ui-scroll-right").show(), o.finish(), Date.now() - e;
    }
  }
  destroy() {
    var _a2;
    var e = this.trigger("destroy", { target: this.name });
    e.isCancelled !== true && (0 < p(this.box).find("#tabs_" + this.name + "_right").length && p(this.box).removeAttr("name").removeClass("w2ui-reset w2ui-tabs").html(""), (_a2 = this.last.observeResize) == null ? void 0 : _a2.disconnect(), delete on[this.name], e.finish());
  }
  click(e, t) {
    var i = this.get(e);
    if (i == null || i.disabled || this.last.reordering) return false;
    if (e = this.trigger("click", { target: e, tab: i, object: i, originalEvent: t }), e.isCancelled !== true) {
      if (p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(this.active)).removeClass("active"), this.active = i.id, p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(this.active)).addClass("active"), typeof i.route == "string") {
        let r = i.route !== "" ? ("/" + i.route).replace(/\/{2,}/g, "/") : "";
        var n = b.parseRoute(r);
        if (0 < n.keys.length) for (let o = 0; o < n.keys.length; o++) this.routeData[n.keys[o].name] != null && (r = r.replace(new RegExp(":" + n.keys[o].name, "g"), this.routeData[n.keys[o].name]));
        setTimeout(() => {
          window.location.hash = r;
        }, 1);
      }
      e.finish();
    }
  }
  clickClose(e, t) {
    var i = this.get(e);
    if (i == null || i.disabled) return false;
    let n = this.trigger("close", { target: e, object: i, tab: i, originalEvent: t });
    n.isCancelled !== true && (this.animateClose(e).then(() => {
      this.remove(e), n.finish(), this.refresh();
    }), t) && t.stopPropagation();
  }
  animateClose(e) {
    return new Promise((t, i) => {
      var n = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(e)), r = parseInt(n.get(0).clientWidth || 0);
      let o = n.replace(`<div class="tab-animate-close" style="display: inline-block; flex-shrink: 0; width: ${r}px; transition: width 0.25s"></div>`);
      setTimeout(() => {
        o.css({ width: "0px" });
      }, 1), setTimeout(() => {
        o.remove(), this.resize(), t();
      }, 500);
    });
  }
  animateInsert(e, t) {
    return new Promise((i, n) => {
      let r = p(this.box).find("#tabs_" + this.name + "_tab_" + b.escapeId(e)), o = p.html(this.getTabHTML(t.id));
      if (r.length == 0) (r = p(this.box).find("#tabs_tabs_right")).before(o), this.resize();
      else {
        o.css({ opacity: 0 }), p(this.box).find("#tabs_tabs_right").before(o.get(0));
        let a = p(this.box).find("#" + o.attr("id")).get(0).clientWidth ?? 0, l = p.html('<div class="tab-animate-insert" style="flex-shrink: 0; width: 0; transition: width 0.25s"></div>');
        r.before(l), o.hide(), l.before(o[0]), setTimeout(() => {
          l.css({ width: a + "px" });
        }, 1), setTimeout(() => {
          l.remove(), o.css({ opacity: 1 }).show(), this.refresh(t.id), this.resize(), i();
        }, 500);
      }
    });
  }
}
class UM extends Xn {
  constructor(e) {
    if (super(e.name), this.name = null, this.box = null, this.columns = [], this.columnGroups = [], this.records = [], this.summary = [], this.searches = [], this.toolbar = {}, this.ranges = [], this.contextMenu = [], this.searchMap = {}, this.searchData = [], this.sortMap = {}, this.sortData = [], this.savedSearches = [], this.defaultSearches = [], this.total = 0, this.recid = null, this.last = { field: "", label: "", logic: "AND", search: "", searchIds: [], selection: { indexes: [], columns: {} }, saved_sel: null, multi: false, scrollTop: 0, scrollLeft: 0, colStart: 0, colEnd: 0, fetch: { action: "", offset: null, start: 0, response: 0, options: null, controller: null, loaded: false, hasMore: false }, pull_more: false, pull_refresh: true, range_start: null, range_end: null, sel_ind: null, sel_col: null, sel_type: null, sel_recid: null, idCache: {}, move: null, cancelClick: null, inEditMode: false, _edit: null, kbd_timer: null, marker_timer: null, click_time: null, click_recid: null, bubbleEl: null, colResizing: false, tmp: null, copy_event: null, userSelect: "", columnDrag: false, state: null, show_extra: 0, toolbar_height: 0 }, this.header = "", this.url = "", this.limit = 100, this.offset = 0, this.postData = {}, this.routeData = {}, this.httpHeaders = {}, this.show = { header: false, toolbar: false, footer: false, columnMenu: true, columnHeaders: true, lineNumbers: false, expandColumn: false, selectColumn: false, emptyRecords: true, toolbarReload: true, toolbarColumns: false, toolbarSearch: true, toolbarAdd: false, toolbarEdit: false, toolbarDelete: false, toolbarSave: false, searchAll: true, searchLogic: true, searchHiddenMsg: false, searchSave: true, statusRange: true, statusBuffered: false, statusRecordID: true, statusSelection: true, statusResponse: true, statusSort: false, statusSearch: false, recordTitles: false, selectionBorder: true, skipRecords: true, saveRestoreState: true }, this.stateId = null, this.hasFocus = false, this.autoLoad = true, this.fixedBody = true, this.recordHeight = 32, this.lineNumberWidth = 34, this.keyboard = true, this.selectType = "row", this.liveSearch = false, this.multiSearch = true, this.multiSelect = true, this.multiSort = true, this.reorderColumns = false, this.reorderRows = false, this.showExtraOnSearch = 0, this.markSearch = true, this.columnTooltip = "top|bottom", this.disableCVS = false, this.nestedFields = true, this.vs_start = 150, this.vs_extra = 5, this.style = "", this.tabIndex = null, this.dataType = null, this.parser = null, this.advanceOnEdit = true, this.useLocalStorage = true, this.colTemplate = { text: "", field: "", size: null, min: 20, max: null, gridMinWidth: null, sizeCorrected: null, sizeCalculated: null, sizeOriginal: null, sizeType: null, hidden: false, sortable: false, sortMode: null, searchable: false, resizable: true, hideable: true, autoResize: null, attr: "", style: "", render: null, title: null, tooltip: null, editable: {}, frozen: false, info: null, clipboardCopy: false }, this.stateColProps = { text: false, field: true, size: true, min: false, max: false, gridMinWidth: false, sizeCorrected: false, sizeCalculated: true, sizeOriginal: true, sizeType: true, hidden: true, sortable: false, sortMode: true, searchable: false, resizable: false, hideable: false, autoResize: false, attr: false, style: false, render: false, title: false, tooltip: false, editable: false, frozen: true, info: false, clipboardCopy: false }, this.msgDelete = "Are you sure you want to delete ${count} ${records}?", this.msgNotJSON = "Returned data is not in valid JSON format.", this.msgHTTPError = "HTTP error. See console for more details.", this.msgServerError = "Server error", this.msgRefresh = "Refreshing...", this.msgNeedReload = "Your remote data source record count has changed, reloading from the first record.", this.msgEmpty = "", this.buttons = { reload: { type: "button", id: "w2ui-reload", icon: "w2ui-icon-reload", tooltip: "Reload data in the list" }, columns: { type: "menu-check", id: "w2ui-column-on-off", icon: "w2ui-icon-columns", tooltip: "Show/hide columns", overlay: { align: "none" } }, search: { type: "html", id: "w2ui-search", html: '<div class="w2ui-icon w2ui-icon-search w2ui-search-down w2ui-action" data-click="searchShowFields"></div>' }, add: { type: "button", id: "w2ui-add", text: "Add New", tooltip: "Add new record", icon: "w2ui-icon-plus" }, edit: { type: "button", id: "w2ui-edit", text: "Edit", tooltip: "Edit selected record", icon: "w2ui-icon-pencil", batch: 1, disabled: true }, delete: { type: "button", id: "w2ui-delete", text: "Delete", tooltip: "Delete selected records", icon: "w2ui-icon-cross", batch: true, disabled: true }, save: { type: "button", id: "w2ui-save", text: "Save", tooltip: "Save changed records", icon: "w2ui-icon-check" } }, this.operators = { text: ["is", "begins", "contains", "ends"], number: ["=", "between", ">", "<", ">=", "<="], date: ["is", { oper: "less", text: "before" }, { oper: "more", text: "since" }, "between"], list: ["is"], hex: ["is", "between"], color: ["is", "begins", "contains", "ends"], enum: ["in", "not in"] }, this.defaultOperator = { text: "begins", number: "=", date: "is", list: "is", enum: "in", hex: "begins", color: "begins" }, this.operatorsMap = { text: "text", int: "number", float: "number", money: "number", currency: "number", percent: "number", hex: "hex", alphanumeric: "text", color: "color", date: "date", time: "date", datetime: "date", list: "list", combo: "text", enum: "enum", file: "enum", select: "list", radio: "list", checkbox: "list", toggle: "list" }, this.onAdd = null, this.onEdit = null, this.onRequest = null, this.onLoad = null, this.onDelete = null, this.onSave = null, this.onSelect = null, this.onClick = null, this.onDblClick = null, this.onContextMenu = null, this.onContextMenuClick = null, this.onColumnClick = null, this.onColumnDblClick = null, this.onColumnContextMenu = null, this.onColumnResize = null, this.onColumnAutoResize = null, this.onSort = null, this.onSearch = null, this.onSearchOpen = null, this.onChange = null, this.onRestore = null, this.onExpand = null, this.onCollapse = null, this.onError = null, this.onKeydown = null, this.onToolbar = null, this.onColumnOnOff = null, this.onCopy = null, this.onPaste = null, this.onSelectionExtend = null, this.onEditField = null, this.onRender = null, this.onRefresh = null, this.onReload = null, this.onResize = null, this.onDestroy = null, this.onStateSave = null, this.onStateRestore = null, this.onFocus = null, this.onBlur = null, this.onReorderRow = null, this.onSearchSave = null, this.onSearchRemove = null, this.onSearchSelect = null, this.onColumnSelect = null, this.onColumnDragStart = null, this.onColumnDragEnd = null, this.onResizerDblClick = null, this.onMouseEnter = null, this.onMouseLeave = null, b.extend(this, e), Array.isArray(this.records)) {
      let t = [];
      this.records.forEach((i, n) => {
        var _a2;
        i[this.recid] != null && (i.recid = i[this.recid]), i.recid == null && console.log("ERROR: Cannot add records without recid. (obj: " + this.name + ")"), ((_a2 = i.w2ui) == null ? void 0 : _a2.summary) === true && (this.summary.push(i), t.push(n));
      }), t.sort();
      for (let i = t.length - 1; 0 <= i; i--) this.records.splice(t[i], 1);
    }
    Array.isArray(this.columns) && this.columns.forEach((t, i) => {
      if (t = b.extend({}, this.colTemplate, t), i = (this.columns[i] = t).searchable, i != null && i !== false && this.getSearch(t.field) == null) if (b.isPlainObject(i)) this.addSearch(b.extend({ field: t.field, label: t.text, type: "text" }, i));
      else {
        let n = t.searchable, r = "";
        t.searchable === true && (n = "text", r = 'size="20"'), this.addSearch({ field: t.field, label: t.text, type: n, attr: r });
      }
    }), Array.isArray(this.defaultSearches) && this.defaultSearches.forEach((t, i) => {
      t.id = "default-" + i, t.icon ?? (t.icon = "w2ui-icon-search");
    }), e = this.cache("searches"), Array.isArray(e) && e.forEach((t) => {
      this.savedSearches.push({ id: t.id ?? "none", text: t.text ?? "none", icon: "w2ui-icon-search", remove: true, logic: t.logic ?? "AND", data: t.data ?? [] });
    }), typeof this.box == "string" && (this.box = p(this.box).get(0)), this.box && this.render(this.box);
  }
  add(e, t) {
    var _a2, _b2;
    Array.isArray(e) || (e = [e]);
    let i = 0;
    for (let r = 0; r < e.length; r++) {
      var n = e[r];
      n[this.recid] != null && (n.recid = n[this.recid]), n.recid == null ? console.log("ERROR: Cannot add record without recid. (obj: " + this.name + ")") : (((_a2 = n.w2ui) == null ? void 0 : _a2.summary) === true ? t ? this.summary.unshift(n) : this.summary.push(n) : t ? this.records.unshift(n) : this.records.push(n), i++);
    }
    return (((_b2 = this.url) == null ? void 0 : _b2.get) ?? this.url) || (this.total = this.records.length, this.localSort(false, true), this.localSearch()), this.refresh(), i;
  }
  find(e, t, i) {
    var n, r = [];
    let o = false;
    for (n in e = e ?? {}) String(n).indexOf(".") != -1 && (o = true);
    var a = i ? this.last.range_start : 0;
    let l = i ? this.last.range_end + 1 : this.records.length;
    l > this.records.length && (l = this.records.length);
    for (let h = a; h < l; h++) {
      let d = true;
      for (var c in e) {
        let u = this.records[h][c];
        o && String(c).indexOf(".") != -1 && (u = this.parseField(this.records[h], c)), e[c] == "not-null" ? u != null && u !== "" || (d = false) : e[c] != u && (d = false);
      }
      d && t !== true && r.push(this.records[h].recid), d && t === true && r.push(h);
    }
    return r;
  }
  set(e, t, i) {
    if (typeof e == "object" && e !== null && (i = t, t = e, e = null), e == null) {
      for (let r = 0; r < this.records.length; r++) b.extend(this.records[r], t);
      i !== true && this.refresh();
    } else {
      var n = this.get(e, true);
      if (n == null) return false;
      !this.records[n] || this.records[n].recid != e ? b.extend(this.summary[n], t) : b.extend(this.records[n], t), i !== true && this.refreshRow(e, n);
    }
    return true;
  }
  get(e, t) {
    if (Array.isArray(e)) {
      var i = [];
      for (let o = 0; o < e.length; o++) {
        var n = this.get(e[o], t);
        n !== null && i.push(n);
      }
      return i;
    }
    {
      let o = this.last.idCache;
      o || (this.last.idCache = o = {});
      var r = o[e];
      if (typeof r == "number") {
        if (0 <= r && r < this.records.length && this.records[r].recid == e) return t === true ? r : this.records[r];
        if (0 <= (r = ~r) && r < this.summary.length && this.summary[r].recid == e) return t === true ? r : this.summary[r];
        this.last.idCache = o = {};
      }
      for (let a = 0; a < this.records.length; a++) if (this.records[a].recid == e) return o[e] = a, t === true ? a : this.records[a];
      for (let a = 0; a < this.summary.length; a++) if (this.summary[a].recid == e) return o[e] = ~a, t === true ? a : this.summary[a];
      return null;
    }
  }
  getFirst(e) {
    if (this.records.length == 0) return null;
    let t = this.records[0];
    var i = this.last.searchIds;
    return t = 0 < this.searchData.length ? Array.isArray(i) && 0 < i.length ? this.records[i[e || 0]] : null : t;
  }
  remove() {
    var _a2;
    let e = 0;
    for (let t = 0; t < arguments.length; t++) {
      for (let i = this.records.length - 1; 0 <= i; i--) this.records[i].recid == arguments[t] && (this.records.splice(i, 1), e++);
      for (let i = this.summary.length - 1; 0 <= i; i--) this.summary[i].recid == arguments[t] && (this.summary.splice(i, 1), e++);
    }
    return (((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url) || (this.localSort(false, true), this.localSearch()), this.refresh(), e;
  }
  addColumn(e, t) {
    let i = 0;
    arguments.length == 1 ? (t = e, e = this.columns.length) : (e = typeof e == "string" ? this.getColumn(e, true) : e) == null && (e = this.columns.length), Array.isArray(t) || (t = [t]);
    for (let r = 0; r < t.length; r++) {
      var n = b.extend({}, this.colTemplate, t[r]);
      if (this.columns.splice(e, 0, n), t[r].searchable) {
        let o = t[r].searchable, a = "";
        t[r].searchable === true && (o = "text", a = 'size="20"'), this.addSearch({ field: t[r].field, label: t[r].text, type: o, attr: a });
      }
      e++, i++;
    }
    return this.refresh(), i;
  }
  removeColumn() {
    let e = 0;
    for (let t = 0; t < arguments.length; t++) for (let i = this.columns.length - 1; 0 <= i; i--) this.columns[i].field == arguments[t] && (this.columns[i].searchable && this.removeSearch(arguments[t]), this.columns.splice(i, 1), e++);
    return this.refresh(), e;
  }
  getColumn(e, t) {
    if (arguments.length === 0) {
      var i = [];
      for (let n = 0; n < this.columns.length; n++) i.push(this.columns[n].field);
      return i;
    }
    for (let n = 0; n < this.columns.length; n++) if (this.columns[n].field == e) return t === true ? n : this.columns[n];
    return null;
  }
  updateColumn(e, t) {
    let i = 0;
    return (e = Array.isArray(e) ? e : [e]).forEach((n) => {
      this.columns.forEach((r) => {
        if (r.field == n) {
          let o = b.clone(t);
          Object.keys(o).forEach((a) => {
            typeof o[a] == "function" && (o[a] = o[a](r)), r[a] != o[a] && i++;
          }), b.extend(r, o);
        }
      });
    }), 0 < i && this.refresh(), i;
  }
  toggleColumn() {
    return this.updateColumn(Array.from(arguments), { hidden(e) {
      return !e.hidden;
    } });
  }
  showColumn() {
    return this.updateColumn(Array.from(arguments), { hidden: false });
  }
  hideColumn() {
    return this.updateColumn(Array.from(arguments), { hidden: true });
  }
  addSearch(e, t) {
    let i = 0;
    arguments.length == 1 ? (t = e, e = this.searches.length) : (e = typeof e == "string" ? this.getSearch(e, true) : e) == null && (e = this.searches.length), Array.isArray(t) || (t = [t]);
    for (let n = 0; n < t.length; n++) this.searches.splice(e, 0, t[n]), e++, i++;
    return this.searchClose(), i;
  }
  removeSearch() {
    let e = 0;
    for (let t = 0; t < arguments.length; t++) for (let i = this.searches.length - 1; 0 <= i; i--) this.searches[i].field == arguments[t] && (this.searches.splice(i, 1), e++);
    return this.searchClose(), e;
  }
  getSearch(e, t) {
    if (arguments.length === 0) {
      var i = [];
      for (let n = 0; n < this.searches.length; n++) i.push(this.searches[n].field);
      return i;
    }
    for (let n = 0; n < this.searches.length; n++) if (this.searches[n].field == e) return t === true ? n : this.searches[n];
    return null;
  }
  toggleSearch() {
    let e = 0;
    for (let t = 0; t < arguments.length; t++) for (let i = this.searches.length - 1; 0 <= i; i--) this.searches[i].field == arguments[t] && (this.searches[i].hidden = !this.searches[i].hidden, e++);
    return this.searchClose(), e;
  }
  showSearch() {
    let e = 0;
    for (let t = 0; t < arguments.length; t++) for (let i = this.searches.length - 1; 0 <= i; i--) this.searches[i].field == arguments[t] && this.searches[i].hidden !== false && (this.searches[i].hidden = false, e++);
    return this.searchClose(), e;
  }
  hideSearch() {
    let e = 0;
    for (let t = 0; t < arguments.length; t++) for (let i = this.searches.length - 1; 0 <= i; i--) this.searches[i].field == arguments[t] && this.searches[i].hidden !== true && (this.searches[i].hidden = true, e++);
    return this.searchClose(), e;
  }
  getSearchData(e) {
    for (let t = 0; t < this.searchData.length; t++) if (this.searchData[t].field == e) return this.searchData[t];
    return null;
  }
  localSort(e, t) {
    var _a2, _b2, _c2;
    let i = this;
    if (((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url) console.log("ERROR: grid.localSort can only be used on local data source, grid.url should be empty.");
    else if (Object.keys(this.sortData).length !== 0) {
      let a = function(d) {
        var u;
        return d.w2ui && d.w2ui.parent_recid != null ? d.w2ui._path || ((u = i.get(d.w2ui.parent_recid)) ? a(u).concat(d) : (console.log("ERROR: no parent record: " + d.w2ui.parent_recid), [d])) : [d];
      }, l = function(d, u) {
        if (d === u) return 0;
        for (let _ = 0; _ < i.sortData.length; _++) {
          var f = i.sortData[_].field, m = i.sortData[_].field_ || f;
          let g = d[m], v = u[m];
          if (String(f).indexOf(".") != -1 && (g = i.parseField(d, m), v = i.parseField(u, m)), m = i.getColumn(f), f = (m && 0 < Object.keys(m.editable).length && (b.isPlainObject(g) && g.text && (g = g.text), b.isPlainObject(v)) && v.text && (v = v.text), c(g, v, _, i.sortData[_].direction, m.sortMode || "default")), f !== 0) return f;
        }
        return c(d.recid, u.recid, 0, "asc");
      }, c = function(d, u, f, m, _) {
        if (d === u) return 0;
        if ((d == null || d === "") && u != null && u !== "") return 1;
        if (d != null && d !== "" && (u == null || u === "")) return -1;
        if (m = m.toLowerCase() === "asc" ? 1 : -1, typeof d != typeof u) return typeof u < typeof d ? m : -m;
        if (d.constructor.name != u.constructor.name) return d.constructor.name > u.constructor.name ? m : -m;
        d && typeof d == "object" && (d = d.valueOf()), u && typeof u == "object" && (u = u.valueOf());
        var g = {}.toString;
        switch (d && typeof d == "object" && d.toString != g && (d = String(d)), u && typeof u == "object" && u.toString != g && (u = String(u)), typeof d == "string" && (d = d.toLowerCase().trim()), typeof u == "string" && (u = u.toLowerCase().trim()), _) {
          case "natural":
            _ = b.naturalCompare;
            break;
          case "i18n":
            _ = b.i18nCompare;
        }
        return typeof _ == "function" ? _(d, u) * m : u < d ? m : d < u ? -m : 0;
      }, h = Date.now();
      this.selectionSave(), this.prepareData(), t || this.reset();
      for (let d = 0; d < this.sortData.length; d++) {
        var n = this.getColumn(this.sortData[d].field);
        if (!n) return;
        typeof n.render == "string" && (["date", "age"].indexOf(n.render.split(":")[0]) != -1 && (this.sortData[d].field_ = n.field + "_"), ["time"].indexOf(n.render.split(":")[0]) != -1) && (this.sortData[d].field_ = n.field + "_");
      }
      for (let d = 0; d < i.records.length; d++) {
        var r = i.records[d];
        ((_b2 = r.w2ui) == null ? void 0 : _b2.parent_recid) != null && (r.w2ui._path = a(r));
      }
      this.records.sort((d, u) => {
        if (!(d.w2ui && d.w2ui.parent_recid != null || u.w2ui && u.w2ui.parent_recid != null)) return l(d, u);
        var f = a(d), m = a(u);
        for (let g = 0; g < Math.min(f.length, m.length); g++) {
          var _ = l(f[g], m[g]);
          if (_ !== 0) return _;
        }
        return f.length > m.length ? 1 : f.length < m.length ? -1 : (console.log("ERROR: two paths should not be equal."), 0);
      });
      for (let d = 0; d < i.records.length; d++) {
        var o = i.records[d];
        ((_c2 = o.w2ui) == null ? void 0 : _c2.parent_recid) != null && (o.w2ui._path = null);
      }
      return this.selectionRestore(t), h = Date.now() - h, e !== true && this.show.statusSort && setTimeout(() => {
        this.status(b.lang("Sorting took ${count} seconds", { count: h / 1e3 }));
      }, 10), h;
    }
  }
  localSearch(e) {
    var _a2;
    let t = this;
    var i = ((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url;
    if (i) console.log("ERROR: grid.localSearch can only be used on local data source, grid.url should be empty.");
    else {
      let r = Date.now(), o = {}.toString, a = {};
      if (this.total = this.records.length, this.last.searchIds = [], this.prepareData(), 0 < this.searchData.length && !i) {
        for (let l = this.total = 0; l < this.records.length; l++) {
          var n = this.records[l];
          if (function c(h) {
            var _a3, _b2;
            let d = 0, u, f, m, _, g = false;
            for (let v = 0; v < t.searchData.length; v++) {
              let y = t.searchData[v], x = t.getSearch(y.field);
              if (y != null) {
                x == null && (x = { field: y.field, type: y.type });
                let S = t.parseField(h, x.field);
                switch (u = S == null || typeof S == "object" && S.toString == o ? "" : String(S).toLowerCase(), y.value != null && (Array.isArray(y.value) ? (f = y.value[0], m = y.value[1]) : f = String(y.value).toLowerCase()), y.operator) {
                  case "=":
                  case "is":
                    t.parseField(h, x.field) == y.value ? d++ : x.type == "date" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatDate(_, "yyyy-mm-dd"), f = b.formatDate(b.isDate(f, b.settings.dateFormat, true), "yyyy-mm-dd"), u == f && d++) : x.type == "time" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatTime(_, "hh24:mi"), f = b.formatTime(f, "hh24:mi"), u == f && d++) : x.type == "datetime" && (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatDateTime(_, "yyyy-mm-dd|hh24:mm:ss"), f = b.formatDateTime(b.isDateTime(f, b.settings.datetimeFormat, true), "yyyy-mm-dd|hh24:mm:ss"), u == f) && d++;
                    break;
                  case "between":
                    ["int", "float", "money", "currency", "percent"].indexOf(x.type) != -1 ? parseFloat(t.parseField(h, x.field)) >= parseFloat(f) && parseFloat(t.parseField(h, x.field)) <= parseFloat(m) && d++ : x.type == "date" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.isDate(_, b.settings.dateFormat, true), f = b.isDate(f, b.settings.dateFormat, true), (m = b.isDate(m, b.settings.dateFormat, true)) != null && (m = new Date(m.getTime() + 864e5)), u >= f && u < m && d++) : x.type == "time" ? (u = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), f = b.isTime(f, true), m = b.isTime(m, true), f = (/* @__PURE__ */ new Date()).setHours(f.hours, f.minutes, f.seconds || 0, 0), m = (/* @__PURE__ */ new Date()).setHours(m.hours, m.minutes, m.seconds || 0, 0), u >= f && u < m && d++) : x.type == "datetime" && (u = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), f = b.isDateTime(f, b.settings.datetimeFormat, true), m = (m = b.isDateTime(m, b.settings.datetimeFormat, true)) && new Date(m.getTime() + 864e5), u >= f) && u < m && d++;
                    break;
                  case "<=":
                    g = true;
                  case "<":
                  case "less":
                    ["int", "float", "money", "currency", "percent"].indexOf(x.type) != -1 ? (u = parseFloat(t.parseField(h, x.field)), f = parseFloat(y.value), (u < f || g && u === f) && d++) : x.type == "date" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.isDate(_, b.settings.dateFormat, true), f = b.isDate(f, b.settings.dateFormat, true), (u < f || g && u === f) && d++) : x.type == "time" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatTime(_, "hh24:mi"), f = b.formatTime(f, "hh24:mi"), (u < f || g && u === f) && d++) : x.type == "datetime" && (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatDateTime(_, "yyyy-mm-dd|hh24:mm:ss"), f = b.formatDateTime(b.isDateTime(f, b.settings.datetimeFormat, true), "yyyy-mm-dd|hh24:mm:ss"), u.length == f.length) && (u < f || g && u === f) && d++;
                    break;
                  case ">=":
                    g = true;
                  case ">":
                  case "more":
                    ["int", "float", "money", "currency", "percent"].indexOf(x.type) != -1 ? (u = parseFloat(t.parseField(h, x.field)), f = parseFloat(y.value), (u > f || g && u === f) && d++) : x.type == "date" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.isDate(_, b.settings.dateFormat, true), f = b.isDate(f, b.settings.dateFormat, true), (u > f || g && u === f) && d++) : x.type == "time" ? (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatTime(_, "hh24:mi"), f = b.formatTime(f, "hh24:mi"), (u > f || g && u === f) && d++) : x.type == "datetime" && (_ = t.parseField(h, x.field + "_") instanceof Date ? t.parseField(h, x.field + "_") : t.parseField(h, x.field), u = b.formatDateTime(_, "yyyy-mm-dd|hh24:mm:ss"), f = b.formatDateTime(b.isDateTime(f, b.settings.datetimeFormat, true), "yyyy-mm-dd|hh24:mm:ss"), u.length == f.length) && (u > f || g && u === f) && d++;
                    break;
                  case "in":
                    _ = y.value, (_ = y.svalue ? y.svalue : _).indexOf(b.isFloat(S) ? parseFloat(S) : S) === -1 && _.indexOf(u) === -1 || d++;
                    break;
                  case "not in":
                    _ = y.value, (_ = y.svalue ? y.svalue : _).indexOf(b.isFloat(S) ? parseFloat(S) : S) === -1 && _.indexOf(u) === -1 && d++;
                    break;
                  case "begins":
                  case "begins with":
                    u.indexOf(f) === 0 && d++;
                    break;
                  case "contains":
                    0 <= u.indexOf(f) && d++;
                    break;
                  case "null":
                    t.parseField(h, x.field) == null && d++;
                    break;
                  case "not null":
                    t.parseField(h, x.field) != null && d++;
                    break;
                  case "ends":
                  case "ends with":
                    let A = u.lastIndexOf(f);
                    A !== -1 && A == u.length - f.length && d++;
                }
              }
            }
            if (t.last.logic == "OR" && d !== 0 || t.last.logic == "AND" && d == t.searchData.length) return true;
            if (((_a3 = h.w2ui) == null ? void 0 : _a3.children) && ((_b2 = h.w2ui) == null ? void 0 : _b2.expanded) !== true) for (let v = 0; v < h.w2ui.children.length; v++) {
              let y = h.w2ui.children[v];
              if (c(y)) return true;
            }
            return false;
          }(n)) if ((n == null ? void 0 : n.w2ui) && function c(h) {
            let d = t.get(h, true);
            if (d == null || h == null || a[h] || t.last.searchIds.includes(d)) return;
            a[h] = true;
            let u = t.records[d];
            (u == null ? void 0 : u.w2ui) && c(u.w2ui.parent_recid), t.last.searchIds.push(d);
          }(n.w2ui.parent_recid), 0 < this.showExtraOnSearch) {
            let c = this.showExtraOnSearch, h = this.showExtraOnSearch;
            if (l < c && (c = l), l + h > this.records.length && (h = this.records.length - l), 0 < c) for (let d = l - c; d < l; d++) this.last.searchIds.indexOf(d) < 0 && this.last.searchIds.push(d);
            if (this.last.searchIds.indexOf(l) < 0 && this.last.searchIds.push(l), 0 < h) for (let d = l + 1; d <= l + h; d++) this.last.searchIds.indexOf(d) < 0 && this.last.searchIds.push(d);
          } else this.last.searchIds.push(l);
        }
        this.total = this.last.searchIds.length;
      }
      return r = Date.now() - r, e !== true && this.show.statusSearch && setTimeout(() => {
        this.status(b.lang("Search took ${count} seconds", { count: r / 1e3 }));
      }, 10), r;
    }
  }
  getRangeData(e, t) {
    var i = this.get(e[0].recid, true), n = this.get(e[1].recid, true), r = e[0].column, o = e[1].column, a = [];
    if (r == o) for (let m = i; m <= n; m++) {
      var l = this.records[m], c = l[this.columns[r].field] || null;
      a.push(t !== true ? c : { data: c, column: r, index: m, record: l });
    }
    else if (i == n) {
      var h = this.records[i];
      for (let m = r; m <= o; m++) {
        var d = h[this.columns[m].field] || null;
        a.push(t !== true ? d : { data: d, column: m, index: i, record: h });
      }
    } else for (let m = i; m <= n; m++) {
      var u = this.records[m];
      a.push([]);
      for (let _ = r; _ <= o; _++) {
        var f = u[this.columns[_].field];
        t !== true ? a[a.length - 1].push(f) : a[a.length - 1].push({ data: f, column: _, index: m, record: u });
      }
    }
    return a;
  }
  addRange(e) {
    let t = 0, i, n;
    if (this.selectType != "row") {
      Array.isArray(e) || (e = [e]);
      for (let o = 0; o < e.length; o++) {
        if (typeof e[o] != "object" && (e[o] = { name: "selection" }), e[o].name == "selection") {
          if (this.show.selectionBorder === false) continue;
          var r = this.getSelection();
          if (r.length === 0) {
            this.removeRange("selection");
            continue;
          }
          i = r[0], n = r[r.length - 1];
        } else i = e[o].range[0], n = e[o].range[1];
        if (i) {
          r = { name: e[o].name, range: [{ recid: i.recid, column: i.column }, { recid: n.recid, column: n.column }], style: e[o].style || "" };
          let a = false;
          for (let l = 0; l < this.ranges.length; l++) if (this.ranges[l].name == e[o].name) {
            a = l;
            break;
          }
          a !== false ? this.ranges[a] = r : this.ranges.push(r), t++;
        }
      }
      this.refreshRanges();
    }
    return t;
  }
  removeRange() {
    let e = 0;
    for (let i = 0; i < arguments.length; i++) {
      var t = arguments[i];
      p(this.box).find("#grid_" + this.name + "_" + t).remove(), p(this.box).find("#grid_" + this.name + "_f" + t).remove();
      for (let n = this.ranges.length - 1; 0 <= n; n--) this.ranges[n].name == t && (this.ranges.splice(n, 1), e++);
    }
    return e;
  }
  refreshRanges() {
    if (this.ranges.length !== 0) {
      let u = function(v) {
        var y = m.last.move;
        if (y && y.type == "expand") {
          y.divX = v.screenX - y.x, y.divY = v.screenY - y.y;
          let x, S, A = v.target;
          A.tagName.toUpperCase() != "TD" && (A = p(A).closest("td")[0]), (S = p(A).attr("col") != null ? parseInt(p(A).attr("col")) : S) != null && (A = p(A).closest("tr")[0], x = m.records[p(A).attr("index")].recid, y.newRange[1].recid != x || y.newRange[1].column != S) && (v = b.clone(y.newRange), y.newRange = [{ recid: y.recid, column: y.column }, { recid: x, column: S }], g.detail && (g.detail.newRange = b.clone(y.newRange), g.detail.originalRange = b.clone(y.originalRange)), (g = m.trigger("selectionExtend", g)).isCancelled === true ? (y.newRange = v, g.detail.newRange = v) : (m.removeRange("grid-selection-expand"), m.addRange({ name: "grid-selection-expand", range: y.newRange, style: "background-color: rgba(100,100,100,0.1); border: 2px dotted rgba(100,100,100,0.5);" })));
        }
      }, f = function(v) {
        m.removeRange("grid-selection-expand"), delete m.last.move, p("body").off(".w2ui-" + m.name), g.finish && g.finish();
      }, m = this, _;
      var e = Date.now(), t = p(this.box).find(`#grid_${this.name}_frecords`), i = p(this.box).find(`#grid_${this.name}_records`);
      for (let v = 0; v < this.ranges.length; v++) {
        var n = this.ranges[v], r = n.range[0], o = n.range[1];
        r.index == null && (r.index = this.get(r.recid, true)), o.index == null && (o.index = this.get(o.recid, true));
        let y = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(r.recid) + ' td[col="' + r.column + '"]'), x = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(o.recid) + ' td[col="' + o.column + '"]'), S = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(r.recid) + ' td[col="' + r.column + '"]'), A = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(o.recid) + ' td[col="' + o.column + '"]'), R = o.column;
        r.column < this.last.colStart && o.column > this.last.colStart && (y = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(r.recid) + ' td[col="start"]')), r.column < this.last.colEnd && o.column > this.last.colEnd && (x = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(o.recid) + ' td[col="end"]'), R = '"end"');
        var c = parseInt(p(this.box).find("#grid_" + this.name + "_rec_top").next().attr("index")), h = parseInt(p(this.box).find("#grid_" + this.name + "_rec_bottom").prev().attr("index")), d = parseInt(p(this.box).find("#grid_" + this.name + "_frec_top").next().attr("index")), a = parseInt(p(this.box).find("#grid_" + this.name + "_frec_bottom").prev().attr("index"));
        y.length === 0 && r.index < c && o.index > c && (y = p(this.box).find("#grid_" + this.name + "_rec_top").next().find('td[col="' + r.column + '"]')), x.length === 0 && o.index > h && r.index < h && (x = p(this.box).find("#grid_" + this.name + "_rec_bottom").prev().find('td[col="' + R + '"]')), S.length === 0 && r.index < d && o.index > d && (S = p(this.box).find("#grid_" + this.name + "_frec_top").next().find('td[col="' + r.column + '"]')), A.length === 0 && o.index > a && r.index < a && (A = p(this.box).find("#grid_" + this.name + "_frec_bottom").prev().find('td[col="' + o.column + '"]'));
        var l, c = p(this.box).find("#grid_" + this.name + "_editable").find(".w2ui-input"), h = c.attr("recid"), d = c.attr("column");
        n.name == "selection" && n.range[0].recid == h && n.range[0].column == d || (_ = p(this.box).find("#grid_" + this.name + "_f" + n.name), (0 < S.length || 0 < A.length) && (_.length === 0 ? (t.append('<div id="grid_' + this.name + "_f" + n.name + '" class="w2ui-selection" style="' + n.style + '">' + (n.name == "selection" ? '<div id="grid_' + this.name + '_resizer" class="w2ui-selection-resizer"></div>' : "") + "</div>"), _ = p(this.box).find("#grid_" + this.name + "_f" + n.name)) : (_.attr("style", n.style), _.find(".w2ui-selection-resizer").show()), A.length === 0 && ((A = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(o.recid) + " td:last-child")).length === 0 && (A = p(this.box).find("#grid_" + this.name + "_frec_bottom td:first-child")), _.css("border-right", "0px"), _.find(".w2ui-selection-resizer").hide()), r.recid != null) && o.recid != null && 0 < S.length && 0 < A.length ? (a = getComputedStyle(A[0]), c = S.prop("offsetTop") - S.prop("scrollTop"), h = S.prop("offsetLeft") + S.prop("scrollLeft"), d = A.prop("offsetTop") - A.prop("scrollTop"), l = A.prop("offsetLeft") + A.prop("scrollLeft"), _.show().css({ top: (0 < c ? c : 0) + "px", left: (0 < h ? h : 0) + "px", width: l - h + parseFloat(a.width) + 2 + "px", height: d - c + parseFloat(a.height) + 1 + "px" })) : _.hide(), _ = p(this.box).find("#grid_" + this.name + "_" + n.name), (0 < y.length || 0 < x.length) && (_.length === 0 ? (i.append('<div id="grid_' + this.name + "_" + n.name + '" class="w2ui-selection" style="' + n.style + '">' + (n.name == "selection" ? '<div id="grid_' + this.name + '_resizer" class="w2ui-selection-resizer"></div>' : "") + "</div>"), _ = p(this.box).find("#grid_" + this.name + "_" + n.name)) : _.attr("style", n.style), y.length === 0 && (y = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(r.recid) + " td:first-child")).length === 0 && (y = p(this.box).find("#grid_" + this.name + "_rec_top td:first-child")), A.length !== 0 && _.css("border-left", "0px"), r.recid != null) && o.recid != null && 0 < y.length && 0 < x.length ? (l = getComputedStyle(x[0]), h = y.prop("offsetTop") - y.prop("scrollTop"), d = y.prop("offsetLeft") + y.prop("scrollLeft"), c = x.prop("offsetTop") - x.prop("scrollTop"), a = x.prop("offsetLeft") + x.prop("scrollLeft"), _.show().css({ top: (0 < h ? h : 0) + "px", left: (0 < d ? d : 0) + "px", width: a - d + parseFloat(l.width) + 2 + "px", height: c - h + parseFloat(l.height) + 1 + "px" })) : _.hide());
      }
      p(this.box).find(".w2ui-selection-resizer").off(".resizer").on("mousedown.resizer", function(v) {
        var y = m.getSelection();
        m.last.move = { type: "expand", x: v.screenX, y: v.screenY, divX: 0, divY: 0, recid: y[0].recid, column: y[0].column, originalRange: [b.clone(y[0]), b.clone(y[y.length - 1])], newRange: [b.clone(y[0]), b.clone(y[y.length - 1])] }, p("body").off(".w2ui-" + m.name).on("mousemove.w2ui-" + m.name, u).on("mouseup.w2ui-" + m.name, f), v.preventDefault();
      }).on("dblclick.resizer", (v) => {
        v = this.trigger("resizerDblClick", { target: this.name, originalEvent: v }), v.isCancelled !== true && v.finish();
      });
      let g = { target: this.name, originalRange: null, newRange: null };
      return Date.now() - e;
    }
  }
  select() {
    if (arguments.length === 0) return 0;
    let e = 0;
    var t = this.last.selection;
    this.multiSelect || this.selectNone(true);
    let i = Array.from(arguments);
    Array.isArray(i[0]) && (i = i[0]);
    var n = { target: this.name }, n = (i.length == 1 ? (n.multiple = false, b.isPlainObject(i[0]) ? n.clicked = { recid: i[0].recid, column: i[0].column } : n.recid = i[0]) : (n.multiple = true, n.clicked = { recids: i }), this.trigger("select", n));
    if (n.isCancelled === true) return 0;
    if (this.selectType == "row") for (let v = 0; v < i.length; v++) {
      var r = typeof i[v] == "object" ? i[v].recid : i[v], o = this.get(r, true);
      if (o != null) {
        let y = null, x = null;
        (this.searchData.length !== 0 || o + 1 >= this.last.range_start && o + 1 <= this.last.range_end) && (y = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(r)), x = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(r))), this.selectType == "row" && t.indexes.indexOf(o) == -1 && (t.indexes.push(o), y && x && (y.addClass("w2ui-selected").find(".w2ui-col-number").addClass("w2ui-row-selected"), x.addClass("w2ui-selected").find(".w2ui-col-number").addClass("w2ui-row-selected"), y.find(".w2ui-grid-select-check").prop("checked", true)), e++);
      }
    }
    else {
      var a = {};
      for (let v = 0; v < i.length; v++) {
        var l = typeof i[v] == "object" ? i[v].recid : i[v], c = typeof i[v] == "object" ? i[v].column : null;
        if (a[l] = a[l] || [], Array.isArray(c)) a[l] = c;
        else if (b.isInt(c)) a[l].push(c);
        else for (let y = 0; y < this.columns.length; y++) this.columns[y].hidden || a[l].push(parseInt(y));
      }
      var h, d = [];
      for (h in a) {
        var u = this.get(h, true);
        if (u != null) {
          let v = null, y = null;
          u + 1 >= this.last.range_start && u + 1 <= this.last.range_end && (v = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(h)), y = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(h)));
          var f = t.columns[u] || [];
          t.indexes.indexOf(u) == -1 && t.indexes.push(u);
          for (let x = 0; x < a[h].length; x++) f.indexOf(a[h][x]) == -1 && f.push(a[h][x]);
          f.sort((x, S) => x - S);
          for (let x = 0; x < a[h].length; x++) {
            var m = a[h][x];
            d.indexOf(m) == -1 && d.push(m), v && (v.find("#grid_" + this.name + "_data_" + u + "_" + m).addClass("w2ui-selected"), v.find(".w2ui-col-number").addClass("w2ui-row-selected"), v.find(".w2ui-grid-select-check").prop("checked", true)), y && (y.find("#grid_" + this.name + "_data_" + u + "_" + m).addClass("w2ui-selected"), y.find(".w2ui-col-number").addClass("w2ui-row-selected"), y.find(".w2ui-grid-select-check").prop("checked", true)), e++;
          }
          t.columns[u] = f;
        }
      }
      for (let v = 0; v < d.length; v++) p(this.box).find("#grid_" + this.name + "_column_" + d[v] + " .w2ui-col-header").addClass("w2ui-col-selected");
    }
    t.indexes.sort((v, y) => v - y);
    var _ = 0 < this.records.length && t.indexes.length == this.records.length, g = 0 < t.indexes.length && this.searchData.length !== 0 && t.indexes.length == this.last.searchIds.length;
    return _ || g ? p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", true) : p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", false), this.status(), this.addRange("selection"), this.updateToolbar(t, _), n.finish(), e;
  }
  unselect() {
    let e = 0;
    var t = this.last.selection;
    let i = Array.from(arguments);
    Array.isArray(i[0]) && (i = i[0]);
    var n = { target: this.name }, n = (i.length == 1 ? (n.multiple = false, b.isPlainObject(i[0]) ? n.clicked = { recid: i[0].recid, column: i[0].column } : n.clicked = { recid: i[0] }) : (n.multiple = true, n.recids = i), this.trigger("select", n));
    if (n.isCancelled === true) return 0;
    for (let m = 0; m < i.length; m++) {
      var r = typeof i[m] == "object" ? i[m].recid : i[m], o = this.get(r);
      if (o != null) {
        var o = this.get(o.recid, true), a = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(r)), l = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(r));
        if (this.selectType == "row") t.indexes.indexOf(o) != -1 && (t.indexes.splice(t.indexes.indexOf(o), 1), a.removeClass("w2ui-selected w2ui-inactive").find(".w2ui-col-number").removeClass("w2ui-row-selected"), l.removeClass("w2ui-selected w2ui-inactive").find(".w2ui-col-number").removeClass("w2ui-row-selected"), a.length != 0 && (a[0].style.cssText = "height: " + this.recordHeight + "px; " + a.attr("custom_style"), l[0].style.cssText = "height: " + this.recordHeight + "px; " + l.attr("custom_style")), a.find(".w2ui-grid-select-check").prop("checked", false), e++);
        else {
          var c = i[m].column;
          if (!b.isInt(c)) {
            var h = [];
            for (let g = 0; g < this.columns.length; g++) this.columns[g].hidden || h.push({ recid: r, column: g });
            return this.unselect(h);
          }
          if (l = t.columns[o], Array.isArray(l) && l.indexOf(c) != -1) {
            l.splice(l.indexOf(c), 1), p(this.box).find(`#grid_${this.name}_rec_${b.escapeId(r)} > td[col="${c}"]`).removeClass("w2ui-selected w2ui-inactive"), p(this.box).find(`#grid_${this.name}_frec_${b.escapeId(r)} > td[col="${c}"]`).removeClass("w2ui-selected w2ui-inactive");
            let g = false, v = false;
            var d = this.getSelection();
            for (let y = 0; y < d.length; y++) d[y].column == c && (g = true), d[y].recid == r && (v = true);
            g || p(this.box).find(`.w2ui-grid-columns td[col="${c}"] .w2ui-col-header, .w2ui-grid-fcolumns td[col="${c}"] .w2ui-col-header`).removeClass("w2ui-col-selected"), v || p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(r)).find(".w2ui-col-number").removeClass("w2ui-row-selected"), e++, l.length === 0 && (delete t.columns[o], t.indexes.splice(t.indexes.indexOf(o), 1), a.find(".w2ui-grid-select-check").prop("checked", false));
          }
        }
      }
    }
    var u = 0 < this.records.length && t.indexes.length == this.records.length, f = 0 < t.indexes.length && this.searchData.length !== 0 && t.indexes.length == this.last.searchIds.length;
    return u || f ? p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", true) : p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", false), this.status(), this.addRange("selection"), this.updateToolbar(t, u), n.finish(), e;
  }
  selectAll() {
    var _a2;
    var e = Date.now();
    if (this.multiSelect !== false) {
      var t = ((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url;
      let n = b.clone(this.last.selection);
      var i = [];
      for (let r = 0; r < this.columns.length; r++) i.push(r);
      if (n.indexes = [], t || this.searchData.length === 0) {
        let r = this.records.length;
        this.searchData.length == 0 || t || (r = this.last.searchIds.length);
        for (let o = 0; o < r; o++) n.indexes.push(o), this.selectType != "row" && (n.columns[o] = i.slice());
      } else for (let r = 0; r < this.last.searchIds.length; r++) n.indexes.push(this.last.searchIds[r]), this.selectType != "row" && (n.columns[this.last.searchIds[r]] = i.slice());
      if (t = this.trigger("select", { target: this.name, multiple: true, all: true, clicked: n }), t.isCancelled !== true) return this.last.selection = n, this.selectType == "row" ? (p(this.box).find(".w2ui-grid-records tr:not(.w2ui-empty-record)").addClass("w2ui-selected").find(".w2ui-col-number").addClass("w2ui-row-selected"), p(this.box).find(".w2ui-grid-frecords tr:not(.w2ui-empty-record)").addClass("w2ui-selected").find(".w2ui-col-number").addClass("w2ui-row-selected")) : (p(this.box).find(".w2ui-grid-columns td .w2ui-col-header, .w2ui-grid-fcolumns td .w2ui-col-header").addClass("w2ui-col-selected"), p(this.box).find(".w2ui-grid-records tr .w2ui-col-number").addClass("w2ui-row-selected"), p(this.box).find(".w2ui-grid-records tr:not(.w2ui-empty-record)").find(".w2ui-grid-data:not(.w2ui-col-select)").addClass("w2ui-selected"), p(this.box).find(".w2ui-grid-frecords tr .w2ui-col-number").addClass("w2ui-row-selected"), p(this.box).find(".w2ui-grid-frecords tr:not(.w2ui-empty-record)").find(".w2ui-grid-data:not(.w2ui-col-select)").addClass("w2ui-selected")), p(this.box).find("input.w2ui-grid-select-check").prop("checked", true), n = this.getSelection(true), this.addRange("selection"), p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", true), this.status(), this.updateToolbar({ indexes: n }, true), t.finish(), Date.now() - e;
    }
  }
  selectNone(e) {
    var t, i = Date.now();
    let n;
    if (e || (n = this.trigger("select", { target: this.name, clicked: [] })).isCancelled !== true) return t = this.last.selection, this.selectType == "row" ? (p(this.box).find(".w2ui-grid-records tr.w2ui-selected").removeClass("w2ui-selected w2ui-inactive").find(".w2ui-col-number").removeClass("w2ui-row-selected"), p(this.box).find(".w2ui-grid-frecords tr.w2ui-selected").removeClass("w2ui-selected w2ui-inactive").find(".w2ui-col-number").removeClass("w2ui-row-selected")) : (p(this.box).find(".w2ui-grid-columns td .w2ui-col-header, .w2ui-grid-fcolumns td .w2ui-col-header").removeClass("w2ui-col-selected"), p(this.box).find(".w2ui-grid-records tr .w2ui-col-number").removeClass("w2ui-row-selected"), p(this.box).find(".w2ui-grid-frecords tr .w2ui-col-number").removeClass("w2ui-row-selected"), p(this.box).find(".w2ui-grid-data.w2ui-selected").removeClass("w2ui-selected w2ui-inactive")), p(this.box).find("input.w2ui-grid-select-check").prop("checked", false), t.indexes = [], t.columns = {}, this.removeRange("selection"), p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", false), this.status(), this.updateToolbar(t, false), e || n.finish(), Date.now() - i;
  }
  updateToolbar(e) {
    let t = this, i = e && e.indexes ? e.indexes.length : 0;
    function n(r, o) {
      if (r.batch != null) {
        let a = false;
        r.batch === true ? 0 < i && (a = true) : typeof r.batch == "number" ? i === r.batch && (a = true) : typeof r.batch == "function" && (a = r.batch({ cnt: i, sel: e })), a ? t.toolbar.enable(o + r.id) : t.toolbar.disable(o + r.id);
      }
    }
    this.toolbar.items.forEach((r) => {
      n(r, ""), Array.isArray(r.items) && r.items.forEach((o) => {
        n(o, r.id + ":");
      });
    }), this.show.toolbarSave && (0 < this.getChanges().length ? this.toolbar.enable("w2ui-save") : this.toolbar.disable("w2ui-save"));
  }
  getSelection(e) {
    var t = [], i = this.last.selection;
    if (this.selectType == "row") for (let r = 0; r < i.indexes.length; r++) this.records[i.indexes[r]] && t.push(e === true ? i.indexes[r] : this.records[i.indexes[r]].recid);
    else for (let r = 0; r < i.indexes.length; r++) {
      var n = i.columns[i.indexes[r]];
      if (this.records[i.indexes[r]]) for (let o = 0; o < n.length; o++) t.push({ recid: this.records[i.indexes[r]].recid, index: parseInt(i.indexes[r]), column: n[o] });
    }
    return t;
  }
  search(e, t) {
    var _a2;
    var i = ((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url, n = [];
    let r = this.last.multi, o = this.last.logic, a = this.last.field, l = this.last.search, c = false;
    var h = p(`#w2overlay-${this.name}-search-overlay`);
    for (let w = 0; w < this.searches.length; w++) this.searches[w].hidden && this.searches[w].value != null && (n.push({ field: this.searches[w].field, operator: this.searches[w].operator || "is", type: this.searches[w].type, value: this.searches[w].value || "" }), c = true);
    if (arguments.length === 0 && h.length === 0 && (t = this.multiSearch ? (e = this.searchData, this.last.logic) : (e = this.last.field, this.last.search)), arguments.length === 0 && h.length !== 0) {
      this.focus(), o = h.find(`#grid_${this.name}_logic`).val(), l = "";
      for (let w = 0; w < this.searches.length; w++) {
        var d = this.searches[w], u = h.find("#grid_" + this.name + "_operator_" + w).val(), f = h.find("#grid_" + this.name + "_field_" + w), m = h.find("#grid_" + this.name + "_field2_" + w);
        let E = f.val(), N = m.val(), k = null, V = null;
        if (["int", "float", "money", "currency", "percent"].indexOf(d.type) != -1 && (_ = f[0]._w2field, m = m[0]._w2field, _ && (E = _.clean(E)), m) && (N = m.clean(N)), ["list", "enum"].indexOf(d.type) != -1 || ["in", "not in"].indexOf(u) != -1) if (E = f[0]._w2field.selected || {}, Array.isArray(E)) {
          k = [];
          for (let q = 0; q < E.length; q++) k.push(b.isFloat(E[q].id) ? parseFloat(E[q].id) : String(E[q].id).toLowerCase()), delete E[q].hidden;
          Object.keys(E).length === 0 && (E = "");
        } else V = E.text || "", E = E.id || "";
        if (E !== "" && E != null || N != null && N !== "") {
          var _ = { field: d.field, type: d.type, operator: u };
          u == "between" ? b.extend(_, { value: [E, N] }) : u == "in" && typeof E == "string" || u == "not in" && typeof E == "string" ? b.extend(_, { value: E.split(",") }) : b.extend(_, { value: E }), k && b.extend(_, { svalue: k }), V && b.extend(_, { text: V });
          try {
            d.type == "date" && u == "between" && (_.value[0] = E, _.value[1] = N), d.type == "date" && u == "is" && (_.value = E);
          } catch {
          }
          n.push(_), r = true;
        }
      }
    }
    if (typeof e == "string" && (arguments.length == 1 && (t = e, e = "all"), a = e, l = t, r = false, o = c ? "AND" : "OR", t != null)) if (e.toLowerCase() == "all") if (0 < this.searches.length) for (let w = 0; w < this.searches.length; w++) {
      var g, v = this.searches[w];
      if ((v.type == "text" || v.type == "alphanumeric" && b.isAlphaNumeric(t) || v.type == "int" && b.isInt(t) || v.type == "float" && b.isFloat(t) || v.type == "percent" && b.isFloat(t) || (v.type == "hex" || v.type == "color") && b.isHex(t) || v.type == "currency" && b.isMoney(t) || v.type == "money" && b.isMoney(t) || v.type == "date" && b.isDate(t) || v.type == "time" && b.isTime(t) || v.type == "datetime" && b.isDateTime(t) || v.type == "datetime" && b.isDate(t) || v.type == "enum" && b.isAlphaNumeric(t) || v.type == "list" && b.isAlphaNumeric(t)) && (g = this.defaultOperator[this.operatorsMap[v.type]], g = { field: v.field, type: v.type, operator: v.operator != null ? v.operator : g, value: t }, String(t).trim() != "") && n.push(g), ["int", "float", "money", "currency", "percent"].indexOf(v.type) != -1 && String(t).trim().split("-").length == 2 && (g = String(t).trim().split("-"), y = { field: v.field, type: v.type, operator: v.operator != null ? v.operator : "between", value: [g[0], g[1]] }, n.push(y)), ["list", "enum"].indexOf(v.type) != -1) {
        var y, x = [];
        v.options == null && (v.options = {}), Array.isArray(v.options.items) || (v.options.items = []);
        for (let E = 0; E < v.options.items; E++) {
          var S = v.options.items[E];
          try {
            var A = new RegExp(t, "i");
            A.test(S) && x.push(E), S.text && A.test(S.text) && x.push(S.id);
          } catch {
          }
        }
        0 < x.length && (y = { field: v.field, type: v.type, operator: v.operator != null ? v.operator : "in", value: x }, n.push(y));
      }
    }
    else for (let w = 0; w < this.columns.length; w++) {
      var R = { field: this.columns[w].field, type: "text", operator: this.defaultOperator.text, value: t };
      n.push(R);
    }
    else {
      var C = h.find("#grid_" + this.name + "_search_all");
      let w = this.getSearch(e);
      if ((w = w ?? { field: e, type: "text" }).field == e && (this.last.label = w.label), t !== "") {
        let E = this.defaultOperator[this.operatorsMap[w.type]], N = t;
        if (["date", "time", "datetime"].indexOf(w.type) != -1 && (E = "is"), ["list", "enum"].indexOf(w.type) != -1 && (E = "is", C = C._w2field.get(), N = C && 0 < Object.keys(C).length ? C.id : ""), w.type == "int" && t !== "" && (E = "is", String(t).indexOf("-") != -1 && (C = t.split("-")).length == 2 && (E = "between", N = [parseInt(C[0]), parseInt(C[1])]), String(t).indexOf(",") != -1)) {
          var P = t.split(",");
          E = "in", N = [];
          for (let k = 0; k < P.length; k++) N.push(P[k]);
        }
        w.operator != null && (E = w.operator), C = { field: w.field, type: w.type, operator: E, value: N }, n.push(C);
      }
    }
    if (Array.isArray(e)) {
      let w = "AND";
      typeof t == "string" && (w = t.toUpperCase()) != "OR" && w != "AND" && (w = "AND"), l = "", r = true, o = w;
      for (let E = 0; E < e.length; E++) {
        var z = e[E];
        typeof z.value == "number" && z.operator == null && (z.operator = this.defaultOperator.number), typeof z.value == "string" && z.operator == null && (z.operator = this.defaultOperator.text), Array.isArray(z.value) && z.operator == null && (z.operator = this.defaultOperator.enum), b.isDate(z.value) && z.operator == null && (z.operator = this.defaultOperator.date), n.push(z);
      }
    }
    C = this.trigger("search", { target: this.name, multi: arguments.length === 0, searchField: e || "multi", searchValue: e ? t : "multi", searchData: n, searchLogic: o }), C.isCancelled !== true && (this.searchData = C.detail.searchData, this.last.field = a, this.last.search = l, this.last.multi = r, this.last.logic = C.detail.searchLogic, this.last.scrollTop = 0, this.last.scrollLeft = 0, this.last.selection.indexes = [], this.last.selection.columns = {}, this.searchClose(), i ? (this.last.fetch.offset = 0, this.reload()) : (this.localSearch(), this.refresh()), C.finish());
  }
  searchOpen() {
    if (this.box && this.searches.length !== 0) {
      let e = this.trigger("searchOpen", { target: this.name });
      if (e.isCancelled !== true) {
        let t = p(this.toolbar.box).find(".w2ui-grid-search-input .w2ui-search-drop");
        t.addClass("checked"), Ge.show({ name: this.name + "-search-overlay", anchor: p(this.box).find("#grid_" + this.name + "_search_all").get(0), position: "bottom|top", html: this.getSearchesHTML(), align: "left", arrowSize: 12, class: "w2ui-grid-search-advanced", hideOn: ["doc-click"] }).then((i) => {
          this.initSearches(), this.last.search_opened = true;
          let n = p(`#w2overlay-${this.name}-search-overlay`);
          n.data("gridName", this.name).off(".grid-search").on("click.grid-search", () => {
            n.find("input, select").each((o) => {
              o = p(o).data("tooltipName"), o && o.forEach((a) => {
                Ge.hide(a);
              });
            });
          }), b.bindEvents(n.find("select, input, button"), this);
          var r = p(`#w2overlay-${this.name}-search-overlay *[rel=search]`);
          0 < r.length && r[0].focus(), e.finish();
        }).hide((i) => {
          t.removeClass("checked"), this.last.search_opened = false;
        });
      }
    }
  }
  searchClose() {
    Ge.hide(this.name + "-search-overlay");
  }
  searchFieldTooltip(n, t, i) {
    var n = this.searches[n], r = this.searchData[t];
    let o = r.operator, a = ((o = o == "more" && r.type == "date" ? "since" : o) == "less" && r.type == "date" && (o = "before"), ""), l = r.value;
    Array.isArray(r.value) ? (r.value.forEach((c) => {
      a += `<span class="value">${c.text || c}</span>`;
    }), r.type == "date" && (a = "", r.value.forEach((c) => {
      a += `<span class="value">${b.formatDate(c)}</span>`;
    }))) : r.type == "date" && (l = b.formatDateTime(l)), Ge.hide(this.name + "-search-props"), Ge.show({ name: this.name + "-search-props", anchor: i, class: "w2ui-white", hideOn: "doc-click", html: `
                <div class="w2ui-grid-search-single">
                    <span class="field">${n.label}</span>
                    <span class="operator">${b.lang(o)}</span>
                    ${Array.isArray(r.value) ? "" + a : `<span class="value">${l}</span>`}
                    <div class="buttons">
                        <button id="remove" class="w2ui-btn">${b.lang("Remove This Field")}</button>
                    </div>
                </div>` }).then((c) => {
      p(c.detail.overlay.box).find("#remove").on("click", () => {
        this.searchData.splice("" + t, 1), this.reload(), this.localSearch(), Ge.hide(this.name + "-search-props");
      });
    });
  }
  searchSuggest(e, t, i) {
    var _a2, _b2;
    clearTimeout(this.last.kbd_timer), clearTimeout(this.last.overlay_timer), this.searchShowFields(true), this.searchClose(), t === true ? Ge.hide(this.name + "-search-suggest") : 0 < p(`#w2overlay-${this.name}-search-suggest`).length || (e ? (t = p(this.box).find(`#grid_${this.name}_search_all`).get(0), e = [...this.defaultSearches ?? [], ...0 < ((_a2 = this.defaultSearches) == null ? void 0 : _a2.length) && 0 < ((_b2 = this.savedSearches) == null ? void 0 : _b2.length) ? ["--"] : [], ...this.savedSearches ?? []], Array.isArray(e) && 0 < e.length && Ot.show({ name: this.name + "-search-suggest", anchor: t, align: "both", items: e, hideOn: ["doc-click", "sleect", "remove"], render(n) {
      let r = n.text;
      return r = n.isDefault ? `<b>${r}</b>` : r;
    } }).select((n) => {
      var r = this.trigger("searchSelect", { target: this.name, index: n.detail.index, item: n.detail.item });
      r.isCancelled === true ? n.preventDefault() : (n.detail.overlay.hide(), this.last.logic = n.detail.item.logic || "AND", this.last.search = "", this.last.label = "[Multiple Fields]", this.searchData = b.clone(n.detail.item.data), this.searchSelected = b.clone(n.detail.item, { exclude: ["icon", "remove"] }), this.reload(), r.finish());
    }).remove((n) => {
      let r = n.detail.item, o = this.trigger("searchRemove", { target: this.name, index: n.detail.index, item: r });
      o.isCancelled === true ? n.preventDefault() : (n.detail.overlay.hide(), this.confirm(b.lang('Do you want to delete search "${item}"?', { item: r.text })).yes((a) => {
        var l = this.savedSearches.findIndex((c) => c.id == r.id);
        l !== -1 && this.savedSearches.splice(l, 1), this.cacheSave("searches", this.savedSearches.map((c) => b.clone(c, { exclude: ["remove", "icon"] }))), a.detail.self.close(), o.finish();
      }).no((a) => {
        a.detail.self.close();
      }));
    })) : this.last.overlay_timer = setTimeout(() => {
      this.searchSuggest(true);
    }, 100));
  }
  searchSave() {
    let e = "", t = (this.searchSelected && (e = this.searchSelected.text), this.savedSearches.findIndex((n) => {
      var _a2;
      return n.id == ((_a2 = this.searchSelected) == null ? void 0 : _a2.id);
    })), i = this.trigger("searchSave", { target: this.name, saveLocalStorage: true });
    i.isCancelled !== true && this.message({ width: 350, height: 150, body: `<div class="w2ui-grid-save-search">
                        <span>${b.lang(t != -1 ? "Update Search" : "Save New Search")}</span>
                        <input class="search-name w2ui-input" placeholder="${b.lang("Search name")}">
                   </div>`, buttons: `
                <button id="grid-search-cancel" class="w2ui-btn">${b.lang("Cancel")}</button>
                <button id="grid-search-save" class="w2ui-btn w2ui-btn-blue" ${String(e).trim() == "" ? "disabled" : ""}>${b.lang("Save")}</button>
            ` }).open(async (n) => {
      p(n.detail.box).find("input, button").eq(0).val(e), await n.complete, p(n.detail.box).find("#grid-search-cancel").on("click", () => {
        this.message();
      }), p(n.detail.box).find("#grid-search-save").on("click", () => {
        var r = p(n.detail.box).find(".w2ui-message .search-name").val();
        this.searchSelected && t != -1 ? Object.assign(this.savedSearches[t], { id: r, text: r, logic: this.last.logic, data: b.clone(this.searchData) }) : this.savedSearches.push({ id: r, text: r, icon: "w2ui-icon-search", remove: true, logic: this.last.logic, data: this.searchData }), this.cacheSave("searches", this.savedSearches.map((o) => b.clone(o, { exclude: ["remove", "icon"] }))), this.message(), (this.searchSelected ? (this.searchSelected.text = r, p(this.box).find(`#grid_${this.name}_search_name .name-text`)) : (this.searchSelected = { text: r, logic: this.last.logic, data: b.clone(this.searchData) }, p(n.detail.box).find(`#grid_${this.name}_search_all`).val(" ").prop("readOnly", true), p(n.detail.box).find(`#grid_${this.name}_search_name`).show().find(".name-text"))).html(r), i.finish({ name: r });
      }), p(n.detail.box).find("input, button").off(".message").on("keydown.message", (r) => {
        var o = String(p(n.detail.box).find(".w2ui-message-body input").val()).trim();
        r.keyCode == 13 && o != "" && p(n.detail.box).find("#grid-search-save").trigger("click"), r.keyCode == 27 && this.message();
      }).eq(0).on("input.message", (r) => {
        var o = p(n.detail.box).closest(".w2ui-message").find("#grid-search-save");
        String(p(n.detail.box).val()).trim() === "" ? o.prop("disabled", true) : o.prop("disabled", false);
      }).get(0).focus();
    });
  }
  cache(e) {
    var _a2;
    if (b.hasLocalStorage && this.useLocalStorage) try {
      var t = JSON.parse(localStorage.w2ui || "{}");
      return t[_a2 = this.stateId || this.name] ?? (t[_a2] = {}), t[this.stateId || this.name][e];
    } catch {
    }
    return null;
  }
  cacheSave(e, t) {
    var _a2;
    if (b.hasLocalStorage && this.useLocalStorage) try {
      var i = JSON.parse(localStorage.w2ui || "{}");
      return i[_a2 = this.stateId || this.name] ?? (i[_a2] = {}), i[this.stateId || this.name][e] = t, localStorage.w2ui = JSON.stringify(i), true;
    } catch {
      delete localStorage.w2ui;
    }
    return false;
  }
  searchReset(e) {
    var t = [];
    let i = false;
    for (let o = 0; o < this.searches.length; o++) this.searches[o].hidden && this.searches[o].value != null && (t.push({ field: this.searches[o].field, operator: this.searches[o].operator || "is", type: this.searches[o].type, value: this.searches[o].value || "" }), i = true);
    var n = this.trigger("search", { reset: true, target: this.name, searchData: t });
    if (n.isCancelled !== true) {
      var r = p(this.box).find("#grid_" + this.name + "_search_all");
      if (this.searchData = n.detail.searchData, this.searchSelected = null, this.last.search = "", this.last.logic = i ? "AND" : "OR", r.next().hide(), 0 < this.searches.length) if (this.multiSearch && this.show.searchAll) this.last.field = "all", this.last.label = "All Fields", r.next().show();
      else {
        let o = 0;
        for (; o < this.searches.length && (this.searches[o].hidden || this.searches[o].simple === false); ) o++;
        o >= this.searches.length ? (this.last.field = "", this.last.label = "") : (this.last.field = this.searches[o].field, this.last.label = this.searches[o].label);
      }
      this.last.multi = false, this.last.fetch.offset = 0, this.last.scrollTop = 0, this.last.scrollLeft = 0, this.last.selection.indexes = [], this.last.selection.columns = {}, this.searchClose(), r = r.val("").get(0), (r == null ? void 0 : r._w2field) && r._w2field.reset(), e || this.reload(), n.finish();
    }
  }
  searchShowFields(e) {
    if (e === true) Ge.hide(this.name + "-search-fields");
    else {
      var t = [];
      for (let n = -1; n < this.searches.length; n++) {
        let r = this.searches[n];
        var i = r ? r.field : null, i = this.getColumn(i);
        let o = false, a = null;
        if (this.show.searchHiddenMsg == 1 && n != -1 && (i == null || i.hidden === true && i.hideable !== false) && (o = true, a = b.lang("This column " + (i == null ? "does not exist" : "is hidden"))), n == -1) {
          if (!this.multiSearch || !this.show.searchAll) continue;
          r = { field: "all", label: "All Fields" };
        } else if (i != null && i.hideable === false || r.hidden === true && (a = b.lang("This column is hidden"), r.simple === false)) continue;
        r.label == null && r.caption != null && (console.log("NOTICE: grid search.caption property is deprecated, please use search.label. Search ->", r), r.label = r.caption), t.push({ id: r.field, text: b.lang(r.label), search: r, tooltip: a, disabled: o, checked: r.field == this.last.field });
      }
      Ot.show({ type: "radio", name: this.name + "-search-fields", anchor: p(this.box).find("#grid_" + this.name + "_search_name").parent().find(".w2ui-search-down").get(0), items: t, align: "none", hideOn: ["doc-click", "select"] }).select((n) => {
        this.searchInitInput(n.detail.item.search.field);
      });
    }
  }
  searchInitInput(e, t) {
    let i;
    var n = p(this.box).find("#grid_" + this.name + "_search_all");
    if (e == "all") i = { field: "all", label: b.lang("All Fields") };
    else if ((i = this.getSearch(e)) == null) return;
    this.last.search != "" ? (this.last.label = i.label, this.search(i.field, this.last.search)) : (this.last.field = i.field, this.last.label = i.label), n.attr("placeholder", b.lang("Search") + " " + b.lang(i.label || i.caption || i.field, true));
  }
  clear(e) {
    this.total = 0, this.records = [], this.summary = [], this.last.fetch.offset = 0, this.last.idCache = {}, this.last.selection = { indexes: [], columns: {} }, this.reset(true), e || this.refresh();
  }
  reset(e) {
    this.last.scrollTop = 0, this.last.scrollLeft = 0, this.last.range_start = null, this.last.range_end = null, p(this.box).find(`#grid_${this.name}_records`).prop("scrollTop", 0), e || this.refresh();
  }
  skip(e, t) {
    var _a2;
    ((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url ? (this.offset = parseInt(e), this.offset > this.total && (this.offset = this.total - this.limit), (this.offset < 0 || !b.isInt(this.offset)) && (this.offset = 0), this.clear(true), this.reload(t)) : console.log("ERROR: grid.skip() can only be called when you have remote data source.");
  }
  load(e, t) {
    return e == null ? (console.log('ERROR: You need to provide url argument when calling .load() method of "' + this.name + '" object.'), new Promise((i, n) => {
      n();
    })) : (this.clear(true), this.request("load", {}, e, t));
  }
  reload(e) {
    var _a2;
    let t = this;
    var i = ((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url;
    return t.selectionSave(), i ? this.load(i, () => {
      t.selectionRestore(), typeof e == "function" && e();
    }) : (this.reset(true), this.localSearch(), this.selectionRestore(), typeof e == "function" && e({ status: "success" }), new Promise((n) => {
      n();
    }));
  }
  request(e, t, i, n) {
    let r = this, o, a;
    var l = new Promise((f, m) => {
      o = f, a = m;
    });
    if (t == null && (t = {}), !(i = i || this.url)) return new Promise((f, m) => {
      m();
    });
    b.isInt(this.offset) || (this.offset = 0), b.isInt(this.last.fetch.offset) || (this.last.fetch.offset = 0);
    let c;
    var h = { limit: this.limit, offset: parseInt(this.offset) + parseInt(this.last.fetch.offset), searchLogic: this.last.logic, search: this.searchData.map((f) => (f = b.clone(f), this.searchMap && this.searchMap[f.field] && (f.field = this.searchMap[f.field]), f)), sort: this.sortData.map((f) => (f = b.clone(f), this.sortMap && this.sortMap[f.field] && (f.field = this.sortMap[f.field]), f)) };
    if (this.searchData.length === 0 && (delete h.search, delete h.searchLogic), this.sortData.length === 0 && delete h.sort, b.extend(h, this.postData), b.extend(h, t), e != "delete" && e != "save" || (delete h.limit, delete h.offset, (h.action = e) == "delete" && (h[this.recid || "recid"] = this.getSelection())), e == "load") {
      if ((c = this.trigger("request", { target: this.name, url: i, postData: h, httpMethod: "GET", httpHeaders: this.httpHeaders })).isCancelled === true) return new Promise((f, m) => {
        m();
      });
    } else c = { detail: { url: i, postData: h, httpMethod: e == "save" ? "PUT" : "DELETE", httpHeaders: this.httpHeaders } };
    if (this.last.fetch.offset === 0 && this.lock(b.lang(this.msgRefresh), true), this.last.fetch.controller) try {
      this.last.fetch.controller.abort();
    } catch {
    }
    switch (i = c.detail.url, e) {
      case "save":
        (i == null ? void 0 : i.save) && (i = i.save);
        break;
      case "delete":
        (i == null ? void 0 : i.remove) && (i = i.remove);
        break;
      default:
        i = (i == null ? void 0 : i.get) ?? i;
    }
    if (0 < Object.keys(this.routeData).length) {
      var d = b.parseRoute(i);
      if (0 < d.keys.length) for (let f = 0; f < d.keys.length; f++) this.routeData[d.keys[f].name] != null && (i = i.replace(new RegExp(":" + d.keys[f].name, "g"), this.routeData[d.keys[f].name]));
    }
    return i = new URL(i, location), t = b.prepareParams(i, { method: c.detail.httpMethod, headers: c.detail.httpHeaders, body: c.detail.postData }, this.dataType), Object.assign(this.last.fetch, { action: e, options: t, controller: new AbortController(), start: Date.now(), loaded: false }), t.signal = this.last.fetch.controller.signal, fetch(i, t).catch(u).then((f) => {
      f != null && ((f == null ? void 0 : f.status) != 200 ? u(f ?? {}) : (r.unlock(), f.json().catch(u).then((m) => {
        this.requestComplete(m, e, n, o, a);
      })));
    }), e == "load" && c.finish(), l;
    function u(f) {
      var m;
      (f == null ? void 0 : f.name) !== "AbortError" && (r.unlock(), (m = r.trigger("error", { response: f, lastFetch: r.last.fetch })).isCancelled !== true) && (f.status && f.status != 200 ? r.error(f.status + ": " + f.statusText) : (console.log("ERROR: Server communication failed.", `
   EXPECTED:`, { total: 5, records: [{ recid: 1, field: "value" }] }, `
         OR:`, { error: true, message: "error message" }), r.requestComplete({ error: true, message: b.lang(this.msgHTTPError), response: f }, e, n, o, a)), m.finish());
    }
  }
  requestComplete(e, t, i, n, r) {
    var _a2;
    let o = e.error ?? false, a = (e.error == null && e.status === "error" && (o = true), this.last.fetch.response = (Date.now() - this.last.fetch.start) / 1e3, setTimeout(() => {
      this.show.statusResponse && this.status(b.lang("Server Response ${count} seconds", { count: this.last.fetch.response }));
    }, 10), this.last.pull_more = false, this.last.pull_refresh = true, "load");
    this.last.fetch.action == "save" && (a = "save"), this.last.fetch.action == "delete" && (a = "delete");
    var l = this.trigger(a, { target: this.name, error: o, data: e, lastFetch: this.last.fetch });
    if (l.isCancelled === true) r();
    else {
      if (o) this.error(b.lang(e.message ?? this.msgServerError)), r(e);
      else if (typeof this.parser == "function" ? typeof (e = this.parser(e)) != "object" && console.log("ERROR: Your parser did not return proper object") : e == null ? e = { error: true, message: b.lang(this.msgNotJSON) } : Array.isArray(e) && (e = { error: o, records: e, total: e.length }), t == "load") {
        if (e.total == null && (e.total = -1), e.records == null && (e.records = []), e.records.length == this.limit ? (r = this.records.length + e.records.length, this.last.fetch.hasMore = r != this.total) : (this.last.fetch.hasMore = false, this.total = this.offset + this.last.fetch.offset + e.records.length), this.last.fetch.hasMore || p(this.box).find("#grid_" + this.name + "_rec_more, #grid_" + this.name + "_frec_more").hide(), this.last.fetch.offset === 0) this.records = [], this.summary = [];
        else if (e.total != -1 && parseInt(e.total) != parseInt(this.total)) {
          let c = this;
          return this.message(b.lang(this.msgNeedReload)).ok(() => {
            delete c.last.fetch.offset, c.reload();
          }), new Promise((h) => {
            h();
          });
        }
        b.isInt(e.total) && (this.total = parseInt(e.total)), e.records && e.records.forEach((c) => {
          var _a3;
          this.recid && (c.recid = this.parseField(c, this.recid)), c.recid == null && (c.recid = "recid-" + this.records.length), (((_a3 = c.w2ui) == null ? void 0 : _a3.summary) === true ? this.summary : this.records).push(c);
        }), e.summary && (this.summary = [], e.summary.forEach((c) => {
          this.recid && (c.recid = this.parseField(c, this.recid)), c.recid == null && (c.recid = "recid-" + this.summary.length), this.summary.push(c);
        }));
      } else if (t == "delete") return this.reset(), this.reload();
      (((_a2 = this.url) == null ? void 0 : _a2.get) ?? this.url) || (this.localSort(), this.localSearch()), this.total = parseInt(this.total), this.last.fetch.offset === 0 ? this.refresh() : (this.scroll(), this.resize()), typeof i == "function" && i(e), n(e), l.finish(), this.last.fetch.loaded = true;
    }
  }
  error(e) {
    var t = this.trigger("error", { target: this.name, message: e });
    t.isCancelled !== true && (this.message(e), t.finish());
  }
  getChanges(e) {
    var t = [];
    e === void 0 && (e = this.records);
    for (let r = 0; r < e.length; r++) {
      var i, n = e[r];
      (n == null ? void 0 : n.w2ui) && (n.w2ui.changes != null && ((i = {})[this.recid || "recid"] = n.recid, t.push(b.extend(i, n.w2ui.changes))), n.w2ui.expanded !== true) && n.w2ui.children && n.w2ui.children.length && t.push(...this.getChanges(n.w2ui.children));
    }
    return t;
  }
  mergeChanges() {
    var e = this.getChanges();
    for (let n = 0; n < e.length; n++) {
      var t, i = this.get(e[n][this.recid || "recid"]);
      for (t in e[n]) if (!(t == "recid" || this.recid && t == this.recid)) {
        typeof e[n][t] == "object" && (e[n][t] = e[n][t].text);
        try {
          (function r(o, a, l) {
            let c = a.split(".");
            c.length == 1 ? o[a] = l : (o = o[c[0]], c.shift(), r(o, c.join("."), l));
          })(i, t, e[n][t]);
        } catch (r) {
          console.log("ERROR: Cannot merge. ", r.message || "", r);
        }
        i.w2ui && delete i.w2ui.changes;
      }
    }
    this.refresh();
  }
  save(e) {
    var _a2;
    var t = this.getChanges(), i = ((_a2 = this.url) == null ? void 0 : _a2.save) ?? this.url;
    let n = this.trigger("save", { target: this.name, changes: t });
    n.isCancelled !== true && (i ? this.request("save", { changes: n.detail.changes }, null, (r) => {
      r.error || this.mergeChanges(), n.finish(), typeof e == "function" && e(r);
    }) : (this.mergeChanges(), n.finish()));
  }
  editField(e, t, i, n) {
    var _a2, _b2;
    let r = this;
    if (this.last.inEditMode === true) n && n.keyCode == 13 ? ({ index: o, column: a, value: l } = this.last._edit, this.editChange({ type: "custom", value: l }, o, a, n), this.editDone(o, a, n)) : 0 < (l = p(this.box).find("div.w2ui-edit-box .w2ui-input")).length && (l.get(0).tagName == "DIV" ? (l.text(l.text() + i), b.setCursorPosition(l.get(0), l.text().length)) : (l.val(l.val() + i), b.setCursorPosition(l.get(0), l.val().length)));
    else {
      let c = this.get(e, true), h = this.getCellEditable(c, t);
      if (h && !["checkbox", "check"].includes(h.type)) {
        let d = this.records[c], u = this.columns[t];
        var o = u.frozen === true ? "_f" : "_";
        if (["enum", "file"].indexOf(h.type) != -1) console.log('ERROR: input types "enum" and "file" are not supported in inline editing.');
        else {
          var a = this.trigger("editField", { target: this.name, recid: e, column: t, value: i, index: c, originalEvent: n });
          if (a.isCancelled !== true) {
            let f = function(S) {
              try {
                var A = getComputedStyle(S), R = S.tagName.toUpperCase() == "DIV" ? S.innerText : S.value, C = p(r.box).find("#grid_" + r.name + "_editable").get(0), P = `font-family: ${A["font-family"]}; font-size: ${A["font-size"]}; white-space: no-wrap;`, z = b.getStrWidth(R, P);
                z + 20 > C.clientWidth && p(C).css("width", z + 20 + "px");
              } catch {
              }
            };
            i = a.detail.value, this.last.inEditMode = true, this.last.editColumn = t, this.last._edit = { value: i, index: c, column: t, recid: e }, this.selectNone(true), this.select({ recid: e, column: t });
            var l = p(this.box).find("#grid_" + this.name + o + "rec_" + b.escapeId(e));
            let m = l.find('[col="' + t + '"] > div'), _ = (this.last._edit.tr = l, this.last._edit.div = m, p(this.box).find("div.w2ui-edit-box").remove(), this.selectType != "row" && (p(this.box).find("#grid_" + this.name + o + "selection").attr("id", "grid_" + this.name + "_editable").removeClass("w2ui-selection").addClass("w2ui-edit-box").prepend('<div style="position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px;"></div>').find(".w2ui-selection-resizer").remove(), m = p(this.box).find("#grid_" + this.name + "_editable > div:first-child")), h.attr = h.attr ?? "", h.text = h.text ?? "", h.style = h.style ?? "", h.items = h.items ?? [], ((_b2 = (_a2 = d.w2ui) == null ? void 0 : _a2.changes) == null ? void 0 : _b2[u.field]) != null ? b.stripTags(d.w2ui.changes[u.field]) : b.stripTags(r.parseField(d, u.field))), g = typeof (_ = _ ?? "") != "object" ? _ : "", v = (a.detail.prevValue != null && (g = a.detail.prevValue), i != null && (_ = i), u.style != null ? u.style + ";" : "");
            typeof u.render == "string" && ["number", "int", "float", "money", "percent", "size"].includes(u.render.split(":")[0]) && (v += "text-align: right;"), 0 < h.items.length && !b.isPlainObject(h.items[0]) && (h.items = b.normMenu(h.items));
            let y, x = ["date", "time", "datetime", "color", "list", "combo"];
            n = getComputedStyle(l.find('[col="' + t + '"] > div').get(0)), o = `font-family: ${n["font-family"]}; font-size: ${n["font-size"]};`, h.type === "div" ? (m.addClass("w2ui-editable").html(b.stripSpaces(`<div id="grid_${this.name}_edit_${e}_${t}" class="w2ui-input w2ui-focus"
                        contenteditable autocorrect="off" autocomplete="off" spellcheck="false"
                        style="${o + v + h.style}"
                        field="${u.field}" recid="${e}" column="${t}" ${h.attr}>
                    </div>` + h.text)), (y = m.find("div.w2ui-input").get(0)).innerText = typeof _ != "object" ? _ : "", i != null ? b.setCursorPosition(y, y.innerText.length) : b.setCursorPosition(y, 0, y.innerText.length)) : (m.addClass("w2ui-editable").html(b.stripSpaces(`<input id="grid_${this.name}_edit_${e}_${t}" class="w2ui-input"
                        autocorrect="off" autocomplete="off" spellcheck="false" type="text"
                        style="${o + v + h.style}"
                        field="${u.field}" recid="${e}" column="${t}" ${h.attr}>` + h.text)), y = m.find("input").get(0), h.type == "number" && (_ = b.formatNumber(_)), h.type == "date" && (_ = b.formatDate(b.isDate(_, h.format, true) || /* @__PURE__ */ new Date(), h.format)), y.value = typeof _ != "object" ? _ : "", l = (S) => {
              var _a3, _b3, _c2, _d2;
              var A = (_a3 = this.last._edit) == null ? void 0 : _a3.escKey;
              let R = false;
              var C = p(y).data("tooltipName");
              C && ((_b3 = Ge.get(C[0])) == null ? void 0 : _b3.selected) != null && (R = true), !this.last.inEditMode || A || !x.includes(h.type) || ((_c2 = S.detail.overlay.anchor) == null ? void 0 : _c2.id) != ((_d2 = this.last._edit.input) == null ? void 0 : _d2.id) && h.type != "list" || (this.editChange(), this.editDone(void 0, void 0, { keyCode: R ? 13 : 0 }));
            }, new Eo(b.extend({}, h, { el: y, selected: _, onSelect: l, onHide: l })), i == null && y && y.select()), Object.assign(this.last._edit, { input: y, edit: h }), p(y).off(".w2ui-editable").on("blur.w2ui-editable", (S) => {
              var A, R;
              this.last.inEditMode && (A = this.last._edit.edit.type, R = p(y).data("tooltipName"), x.includes(A) && R || (this.editChange(y, c, t, S), this.editDone()));
            }).on("mousedown.w2ui-editable", (S) => {
              S.stopPropagation();
            }).on("click.w2ui-editable", (S) => {
              f.call(y, S);
            }).on("paste.w2ui-editable", (S) => {
              S.preventDefault(), S = S.clipboardData.getData("text/plain"), document.execCommand("insertHTML", false, S);
            }).on("keyup.w2ui-editable", (S) => {
              f.call(y, S);
            }).on("keydown.w2ui-editable", (S) => {
              switch (S.keyCode) {
                case 8:
                  h.type != "list" || y._w2field || S.preventDefault();
                  break;
                case 9:
                case 13:
                  S.preventDefault();
                  break;
                case 27:
                  var A = p(y).data("tooltipName");
                  A && 0 < A.length && (this.last._edit.escKey = true, Ge.hide(A[0]), S.preventDefault()), S.stopPropagation();
              }
              setTimeout(() => {
                var _a3, _b3;
                switch (S.keyCode) {
                  case 9:
                    var R = S.shiftKey ? r.prevCell(c, t, true) : r.nextCell(c, t, true);
                    R != null && (C = r.records[R.index].recid, this.editChange(y, c, t, S), this.editDone(c, t, S), r.selectType != "row" ? (r.selectNone(true), r.select({ recid: C, column: R.colIndex })) : r.editField(C, R.colIndex, null, S), S.preventDefault) && S.preventDefault();
                    break;
                  case 13: {
                    let P = false;
                    var C = p(y).data("tooltipName");
                    C && Ge.get(C[0]).selected != null && (P = true), C && P || (this.editChange(y, c, t, S), this.editDone(c, t, S));
                    break;
                  }
                  case 27: {
                    this.last._edit.escKey = false;
                    let P = r.parseField(d, u.field);
                    ((_b3 = (_a3 = d.w2ui) == null ? void 0 : _a3.changes) == null ? void 0 : _b3[u.field]) != null && (P = d.w2ui.changes[u.field]), y._prevValue != null && (P = y._prevValue), y.tagName == "DIV" ? y.innerText = P ?? "" : y.value = P ?? "", this.editDone(c, t, S), setTimeout(() => {
                      r.select({ recid: e, column: t });
                    }, 1);
                    break;
                  }
                }
                f(y);
              }, 1);
            }), y && (y._prevValue = g), h.type != "list" && setTimeout(() => {
              this.last.inEditMode && y && (y.focus(), clearTimeout(this.last.kbd_timer), (y.resize = f)(y));
            }, 50), a.finish({ input: y });
          }
        }
      }
    }
  }
  editChange(e, t, i, n) {
    var _a2, _b2, _c2, _d2;
    e = e ?? this.last._edit.input, t = t ?? this.last._edit.index, i = i ?? this.last._edit.column, n = n ?? {};
    var r = (t < 0 ? this.summary : this.records)[t = t < 0 ? -t - 1 : t], o = this.columns[i];
    let a = (e == null ? void 0 : e.tagName) == "DIV" ? e.innerText : e.value;
    var l = e._w2field, c = (l && (l.type == "list" && (a = l.selected), Object.keys(a).length !== 0 && a != null || (a = ""), b.isPlainObject(a) || (a = l.clean(a))), e.type == "checkbox" && (((_a2 = r.w2ui) == null ? void 0 : _a2.editable) === false && (e.checked = !e.checked), a = e.checked), this.parseField(r, o.field)), h = ((_b2 = r.w2ui) == null ? void 0 : _b2.changes) && r.w2ui.changes.hasOwnProperty(o.field) ? r.w2ui.changes[o.field] : c;
    let d = { target: this.name, input: e, recid: r.recid, index: t, column: i, originalEvent: n, value: { new: a, previous: h, original: c } }, u = (((_c2 = n.target) == null ? void 0 : _c2._prevValue) != null && (d.value.previous = n.target._prevValue), 0);
    for (; u < 20; ) {
      if (u++, typeof (a = d.value.new) != "object" && String(c) != String(a) || typeof a == "object" && a && a.id != c && (typeof c != "object" || c == null || a.id != c.id)) {
        if ((d = this.trigger("change", d)).isCancelled !== true) {
          if (a !== d.detail.value.new) continue;
          (d.detail.value.new !== "" && d.detail.value.new != null || h !== "" && h != null) && (r.w2ui = r.w2ui ?? {}, r.w2ui.changes = r.w2ui.changes ?? {}, r.w2ui.changes[o.field] = d.detail.value.new), d.finish();
        }
      } else if ((d = this.trigger("restore", d)).isCancelled !== true) {
        if (a !== d.detail.value.new) continue;
        ((_d2 = r.w2ui) == null ? void 0 : _d2.changes) && (delete r.w2ui.changes[o.field], Object.keys(r.w2ui.changes).length === 0) && delete r.w2ui.changes, d.finish();
      }
      break;
    }
  }
  editDone(e, t, i) {
    var _a2, _b2;
    if (e = e ?? this.last._edit.index, t = t ?? this.last._edit.column, i = i ?? {}, this.advanceOnEdit && i.keyCode == 13) {
      let l = i.shiftKey ? this.prevRow(e, t, 1) : this.nextRow(e, t, 1);
      l == null && (l = e), setTimeout(() => {
        this.selectType != "row" ? (this.selectNone(true), this.select({ recid: this.records[l].recid, column: t })) : this.editField(this.records[l].recid, t, null, i);
      }, 1);
    }
    var n = e < 0, r = p(this.last._edit.tr).find('[col="' + t + '"]'), o = this.records[e], a = this.columns[t];
    this.last.inEditMode = false, this.last._edit = null, n || (((_b2 = (_a2 = o.w2ui) == null ? void 0 : _a2.changes) == null ? void 0 : _b2[a.field]) != null ? r.addClass("w2ui-changed") : r.removeClass("w2ui-changed"), r.replace(this.getCellHTML(e, t, n))), p(this.box).find("div.w2ui-edit-box").remove(), this.updateToolbar(), setTimeout(() => {
      var l = p(this.box).find(`#grid_${this.name}_focus`).get(0);
      document.activeElement === l || this.last.inEditMode || l.focus();
    }, 10);
  }
  delete(e) {
    var _a2;
    var t = this.trigger("delete", { target: this.name, force: e });
    if (e && this.message(), t.isCancelled !== true) {
      e = t.detail.force;
      var i = this.getSelection();
      if (i.length !== 0) if (this.msgDelete == "" || e) {
        if (typeof this.url != "object" ? this.url : this.url.remove) this.request("delete");
        else if (typeof i[0] != "object") this.selectNone(), this.remove.apply(this, i);
        else {
          for (let a = 0; a < i.length; a++) {
            var n = this.columns[i[a].column].field, r = this.get(i[a].recid, true), o = this.records[r];
            r != null && n != "recid" && (this.records[r][n] = "", (_a2 = o.w2ui) == null ? void 0 : _a2.changes) && delete o.w2ui.changes[n];
          }
          this.update();
        }
        t.finish();
      } else this.confirm({ text: b.lang(this.msgDelete, { count: i.length, records: b.lang(i.length == 1 ? "record" : "records") }), width: 380, height: 170, yes_text: b.lang("Delete"), yes_class: "w2ui-btn-red", no_text: b.lang("Cancel") }).yes((a) => {
        a.detail.self.close(), this.delete(true);
      }).no((a) => {
        a.detail.self.close();
      });
    }
  }
  click(e, t) {
    var _a2, _b2, _c2;
    var i = Date.now();
    let n = null;
    if (!(this.last.cancelClick == 1 || t && t.altKey)) if (typeof e == "object" && e !== null && (n = e.column, e = e.recid), t == null && (t = {}), i - parseInt(this.last.click_time) < 350 && this.last.click_recid == e && t.type == "click") this.dblClick(e, t);
    else {
      if (this.last.bubbleEl && (this.last.bubbleEl = null), this.last.click_time = i, i = this.last.click_recid, this.last.click_recid = e, n == null && t.target) {
        let d = t.target;
        d.tagName != "TD" && (d = p(d).closest("td")[0]), p(d).attr("col") != null && (n = parseInt(p(d).attr("col")));
      }
      var r = this.trigger("click", { target: this.name, recid: e, column: n, originalEvent: t });
      if (r.isCancelled !== true) {
        var o = this.getSelection(), a = (p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", false), this.get(e, true)), l = [];
        this.last.sel_ind = a, this.last.sel_col = n, this.last.sel_recid = e, this.last.sel_type = "click";
        let d, u, f, m;
        if (t.shiftKey && 0 < o.length && this.multiSelect) {
          if (o[0].recid) {
            d = this.get(o[0].recid, true), u = this.get(e, true), m = n > o[0].column ? (f = o[0].column, n) : (f = n, o[0].column);
            for (let _ = f; _ <= m; _++) l.push(_);
          } else d = this.get(i, true), u = this.get(e, true);
          var c = [], h = (d > u && (i = d, d = u, u = i), ((_a2 = this.url) == null ? void 0 : _a2.get) ? this.url.get : this.url);
          for (let _ = d; _ <= u; _++) if (!(0 < this.searchData.length) || h || this.last.searchIds.includes(_)) if (this.selectType == "row") c.push(this.records[_].recid);
          else for (let g = 0; g < l.length; g++) c.push({ recid: this.records[_].recid, column: l[g] });
          this.select(c);
        } else {
          i = this.last.selection;
          let _ = i.indexes.indexOf(a) != -1, g = false;
          p(t.target).closest("td").hasClass("w2ui-col-select") && (g = true), (t.ctrlKey || t.shiftKey || t.metaKey || g) && this.multiSelect || this.showSelectColumn ? (_ = this.selectType == "row" || ((_b2 = i.columns[a]) == null ? void 0 : _b2.includes(n)) ? _ : false) === true ? this.unselect({ recid: e, column: n }) : this.select({ recid: e, column: n }) : (this.selectType == "row" || ((_c2 = i.columns[a]) == null ? void 0 : _c2.includes(n)) || (_ = false), this.selectNone(true), _ === true && o.length == 1 ? this.unselect({ recid: e, column: n }) : this.select({ recid: e, column: n }));
        }
        this.status(), this.initResize(), r.finish();
      }
    }
  }
  columnClick(e, t) {
    if (this.last.colResizing !== true) {
      let o = this.trigger("columnClick", { target: this.name, field: e, originalEvent: t });
      if (o.isCancelled !== true) {
        if (this.selectType == "row") {
          var i = this.getColumn(e);
          i && i.sortable && this.sort(e, null, !(!t || !t.ctrlKey && !t.metaKey)), o.detail.field == "line-number" && (this.getSelection().length >= this.records.length ? this.selectNone() : this.selectAll());
        } else if (t.altKey && (i = this.getColumn(e)) && i.sortable && this.sort(e, null, !(!t || !t.ctrlKey && !t.metaKey)), o.detail.field == "line-number") this.getSelection().length >= this.records.length ? this.selectNone() : this.selectAll();
        else {
          t.shiftKey || t.metaKey || t.ctrlKey || this.selectNone(true);
          var i = this.getSelection(), e = this.getColumn(o.detail.field, true), n = [], r = [];
          if (i.length != 0 && t.shiftKey) {
            let c = e, h = i[0].column;
            c > h && (c = i[0].column, h = e);
            for (let d = c; d <= h; d++) r.push(d);
          } else r.push(e);
          if ((o = this.trigger("columnSelect", { target: this.name, columns: r })).isCancelled !== true) {
            for (let c = 0; c < this.records.length; c++) n.push({ recid: this.records[c].recid, column: r });
            this.select(n);
          }
          o.finish();
        }
        o.finish();
      }
    }
  }
  columnDblClick(e, t) {
    e = this.trigger("columnDblClick", { target: this.name, field: e, originalEvent: t }), e.isCancelled !== true && e.finish();
  }
  columnContextMenu(e, t) {
    e = this.trigger("columnContextMenu", { target: this.name, field: e, originalEvent: t }), e.isCancelled !== true && (this.show.columnMenu && (Ot.show({ type: "check", anchor: document.body, originalEvent: t, items: this.initColumnOnOff() }).then(() => {
      p("#w2overlay-context-menu .w2ui-grid-skip").off(".w2ui-grid").on("click.w2ui-grid", (i) => {
        i.stopPropagation();
      }).on("keypress", (i) => {
        i.keyCode == 13 && (this.skip(i.target.value), this.toolbar.click("w2ui-column-on-off"));
      });
    }).select((i) => {
      var n = i.detail.item.id;
      ["w2ui-stateSave", "w2ui-stateReset"].includes(n) ? this[n.substring(5)]() : n != "w2ui-skip" && this.columnOnOff(i, i.detail.item.id), clearTimeout(this.last.kbd_timer);
    }), clearTimeout(this.last.kbd_timer)), t.preventDefault(), e.finish());
  }
  focus(e) {
    if (e = this.trigger("focus", { target: this.name, originalEvent: e }), e.isCancelled === true) return false;
    this.hasFocus = true, p(this.box).removeClass("w2ui-inactive").find(".w2ui-inactive").removeClass("w2ui-inactive"), setTimeout(() => {
      var t = p(this.box).find(`#grid_${this.name}_focus`).get(0);
      t && document.activeElement != t && t.focus();
    }, 10), e.finish();
  }
  blur(e) {
    if (e = this.trigger("blur", { target: this.name, originalEvent: e }), e.isCancelled === true) return false;
    this.hasFocus = false, p(this.box).addClass("w2ui-inactive").find(".w2ui-selected").addClass("w2ui-inactive"), p(this.box).find(".w2ui-selection").addClass("w2ui-inactive"), e.finish();
  }
  keydown(e) {
    let t = this, i = typeof this.url != "object" ? this.url : this.url.get;
    if (t.keyboard === true) {
      var n = t.trigger("keydown", { target: t.name, originalEvent: e });
      if (n.isCancelled !== true) if (0 < p(this.box).find(".w2ui-message").length) e.keyCode == 27 && this.message();
      else {
        let l = function(P) {
          if (u && h(), !(S.length <= 0)) {
            let E = t.prevRow(y, t.selectType == "row" ? 0 : m[0].column, P);
            if ((E = C || E != null ? E : t.searchData.length == 0 || i ? 0 : t.last.searchIds[0]) != null) {
              if (C && t.multiSelect) {
                if (d()) return;
                if (t.selectType == "row") t.last.sel_ind > E && t.last.sel_ind != x ? t.unselect(t.records[x].recid) : t.select(t.records[E].recid);
                else if (t.last.sel_ind > E && t.last.sel_ind != x) {
                  E = x;
                  var z = [];
                  for (let N = 0; N < g.length; N++) z.push({ recid: t.records[E].recid, column: g[N] });
                  t.unselect(z);
                } else {
                  var w = [];
                  for (let N = 0; N < g.length; N++) w.push({ recid: t.records[E].recid, column: g[N] });
                  t.select(w);
                }
              } else t.selectNone(true), t.click({ recid: t.records[E].recid, column: g[0] }, e);
              t.scrollIntoView(E, null, true, P != 1), e.preventDefault && e.preventDefault();
            } else C || t.selectNone(true);
          }
        }, c = function(P) {
          if (u && h(), !(S.length <= 0)) {
            let E = t.nextRow(x, t.selectType == "row" ? 0 : m[0].column, P);
            if ((E = C || E != null ? E : t.searchData.length == 0 || i ? t.records.length - 1 : t.last.searchIds[t.last.searchIds.length - 1]) != null) {
              if (C && t.multiSelect) {
                if (d()) return;
                if (t.selectType == "row") t.last.sel_ind < E && t.last.sel_ind != y ? t.unselect(t.records[y].recid) : t.select(t.records[E].recid);
                else if (t.last.sel_ind < E && t.last.sel_ind != y) {
                  E = y;
                  var z = [];
                  for (let N = 0; N < g.length; N++) z.push({ recid: t.records[E].recid, column: g[N] });
                  t.unselect(z);
                } else {
                  var w = [];
                  for (let N = 0; N < g.length; N++) w.push({ recid: t.records[E].recid, column: g[N] });
                  t.select(w);
                }
              } else t.selectNone(true), t.click({ recid: t.records[E].recid, column: g[0] }, e);
              t.scrollIntoView(E, null, true, P != 1), A = true;
            } else C || t.selectNone(true);
          }
        }, h = function() {
          if (t.records && t.records.length !== 0) {
            let P = Math.floor(f[0].scrollTop / t.recordHeight) + 1;
            (!t.records[P] || P < 2) && (P = 0), t.records[P] !== void 0 && t.select({ recid: t.records[P].recid, column: 0 });
          }
        }, d = function() {
          if (t.last.sel_type == "click") {
            if (t.selectType == "row") return t.last.sel_type = "key", 1 < m.length && (m.splice(m.indexOf(t.records[t.last.sel_ind].recid), 1), t.unselect(m), 1);
            if (t.last.sel_type = "key", 1 < m.length) {
              for (let P = 0; P < m.length; P++) if (m[P].recid == t.last.sel_recid && m[P].column == t.last.sel_col) {
                m.splice(P, 1);
                break;
              }
              return t.unselect(m), 1;
            }
          }
        }, u = false, f = p(t.box).find("#grid_" + t.name + "_records"), m = t.getSelection(), _ = (m.length === 0 && (u = true), m[0] || null), g = [], v = m[m.length - 1];
        if (typeof _ == "object" && _ != null) {
          _ = m[0].recid, g = [];
          let P = 0;
          for (; !(!m[P] || m[P].recid != _); ) g.push(m[P].column), P++;
          v = m[m.length - 1].recid;
        }
        let y = t.get(_, true), x = t.get(v, true), S = p(t.box).find(`#grid_${t.name}_rec_` + (y != null ? b.escapeId(t.records[y].recid) : "none"));
        var r, o = Math.floor(f[0].clientHeight / t.recordHeight);
        let A = false, R = e.keyCode, C = e.shiftKey;
        switch (R) {
          case 8:
          case 46:
            t.delete(), A = true, e.stopPropagation();
            break;
          case 27:
            t.selectNone(), A = true;
            break;
          case 65:
            (e.metaKey || e.ctrlKey) && (t.selectAll(), A = true);
            break;
          case 13:
            if (this.selectType == "row" && t.show.expandColumn === true) {
              if (S.length <= 0) break;
              t.toggle(_, e), A = true;
            } else {
              for (let P = 0; P < this.columns.length; P++) if (this.getCellEditable(y, P)) {
                g.push(parseInt(P));
                break;
              }
              0 < (g = this.selectType == "row" && this.last._edit && this.last._edit.column ? [this.last._edit.column] : g).length && (t.editField(_, this.last.editColumn || g[0], null, e), A = true);
            }
            break;
          case 37:
            (function() {
              if (u) h();
              else {
                if (t.selectType == "row") {
                  if (S.length <= 0) return;
                  var P = t.records[y].w2ui || {};
                  !P || P.parent_recid == null || Array.isArray(P.children) && P.children.length !== 0 && P.expanded ? t.collapse(_, e) : (t.unselect(_), t.collapse(P.parent_recid, e), t.select(P.parent_recid));
                } else {
                  let N = t.prevCell(y, g[0]);
                  if (N = (N == null ? void 0 : N.index) != y ? null : N == null ? void 0 : N.colIndex, C || N != null || (t.selectNone(true), N = 0), N != null) if (C && t.multiSelect) {
                    if (d()) return;
                    var z = [], w = [], E = [];
                    if (g.indexOf(t.last.sel_col) === 0 && 1 < g.length) {
                      for (let k = 0; k < m.length; k++) z.indexOf(m[k].recid) == -1 && z.push(m[k].recid), E.push({ recid: m[k].recid, column: g[g.length - 1] });
                      t.unselect(E), t.scrollIntoView(y, g[g.length - 1], true);
                    } else {
                      for (let k = 0; k < m.length; k++) z.indexOf(m[k].recid) == -1 && z.push(m[k].recid), w.push({ recid: m[k].recid, column: N });
                      t.select(w), t.scrollIntoView(y, N, true);
                    }
                  } else t.click({ recid: _, column: N }, e), t.scrollIntoView(y, N, true);
                  else C || t.selectNone(true);
                }
                A = true;
              }
            })();
            break;
          case 39:
            (function() {
              if (u) h();
              else {
                if (t.selectType == "row") {
                  if (S.length <= 0) return;
                  t.expand(_, e);
                } else {
                  let E = t.nextCell(y, g[g.length - 1]);
                  if (E = E.index != y ? null : E.colIndex, C || E != null || (t.selectNone(true), E = t.columns.length - 1), E != null) if (C && R == 39 && t.multiSelect) {
                    if (d()) return;
                    var P = [], z = [], w = [];
                    if (g.indexOf(t.last.sel_col) == g.length - 1 && 1 < g.length) {
                      for (let N = 0; N < m.length; N++) P.indexOf(m[N].recid) == -1 && P.push(m[N].recid), w.push({ recid: m[N].recid, column: g[0] });
                      t.unselect(w), t.scrollIntoView(y, g[0], true);
                    } else {
                      for (let N = 0; N < m.length; N++) P.indexOf(m[N].recid) == -1 && P.push(m[N].recid), z.push({ recid: m[N].recid, column: E });
                      t.select(z), t.scrollIntoView(y, E, true);
                    }
                  } else t.click({ recid: _, column: E }, e), t.scrollIntoView(y, E, true);
                  else C || t.selectNone(true);
                }
                A = true;
              }
            })();
            break;
          case 33:
            l(o);
            break;
          case 34:
            c(o);
            break;
          case 35:
            c(-1);
            break;
          case 36:
            l(-1);
            break;
          case 38:
            l(e.metaKey || e.ctrlKey ? -1 : 1);
            break;
          case 40:
            c(e.metaKey || e.ctrlKey ? -1 : 1);
            break;
          case 17:
          case 91:
            u || b.isSafari && (t.last.copy_event = t.copy(false, e), (r = p(t.box).find("#grid_" + t.name + "_focus")).val(t.last.copy_event.detail.text), r[0].select());
            break;
          case 67:
            (e.metaKey || e.ctrlKey) && (b.isSafari || (t.last.copy_event = t.copy(false, e), (r = p(t.box).find("#grid_" + t.name + "_focus")).val(t.last.copy_event.detail.text), r[0].select()), t.copy(t.last.copy_event, e));
            break;
          case 88:
            u || (e.ctrlKey || e.metaKey) && (b.isSafari || (t.last.copy_event = t.copy(false, e), (r = p(t.box).find("#grid_" + t.name + "_focus")).val(t.last.copy_event.detail.text), r[0].select()), t.copy(t.last.copy_event, e));
        }
        var a = [32, 187, 189, 192, 219, 220, 221, 186, 222, 188, 190, 191];
        for (let P = 48; P <= 111; P++) a.push(P);
        a.indexOf(R) == -1 || e.ctrlKey || e.metaKey || A || (g.length === 0 && g.push(0), A = false, setTimeout(() => {
          var P = p(t.box).find("#grid_" + t.name + "_focus"), z = P.val();
          P.val(""), t.editField(_, g[0], z, e);
        }, 1)), A && e.preventDefault && e.preventDefault(), n.finish();
      }
    }
  }
  scrollIntoView(e, t, i, n) {
    let r = this.records.length;
    if ((r = this.searchData.length == 0 || this.url ? r : this.last.searchIds.length) !== 0) {
      if (e == null) {
        var o = this.getSelection();
        if (o.length === 0) return;
        b.isPlainObject(o[0]) ? (e = o[0].index, t = o[0].column) : e = this.get(o[0], true);
      }
      var o = p(this.box).find(`#grid_${this.name}_records`), a = o[0].clientWidth, l = o[0].clientHeight, c = o[0].scrollTop, h = o[0].scrollLeft, d = this.last.searchIds.length;
      if (0 < d && (e = this.last.searchIds.indexOf(e)), o.css({ "scroll-behavior": i ? "auto" : "smooth" }), l < this.recordHeight * (0 < d ? d : r) && 0 < o.length && (d = (i = Math.floor(c / this.recordHeight)) + Math.floor(l / this.recordHeight), e == i && o.prop("scrollTop", c - l / 1.3), e == d && o.prop("scrollTop", c + l / 1.3), (e < i || d < e) && o.prop("scrollTop", (e - 1) * this.recordHeight), n === true) && o.prop("scrollTop", e * this.recordHeight), t != null) {
        let f = 0, m = 0;
        c = b.scrollBarSize();
        for (let _ = 0; _ <= t; _++) {
          var u = this.columns[_];
          u.frozen || u.hidden || (f = m, m += parseInt(u.sizeCalculated));
        }
        a < m - h ? o.prop("scrollLeft", f - c) : f < h && o.prop("scrollLeft", m - a + 2 * c);
      }
    }
  }
  scrollToColumn(e) {
    if (e != null) {
      let i = 0, n = false;
      for (let r = 0; r < this.columns.length; r++) {
        var t = this.columns[r];
        if (t.field == e) {
          n = true;
          break;
        }
        t.frozen || t.hidden || (t = parseInt(t.sizeCalculated || t.size), i += t);
      }
      n && (this.last.scrollLeft = i + 1, this.scroll());
    }
  }
  dblClick(e, t) {
    let i = null;
    if (typeof e == "object" && e !== null && (i = e.column, e = e.recid), t == null && (t = {}), i == null && t.target) {
      let a = t.target;
      a.tagName.toUpperCase() != "TD" && (a = p(a).closest("td")[0]), i = parseInt(p(a).attr("col"));
    }
    var n = this.get(e, true), r = this.records[n], o = this.trigger("dblClick", { target: this.name, recid: e, column: i, originalEvent: t });
    o.isCancelled !== true && (this.selectNone(true), this.getCellEditable(n, i) ? this.editField(e, i, null, t) : (this.select({ recid: e, column: i }), (this.show.expandColumn || r && r.w2ui && Array.isArray(r.w2ui.children)) && this.toggle(e)), o.finish());
  }
  showContextMenu(e, t, i) {
    if (this.last.userSelect != "text") {
      (i = i ?? { offsetX: 0, offsetY: 0, target: p(this.box).find(`#grid_${this.name}_rec_` + e)[0] }).offsetX == null && (i.offsetX = i.layerX - i.target.offsetLeft, i.offsetY = i.layerY - i.target.offsetTop), b.isFloat(e) && (e = parseFloat(e));
      var n = this.getSelection();
      if (this.selectType == "row") n.indexOf(e) == -1 && this.click(e);
      else {
        let o = false;
        for (let a = 0; a < n.length; a++) n[a].recid != e && n[a].column != t || (o = true);
        o || e == null || this.click({ recid: e, column: t }), o || t == null || this.columnClick(this.columns[t].field, i);
      }
      var r = this.trigger("contextMenu", { target: this.name, originalEvent: i, recid: e, column: t });
      r.isCancelled !== true && (0 < this.contextMenu.length && (Ot.show({ anchor: document.body, originalEvent: i, items: this.contextMenu }).select((o) => {
        clearTimeout(this.last.kbd_timer), this.contextMenuClick(e, t, o);
      }), clearTimeout(this.last.kbd_timer)), i.preventDefault(), r.finish());
    }
  }
  contextMenuClick(e, t, i) {
    e = this.trigger("contextMenuClick", { target: this.name, recid: e, column: t, originalEvent: i.detail.originalEvent, menuEvent: i, menuIndex: i.detail.index, menuItem: i.detail.item }), e.isCancelled !== true && e.finish();
  }
  toggle(e) {
    var t = this.get(e);
    if (t != null) return t.w2ui = t.w2ui ?? {}, t.w2ui.expanded === true ? this.collapse(e) : this.expand(e);
  }
  expand(e, t) {
    var _a2;
    var i = this.get(e, true);
    let n = this.records[i];
    n.w2ui = n.w2ui ?? {};
    var r = b.escapeId(e), o = n.w2ui.children;
    let a;
    if (Array.isArray(o)) {
      if (n.w2ui.expanded === true || o.length === 0 || (a = this.trigger("expand", { target: this.name, recid: e })).isCancelled === true) return false;
      n.w2ui.expanded = true, o.forEach((l) => {
        l.w2ui = l.w2ui ?? {}, l.w2ui.parent_recid = n.recid, l.w2ui.children == null && (l.w2ui.children = []);
      }), this.records.splice.apply(this.records, [i + 1, 0].concat(o)), this.total !== -1 && (this.total += o.length), (typeof this.url != "object" ? this.url : this.url.get) || (this.localSort(true, true), 0 < this.searchData.length && this.localSearch(true)), t !== true && this.refresh(), a.finish();
    } else {
      if (0 < p(this.box).find("#grid_" + this.name + "_rec_" + r + "_expanded_row").length || this.show.expandColumn !== true || n.w2ui.expanded == "none") return false;
      if (p(this.box).find("#grid_" + this.name + "_rec_" + r).after(`<tr id="grid_${this.name}_rec_${e}_expanded_row" class="w2ui-expanded-row">
                    <td colspan="100" class="w2ui-expanded2">
                        <div id="grid_${this.name}_rec_${e}_expanded"></div>
                    </td>
                    <td class="w2ui-grid-data-last"></td>
                </tr>`), p(this.box).find("#grid_" + this.name + "_frec_" + r).after(`<tr id="grid_${this.name}_frec_${e}_expanded_row" class="w2ui-expanded-row">
                    ${this.show.lineNumbers ? '<td class="w2ui-col-number"></td>' : ""}
                    <td class="w2ui-grid-data w2ui-expanded1" colspan="100">
                       <div id="grid_${this.name}_frec_${e}_expanded"></div>
                    </td>
                </tr>`), (a = this.trigger("expand", { target: this.name, recid: e, box_id: "grid_" + this.name + "_rec_" + e + "_expanded", fbox_id: "grid_" + this.name + "_frec_" + e + "_expanded" })).isCancelled === true) return p(this.box).find("#grid_" + this.name + "_rec_" + r + "_expanded_row").remove(), p(this.box).find("#grid_" + this.name + "_frec_" + r + "_expanded_row").remove(), false;
      i = p(this.box).find("#grid_" + this.name + "_rec_" + e + "_expanded"), o = p(this.box).find("#grid_" + this.name + "_frec_" + e + "_expanded"), t = ((_a2 = i.find(":scope div:first-child")[0]) == null ? void 0 : _a2.clientHeight) ?? 50, i[0].clientHeight < t && i.css({ height: t + "px" }), o[0].clientHeight < t && o.css({ height: t + "px" }), p(this.box).find("#grid_" + this.name + "_rec_" + r).attr("expanded", "yes").addClass("w2ui-expanded"), p(this.box).find("#grid_" + this.name + "_frec_" + r).attr("expanded", "yes").addClass("w2ui-expanded"), p(this.box).find("#grid_" + this.name + "_cell_" + this.get(e, true) + "_expand div").html("-"), n.w2ui.expanded = true, a.finish(), this.resizeRecords();
    }
    return true;
  }
  collapse(e, t) {
    var i = this.get(e, true);
    let n = this.records[i], r = (n.w2ui = n.w2ui || {}, b.escapeId(e));
    var o = n.w2ui.children;
    let a;
    if (Array.isArray(o)) {
      if (n.w2ui.expanded !== true || (a = this.trigger("collapse", { target: this.name, recid: e })).isCancelled === true) return false;
      (function h(d) {
        d.w2ui.expanded = false;
        for (let u = 0; u < d.w2ui.children.length; u++) {
          let f = d.w2ui.children[u];
          f.w2ui.expanded && h(f);
        }
      })(n);
      var l = [];
      for (let h = n; h != null; h = this.get(h.w2ui.parent_recid)) l.push(h.w2ui.parent_recid);
      o = i + 1;
      let c = o;
      for (; !(this.records.length <= c + 1 || this.records[c + 1].w2ui == null || 0 <= l.indexOf(this.records[c + 1].w2ui.parent_recid)); ) c++;
      this.records.splice(o, c - o + 1), this.total !== -1 && (this.total -= c - o + 1), (typeof this.url != "object" ? this.url : this.url.get) || 0 < this.searchData.length && this.localSearch(true), t !== true && this.refresh(), a.finish();
    } else {
      if (p(this.box).find("#grid_" + this.name + "_rec_" + r + "_expanded_row").length === 0 || this.show.expandColumn !== true || (a = this.trigger("collapse", { target: this.name, recid: e, box_id: "grid_" + this.name + "_rec_" + e + "_expanded", fbox_id: "grid_" + this.name + "_frec_" + e + "_expanded" })).isCancelled === true) return false;
      p(this.box).find("#grid_" + this.name + "_rec_" + r).removeAttr("expanded").removeClass("w2ui-expanded"), p(this.box).find("#grid_" + this.name + "_frec_" + r).removeAttr("expanded").removeClass("w2ui-expanded"), p(this.box).find("#grid_" + this.name + "_cell_" + this.get(e, true) + "_expand div").html("+"), p(this.box).find("#grid_" + this.name + "_rec_" + r + "_expanded").css("height", "0px"), p(this.box).find("#grid_" + this.name + "_frec_" + r + "_expanded").css("height", "0px"), setTimeout(() => {
        p(this.box).find("#grid_" + this.name + "_rec_" + r + "_expanded_row").remove(), p(this.box).find("#grid_" + this.name + "_frec_" + r + "_expanded_row").remove(), n.w2ui.expanded = false, a.finish(), this.resizeRecords();
      }, 300);
    }
    return true;
  }
  sort(e, t, i) {
    var n = this.trigger("sort", { target: this.name, field: e, direction: t, multiField: i });
    if (n.isCancelled !== true) {
      if (e != null) {
        let r = this.sortData.length;
        for (let o = 0; o < this.sortData.length; o++) if (this.sortData[o].field == e) {
          r = o;
          break;
        }
        t == null && (t = this.sortData[r] != null && (this.sortData[r].direction == null && (this.sortData[r].direction = ""), this.sortData[r].direction.toLowerCase() === "asc") ? "desc" : "asc"), this.multiSort === false && (this.sortData = [], r = 0), i != 1 && (this.sortData = [], r = 0), this.sortData[r] == null && (this.sortData[r] = {}), this.sortData[r].field = e, this.sortData[r].direction = t;
      } else this.sortData = [];
      (typeof this.url != "object" ? this.url : this.url.get) ? (n.finish({ direction: t }), this.last.fetch.offset = 0, this.reload()) : (this.localSort(false, true), 0 < this.searchData.length && this.localSearch(true), this.last.scrollTop = 0, p(this.box).find(`#grid_${this.name}_records`).prop("scrollTop", 0), n.finish({ direction: t }), this.refresh());
    }
  }
  copy(e, t) {
    if (b.isPlainObject(e)) return e.finish(), e.text;
    var i = this.getSelection();
    if (i.length === 0) return "";
    let n = "";
    if (typeof i[0] == "object") {
      let h = i[0].column, d = i[0].column;
      var r = [];
      for (let u = 0; u < i.length; u++) i[u].column < h && (h = i[u].column), i[u].column > d && (d = i[u].column), r.indexOf(i[u].index) == -1 && r.push(i[u].index);
      r.sort((u, f) => u - f);
      for (let u = 0; u < r.length; u++) {
        var o = r[u];
        for (let f = h; f <= d; f++) this.columns[f].hidden !== true && (n += this.getCellCopy(o, f) + "	");
        n = n.substr(0, n.length - 1), n += `
`;
      }
    } else {
      for (let h = 0; h < this.columns.length; h++) {
        var a = this.columns[h];
        if (a.hidden !== true) {
          let d = a.text || a.field;
          a.text && a.text.length < 3 && a.tooltip && (d = a.tooltip), n += '"' + b.stripTags(d) + '"	';
        }
      }
      n = n.substr(0, n.length - 1), n += `
`;
      for (let h = 0; h < i.length; h++) {
        var l = this.get(i[h], true);
        for (let d = 0; d < this.columns.length; d++) this.columns[d].hidden !== true && (n += '"' + this.getCellCopy(l, d) + '"	');
        n = n.substr(0, n.length - 1), n += `
`;
      }
    }
    n = n.substr(0, n.length - 1);
    let c;
    return e == null ? (c = this.trigger("copy", { target: this.name, text: n, cut: t.keyCode == 88, originalEvent: t })).isCancelled === true ? "" : (n = c.detail.text, c.finish(), n) : e === false ? (c = this.trigger("copy", { target: this.name, text: n, cut: t.keyCode == 88, originalEvent: t })).isCancelled === true ? "" : (n = c.detail.text, c) : void 0;
  }
  getCellCopy(e, t) {
    return b.stripTags(this.getCellHTML(e, t));
  }
  paste(e, c) {
    var i = this.getSelection();
    let n = this.get(i[0].recid, true);
    var r, o, a, l = i[0].column, c = this.trigger("paste", { target: this.name, text: e, index: n, column: l, originalEvent: c });
    if (c.isCancelled !== true) {
      if (e = c.detail.text, this.selectType == "row" || i.length === 0) console.log("ERROR: You can paste only if grid.selectType = 'cell' and when at least one cell selected.");
      else {
        if (typeof e != "object") {
          var h = [];
          e = e.split(`
`);
          for (let m = 0; m < e.length; m++) {
            var d = e[m].split("	");
            let _ = 0;
            var u = this.records[n], f = [];
            if (u != null) {
              for (let g = 0; g < d.length; g++) this.columns[l + _] && (r = u, o = this.columns[l + _].field, a = d[g], r.w2ui = r.w2ui ?? {}, r.w2ui.changes = r.w2ui.changes || {}, r.w2ui.changes[o] = a, f.push(l + _), _++);
              for (let g = 0; g < f.length; g++) h.push({ recid: u.recid, column: f[g] });
              n++;
            }
          }
          this.selectNone(true), this.select(h);
        } else this.selectNone(true), this.select([{ recid: this.records[n], column: l }]);
        this.refresh();
      }
      c.finish();
    }
  }
  resize() {
    var e = Date.now();
    if (this.box && p(this.box).attr("name") == this.name) {
      var t = this.trigger("resize", { target: this.name });
      if (t.isCancelled !== true) return this.resizeBoxes(), this.resizeRecords(), t.finish(), Date.now() - e;
    }
  }
  update({ cells: e, fullCellRefresh: t, ignoreColumns: i } = {}) {
    var n = Date.now();
    let r = this;
    if (this.box == null) return 0;
    if (Array.isArray(e)) for (let d = 0; d < e.length; d++) {
      var o = e[d].index, a = e[d].column;
      if (!(o < 0)) if (o == null || a == null) console.log("ERROR: Wrong argument for grid.update({ cells }), cells should be [{ index: X, column: Y }, ...]");
      else {
        var l = this.records[o] ?? {};
        l.w2ui = l.w2ui ?? {}, l.w2ui._update = l.w2ui._update ?? { cells: [] };
        let u = l.w2ui._update.row1, f = l.w2ui._update.row2;
        u != null && u.isConnected && f != null && f.isColSelected || (u = this.box.querySelector(`#grid_${this.name}_rec_` + b.escapeId(l.recid)), f = this.box.querySelector(`#grid_${this.name}_frec_` + b.escapeId(l.recid)), l.w2ui._update.row1 = u, l.w2ui._update.row2 = f), h(l, u, f, o, a);
      }
    }
    else for (let d = this.last.range_start - 1; d <= this.last.range_end; d++) {
      let u = d;
      u = 0 < this.last.searchIds.length ? this.last.searchIds[d] : d;
      var c = this.records[u];
      if (!(u < 0 || c == null)) {
        c.w2ui = c.w2ui ?? {}, c.w2ui._update = c.w2ui._update ?? { cells: [] };
        let f = c.w2ui._update.row1, m = c.w2ui._update.row2;
        f != null && f.isConnected && m != null && m.isColSelected || (f = this.box.querySelector(`#grid_${this.name}_rec_` + b.escapeId(c.recid)), m = this.box.querySelector(`#grid_${this.name}_frec_` + b.escapeId(c.recid)), c.w2ui._update.row1 = f, c.w2ui._update.row2 = m);
        for (let _ = 0; _ < this.columns.length; _++) h(c, f, m, u, _);
      }
    }
    return Date.now() - n;
    function h(d, u, f, m, _) {
      var g = r.columns[_];
      if (!Array.isArray(i) || !i.includes(_) && !i.includes(g.field)) {
        let S = d.w2ui._update.cells[_];
        if (S != null && S.isConnected || (S = r.box.querySelector(`#grid_${r.name}_data_${m}_` + _), d.w2ui._update.cells[_] = S), S != null) {
          if (t) p(S).replace(r.getCellHTML(m, _, false)), S = r.box.querySelector(`#grid_${r.name}_data_${m}_` + _), d.w2ui._update.cells[_] = S;
          else {
            var v = S.children[0], { value: m, style: y, className: x } = r.getCellValue(m, _, false, true);
            if (v.innerHTML != m && (v.innerHTML = m), y != "" && S.style.cssText != y && (S.style.cssText = y), x != "") {
              let R = ["w2ui-grid-data"], C = [];
              v = x.split(" ").filter((P) => !!P), S.classList.forEach((P) => {
                R.includes(P) || C.push(P);
              }), S.classList.remove(...C), S.classList.add(...v);
            }
          }
          if (r.columns[_].style && r.columns[_].style != S.style.cssText && (S.style.cssText = r.columns[_].style ?? ""), d.w2ui.class != null) {
            if (typeof d.w2ui.class == "string") {
              let A = ["w2ui-odd", "w2ui-even", "w2ui-record"], R = [];
              m = d.w2ui.class.split(" ").filter((C) => !!C), u && f && (u.classList.forEach((C) => {
                A.includes(C) || R.push(C);
              }), u.classList.remove(...R), u.classList.add(...m), f.classList.remove(...R), f.classList.add(...m));
            }
            if (b.isPlainObject(d.w2ui.class) && typeof d.w2ui.class[g.field] == "string") {
              let A = ["w2ui-grid-data"], R = [];
              y = d.w2ui.class[g.field].split(" ").filter((C) => !!C), S.classList.forEach((C) => {
                A.includes(C) || R.push(C);
              }), S.classList.remove(...R), S.classList.add(...y);
            }
          }
          d.w2ui.style != null && (u && f && typeof d.w2ui.style == "string" && u.style.cssText !== d.w2ui.style && (u.style.cssText = "height: " + r.recordHeight + "px;" + d.w2ui.style, u.setAttribute("custom_style", d.w2ui.style), f.style.cssText = "height: " + r.recordHeight + "px;" + d.w2ui.style, f.setAttribute("custom_style", d.w2ui.style)), b.isPlainObject(d.w2ui.style)) && typeof d.w2ui.style[g.field] == "string" && S.style.cssText !== d.w2ui.style[g.field] && (S.style.cssText = d.w2ui.style[g.field]);
        }
      }
    }
  }
  refreshCell(r, n) {
    var i = this.get(r, true), n = this.getColumn(n, true), r = !this.records[i] || this.records[i].recid != r, o = p(this.box).find(`${r ? ".w2ui-grid-summary " : ""}#grid_${this.name}_data_${i}_` + n);
    return o.length != 0 && (o.replace(this.getCellHTML(i, n, r)), true);
  }
  refreshRow(e, t = null) {
    let i = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(e)), n = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(e));
    if (0 < i.length) {
      t == null && (t = this.get(e, true));
      var r = i.attr("line"), o = !this.records[t] || this.records[t].recid != e, a = typeof this.url != "object" ? this.url : this.url.get;
      if (0 < this.searchData.length && !a) for (let c = 0; c < this.last.searchIds.length; c++) this.last.searchIds[c] == t && (t = c);
      a = this.getRecordHTML(t, r, o), i.replace(a[0]), n.replace(a[1]);
      let l = this.records[t].w2ui ? this.records[t].w2ui.style : "";
      return typeof l == "string" && (i = p(this.box).find("#grid_" + this.name + "_frec_" + b.escapeId(e)), n = p(this.box).find("#grid_" + this.name + "_rec_" + b.escapeId(e)), i.attr("custom_style", l), n.attr("custom_style", l), i.hasClass("w2ui-selected") && (l = l.replace("background-color", "none")), i[0].style.cssText = "height: " + this.recordHeight + "px;" + l, n[0].style.cssText = "height: " + this.recordHeight + "px;" + l), o && this.resize(), true;
    }
    return false;
  }
  refresh() {
    var e = Date.now(), t = typeof this.url != "object" ? this.url : this.url.get;
    if (this.total <= 0 && !t && this.searchData.length === 0 && (this.total = this.records.length), this.box && (t = this.trigger("refresh", { target: this.name }), t.isCancelled !== true)) {
      this.show.header ? p(this.box).find(`#grid_${this.name}_header`).html(b.lang(this.header) + "&#160;").show() : p(this.box).find(`#grid_${this.name}_header`).hide(), this.show.toolbar ? p(this.box).find("#grid_" + this.name + "_toolbar").show() : p(this.box).find("#grid_" + this.name + "_toolbar").hide(), this.searchClose();
      var i = p(this.box).find("#grid_" + this.name + "_search_all");
      !this.multiSearch && this.last.field == "all" && 0 < this.searches.length && (this.last.field = this.searches[0].field, this.last.label = this.searches[0].label);
      for (let a = 0; a < this.searches.length; a++) this.searches[a].field == this.last.field && (this.last.label = this.searches[a].label);
      if (this.last.multi ? i.attr("placeholder", "[" + b.lang("Multiple Fields") + "]") : i.attr("placeholder", b.lang("Search") + " " + b.lang(this.last.label, true)), i.val() != this.last.search) {
        let a = this.last.search;
        var n = i._w2field;
        n && (a = n.format(a)), i.val(a);
      }
      this.refreshSearch(), this.refreshBody(), this.show.footer ? p(this.box).find(`#grid_${this.name}_footer`).html(this.getFooterHTML()).show() : p(this.box).find(`#grid_${this.name}_footer`).hide();
      var n = this.last.selection, i = 0 < this.records.length && n.indexes.length == this.records.length, n = 0 < n.indexes.length && this.searchData.length !== 0 && n.indexes.length == this.last.searchIds.length, r = (i || n ? p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", true) : p(this.box).find("#grid_" + this.name + "_check_all").prop("checked", false), this.status(), this.find({ "w2ui.expanded": true }, true, true));
      for (let a = 0; a < r.length; a++) {
        var o = this.records[r[a]].w2ui;
        o && !Array.isArray(o.children) && (o.expanded = false);
      }
      return this.markSearch && setTimeout(() => {
        var a = [];
        for (let h = 0; h < this.searchData.length; h++) {
          var l = this.searchData[h], c = this.getSearch(l.field);
          c && !c.hidden && (c = this.getColumn(l.field, true), a.push({ field: l.field, search: l.value, col: c }));
        }
        0 < a.length && a.forEach((h) => {
          var d = p(this.box).find('td[col="' + h.col + '"]:not(.w2ui-head)');
          b.marker(d, h.search);
        });
      }, 50), this.updateToolbar(this.last.selection), t.finish(), this.resize(), this.addRange("selection"), setTimeout(() => {
        this.resize(), this.scroll();
      }, 1), this.reorderColumns && !this.last.columnDrag ? this.last.columnDrag = this.initColumnDrag() : !this.reorderColumns && this.last.columnDrag && this.last.columnDrag.remove(), Date.now() - e;
    }
  }
  refreshSearch() {
    if (this.multiSearch && 0 < this.searchData.length) {
      p(this.box).find(".w2ui-grid-searches").length == 0 && p(this.box).find(".w2ui-grid-toolbar").css("height", this.last.toolbar_height + 35 + "px").append(`<div id="grid_${this.name}_searches" class="w2ui-grid-searches"></div>`);
      let e = `
                <span id="grid_${this.name}_search_logic" class="w2ui-grid-search-logic"></span>
                <div class="grid-search-line"></div>`;
      this.searchData.forEach((t, i) => {
        var n = this.getSearch(t.field, true), r = this.searches[n];
        let o;
        if (o = Array.isArray(t.value) ? `<span class="grid-search-count">${t.value.length}</span>` : r && r.type == "list" && t.text && t.text !== t.value ? ": " + t.text : ": " + t.value, r && r.type == "date") if (t.operator == "between") {
          let a = t.value[0], l = t.value[1];
          Number(a) === a && (a = b.formatDate(a)), Number(l) === l && (l = b.formatDate(l)), o = `: ${a} - ` + l;
        } else {
          let a = t.value, l = (Number(a) == a && (a = b.formatDate(a)), t.operator);
          (l = (l = l == "more" ? "since" : l) == "less" ? "before" : l).substr(0, 5) == "more:" && (l = "since"), o = `: ${l} ` + a;
        }
        e += `<span class="w2ui-action" data-click="searchFieldTooltip|${n}|${i}|this">
                    ${r ? r.label : ""}
                    ${o}
                    <span class="icon-chevron-down"></span>
                </span>`;
      }), e += `
                ${this.show.searchSave ? `<div class="grid-search-line"></div>
                       <button class="w2ui-btn grid-search-btn" data-click="searchSave">${b.lang("Save")}</button>
                      ` : ""}
                <button class="w2ui-btn grid-search-btn btn-remove"
                    data-click="searchReset">X</button>
            `, p(this.box).find(`#grid_${this.name}_searches`).html(e), p(this.box).find(`#grid_${this.name}_search_logic`).html(b.lang(this.last.logic == "AND" ? "All" : "Any"));
    } else p(this.box).find(".w2ui-grid-toolbar").css("height", this.last.toolbar_height + "px").find(".w2ui-grid-searches").remove();
    this.searchSelected ? (p(this.box).find(`#grid_${this.name}_search_all`).val(" ").prop("readOnly", true), p(this.box).find(`#grid_${this.name}_search_name`).show().find(".name-text").html(this.searchSelected.text)) : (p(this.box).find(`#grid_${this.name}_search_all`).prop("readOnly", false), p(this.box).find(`#grid_${this.name}_search_name`).hide().find(".name-text").html("")), b.bindEvents(p(this.box).find(`#grid_${this.name}_searches .w2ui-action, #grid_${this.name}_searches button`), this);
  }
  refreshBody() {
    this.scroll();
    var t = this.getRecordsHTML(), e = this.getColumnsHTML(), t = '<div id="grid_' + this.name + '_frecords" class="w2ui-grid-frecords" style="margin-bottom: ' + (b.scrollBarSize() - 1) + 'px;">' + t[0] + '</div><div id="grid_' + this.name + '_records" class="w2ui-grid-records">' + t[1] + '</div><div id="grid_' + this.name + '_scroll1" class="w2ui-grid-scroll1" style="height: ' + b.scrollBarSize() + 'px"></div><div id="grid_' + this.name + '_fcolumns" class="w2ui-grid-fcolumns">    <table><tbody>' + e[0] + '</tbody></table></div><div id="grid_' + this.name + '_columns" class="w2ui-grid-columns">    <table><tbody>' + e[1] + `</tbody></table></div><div class="w2ui-intersection-marker" style="display: none; height: ${this.recordHeight - 5}px">
               <div class="top-marker"></div>
               <div class="bottom-marker"></div>
            </div>`;
    let i = p(this.box).find(`#grid_${this.name}_body`, this.box).html(t);
    e = p(this.box).find(`#grid_${this.name}_records`, this.box), t = p(this.box).find(`#grid_${this.name}_frecords`, this.box), this.selectType == "row" && (e.on("mouseover mouseout", { delegate: "tr" }, (n) => {
      var r = p(n.delegate).attr("recid");
      p(this.box).find(`#grid_${this.name}_frec_` + b.escapeId(r)).toggleClass("w2ui-record-hover", n.type == "mouseover");
    }), t.on("mouseover mouseout", { delegate: "tr" }, (n) => {
      var r = p(n.delegate).attr("recid");
      p(this.box).find(`#grid_${this.name}_rec_` + b.escapeId(r)).toggleClass("w2ui-record-hover", n.type == "mouseover");
    })), b.isIOS ? e.append(t).on("click", { delegate: "tr" }, (n) => {
      var r = p(n.delegate).attr("recid");
      this.dblClick(r, n);
    }) : e.add(t).on("click", { delegate: "tr" }, (n) => {
      var r = p(n.delegate).attr("recid");
      r != "-none-" && this.click(r, n);
    }).on("contextmenu", { delegate: "tr" }, (n) => {
      var r = p(n.delegate).attr("recid"), o = p(n.target).closest("td"), o = parseInt(o.attr("col") ?? -1);
      this.showContextMenu(r, o, n);
    }).on("mouseover", { delegate: "tr" }, (n) => {
      this.last.rec_out = false;
      let r = p(n.delegate).attr("index"), o = p(n.delegate).attr("recid");
      r !== this.last.rec_over && (this.last.rec_over = r, setTimeout(() => {
        delete this.last.rec_out, this.trigger("mouseEnter", { target: this.name, originalEvent: n, index: r, recid: o }).finish();
      }));
    }).on("mouseout", { delegate: "tr" }, (n) => {
      let r = p(n.delegate).attr("index"), o = p(n.delegate).attr("recid");
      this.last.rec_out = true, setTimeout(() => {
        let a = () => {
          this.trigger("mouseLeave", { target: this.name, originalEvent: n, index: r, recid: o }).finish();
        };
        r !== this.last.rec_over && a(), setTimeout(() => {
          this.last.rec_out && (delete this.last.rec_out, delete this.last.rec_over, a());
        });
      });
    }), i.data("scroll", { lastDelta: 0, lastTime: 0 }).find(".w2ui-grid-frecords").on("mousewheel DOMMouseScroll ", (a) => {
      a.preventDefault();
      var r = i.data("scroll"), o = i.find(".w2ui-grid-records"), a = typeof a.wheelDelta != null ? -a.wheelDelta : a.detail || a.deltaY, l = o.prop("scrollTop");
      r.lastDelta += a, a = Math.round(r.lastDelta), i.data("scroll", r), o.get(0).scroll({ top: l + a, behavior: "smooth" });
    }), e.off(".body-global").on("scroll.body-global", { delegate: ".w2ui-grid-records" }, (n) => {
      this.scroll(n);
    }), p(this.box).find(".w2ui-grid-body").off(".body-global").on("click.body-global dblclick.body-global contextmenu.body-global", { delegate: "td.w2ui-head" }, (n) => {
      var r = p(n.delegate).attr("col"), o = this.columns[r] ?? { field: r };
      switch (n.type) {
        case "click":
          this.columnClick(o.field, n);
          break;
        case "dblclick":
          this.columnDblClick(o.field, n);
          break;
        case "contextmenu":
          this.columnContextMenu(o.field, n);
      }
    }).on("mouseover.body-global", { delegate: ".w2ui-col-header" }, (n) => {
      let r = p(n.delegate).parent().attr("col");
      this.columnTooltipShow(r, n), p(n.delegate).off(".tooltip").on("mouseleave.tooltip", () => {
        this.columnTooltipHide(r, n);
      });
    }).on("click.body-global", { delegate: "input.w2ui-select-all" }, (n) => {
      n.delegate.checked ? this.selectAll() : this.selectNone(), n.stopPropagation(), clearTimeout(this.last.kbd_timer);
    }).on("click.body-global", { delegate: ".w2ui-show-children, .w2ui-col-expand" }, (n) => {
      n.stopPropagation(), this.toggle(p(n.target).parents("tr").attr("recid"));
    }).on("click.body-global mouseover.body-global", { delegate: ".w2ui-info" }, (n) => {
      var _a2, _b2;
      var r = p(n.delegate).closest("td"), o = r.parent(), a = this.columns[r.attr("col")], l = o.parents(".w2ui-grid-body").hasClass("w2ui-grid-summary");
      ["mouseenter", "mouseover"].includes((_b2 = (_a2 = a.info) == null ? void 0 : _a2.showOn) == null ? void 0 : _b2.toLowerCase()) && n.type == "mouseover" ? this.showBubble(o.attr("index"), r.attr("col"), l).then(() => {
        p(n.delegate).off(".tooltip").on("mouseleave.tooltip", () => {
          Ge.hide(this.name + "-bubble");
        });
      }) : n.type == "click" && (Ge.hide(this.name + "-bubble"), this.showBubble(o.attr("index"), r.attr("col"), l));
    }).on("mouseover.body-global", { delegate: ".w2ui-clipboard-copy" }, (n) => {
      if (!n.delegate._tooltipShow) {
        let o = p(n.delegate).parent(), a = o.parent();
        var r = this.columns[o.attr("col")];
        let l = a.parents(".w2ui-grid-body").hasClass("w2ui-grid-summary");
        Ge.show({ name: this.name + "-bubble", anchor: n.delegate, html: b.lang(typeof r.clipboardCopy == "string" ? r.clipboardCopy : "Copy to clipboard"), position: "top|bottom", offsetY: -2 }).hide((c) => {
          n.delegate._tooltipShow = false, p(n.delegate).off(".tooltip");
        }), p(n.delegate).off(".tooltip").on("mouseleave.tooltip", (c) => {
          Ge.hide(this.name + "-bubble");
        }).on("click.tooltip", (c) => {
          c.stopPropagation(), Ge.update(this.name + "-bubble", b.lang("Copied")), this.clipboardCopy(a.attr("index"), o.attr("col"), l);
        }), n.delegate._tooltipShow = true;
      }
    }).on("click.body-global", { delegate: ".w2ui-editable-checkbox" }, (n) => {
      var r = p(n.delegate).data();
      this.editChange.call(this, n.delegate, r.changeind, r.colind, n), this.updateToolbar();
    }), this.records.length === 0 && this.msgEmpty ? p(this.box).find(`#grid_${this.name}_body`).append(`<div id="grid_${this.name}_empty_msg" class="w2ui-grid-empty-msg"><div>${b.lang(this.msgEmpty)}</div></div>`) : 0 < p(this.box).find(`#grid_${this.name}_empty_msg`).length && p(this.box).find(`#grid_${this.name}_empty_msg`).remove(), 0 < this.summary.length ? (t = this.getSummaryHTML(), p(this.box).find(`#grid_${this.name}_fsummary`).html(t[0]).show(), p(this.box).find(`#grid_${this.name}_summary`).html(t[1]).show()) : (p(this.box).find(`#grid_${this.name}_fsummary`).hide(), p(this.box).find(`#grid_${this.name}_summary`).hide());
  }
  render(e) {
    var t = Date.now();
    let i = this;
    typeof e == "string" && (e = p(e).get(0));
    var n = this.trigger("render", { target: this.name, box: e ?? this.box });
    if (n.isCancelled !== true && (e != null && (0 < p(this.box).find(`#grid_${this.name}_body`).length && p(this.box).removeAttr("name").removeClass("w2ui-reset w2ui-grid w2ui-inactive").html(""), this.box = e), this.box)) {
      let r = function(h) {
        var _a2, _b2;
        if (h.target.tagName) {
          var d = i.last.move;
          if (d && ["select", "select-column"].indexOf(d.type) != -1 && (d.divX = h.screenX - d.x, d.divY = h.screenY - d.y, !(Math.abs(d.divX) <= 1 && Math.abs(d.divY) <= 1))) if (i.last.cancelClick = true, i.reorderRows == 1 && i.last.move.reorder) {
            let A = p(h.target).parents("tr").attr("recid");
            (A = A == "-none-" ? "bottom" : A) != d.from && (f = p(i.box).find("#grid_" + i.name + "_rec_" + A), p(i.box).find(".insert-before"), f.addClass("insert-before"), d.lastY = h.screenY, d.to = A, f = { top: (_a2 = f.get(0)) == null ? void 0 : _a2.offsetTop, left: (_b2 = f.get(0)) == null ? void 0 : _b2.offsetLeft }, p(i.box).find("#grid_" + i.name + "_ghost_line").css({ top: f.top + "px", left: d.pos.left + "px", "border-top": "2px solid #769EFC" })), p(i.box).find("#grid_" + i.name + "_ghost").css({ top: d.pos.top + d.divY + "px", left: d.pos.left + "px" });
          } else {
            d.start && d.recid && (i.selectNone(), d.start = false);
            var u = [], f = (h.target.tagName.toUpperCase() == "TR" ? p(h.target) : p(h.target).parents("tr")).attr("recid");
            if (f == null) {
              if (i.selectType != "row" && (!i.last.move || i.last.move.type != "select")) {
                var m = parseInt(p(h.target).parents("td").attr("col"));
                if (isNaN(m)) i.removeRange("column-selection"), p(i.box).find(".w2ui-grid-columns .w2ui-col-header, .w2ui-grid-fcolumns .w2ui-col-header").removeClass("w2ui-col-selected"), p(i.box).find(".w2ui-col-number").removeClass("w2ui-row-selected"), delete d.colRange;
                else {
                  let A = m + "-" + m;
                  d.column < m && (A = d.column + "-" + m);
                  var _ = [], g = (A = d.column > m ? m + "-" + d.column : A).split("-");
                  for (let R = parseInt(g[0]); R <= parseInt(g[1]); R++) _.push(R);
                  if (d.colRange != A && (c = i.trigger("columnSelect", { target: i.name, columns: _ })).isCancelled !== true) {
                    d.colRange == null && i.selectNone();
                    var v = A.split("-");
                    p(i.box).find(".w2ui-grid-columns .w2ui-col-header, .w2ui-grid-fcolumns .w2ui-col-header").removeClass("w2ui-col-selected");
                    for (let R = parseInt(v[0]); R <= parseInt(v[1]); R++) p(i.box).find("#grid_" + i.name + "_column_" + R + " .w2ui-col-header").addClass("w2ui-col-selected");
                    p(i.box).find(".w2ui-col-number").not(".w2ui-head").addClass("w2ui-row-selected"), d.colRange = A, i.removeRange("column-selection"), i.addRange({ name: "column-selection", range: [{ recid: i.records[0].recid, column: v[0] }, { recid: i.records[i.records.length - 1].recid, column: v[1] }], style: "background-color: rgba(90, 145, 234, 0.1)" });
                  }
                }
              }
            } else {
              let A = i.get(d.recid, true);
              if (!(A == null || i.records[A] && i.records[A].recid != d.recid)) {
                let R = i.get(f, true);
                if (R != null) {
                  let C = parseInt(d.column), P = parseInt((h.target.tagName.toUpperCase() == "TD" ? p(h.target) : p(h.target).parents("td")).attr("col"));
                  isNaN(C) && isNaN(P) && (C = 0, P = i.columns.length - 1), A > R && (m = A, A = R, R = m);
                  var y, f = "ind1:" + A + ",ind2;" + R + ",col1:" + C + ",col2:" + P;
                  if (d.range != f) {
                    d.range = f;
                    for (let w = A; w <= R; w++) if (!(0 < i.last.searchIds.length && i.last.searchIds.indexOf(w) == -1)) if (i.selectType != "row") {
                      C > P && (y = C, C = P, P = y);
                      for (let E = C; E <= P; E++) i.columns[E].hidden || u.push({ recid: i.records[w].recid, column: parseInt(E) });
                    } else u.push(i.records[w].recid);
                    if (i.selectType != "row") {
                      var x = i.getSelection();
                      let w = [];
                      for (let E = 0; E < u.length; E++) {
                        let N = false;
                        for (let k = 0; k < x.length; k++) u[E].recid == x[k].recid && u[E].column == x[k].column && (N = true);
                        N || w.push({ recid: u[E].recid, column: u[E].column });
                      }
                      i.select(w), w = [];
                      for (let E = 0; E < x.length; E++) {
                        let N = false;
                        for (let k = 0; k < u.length; k++) u[k].recid == x[E].recid && u[k].column == x[E].column && (N = true);
                        N || w.push({ recid: x[E].recid, column: x[E].column });
                      }
                      i.unselect(w);
                    } else if (i.multiSelect) {
                      var S = i.getSelection();
                      for (let w = 0; w < u.length; w++) S.indexOf(u[w]) == -1 && i.select(u[w]);
                      for (let w = 0; w < S.length; w++) u.indexOf(S[w]) == -1 && i.unselect(S[w]);
                    }
                  }
                }
              }
            }
          }
        }
      }, o = function(h) {
        var d = i.last.move;
        if (setTimeout(() => {
          delete i.last.cancelClick;
        }, 1), !p(h.target).parents().hasClass(".w2ui-head") && !p(h.target).hasClass(".w2ui-head")) {
          if (d && ["select", "select-column"].indexOf(d.type) != -1) {
            if (d.colRange != null && c.isCancelled !== true) {
              var u = d.colRange.split("-"), f = [];
              for (let g = 0; g < i.records.length; g++) {
                var m = [];
                for (let v = parseInt(u[0]); v <= parseInt(u[1]); v++) m.push(v);
                f.push({ recid: i.records[g].recid, column: m });
              }
              i.removeRange("column-selection"), c.finish(), i.select(f);
            }
            if (i.reorderRows == 1 && i.last.move.reorder) if (d.to != null) {
              if (h = i.trigger("reorderRow", { target: i.name, recid: d.from, moveBefore: d.to }), h.isCancelled === true) return a(), void delete i.last.move;
              var _ = i.get(d.from, true);
              let g = i.get(d.to, true);
              d.to == "bottom" && (g = i.records.length), d = i.records[_], _ != null && g != null && (i.records.splice(_, 1), _ > g ? i.records.splice(g, 0, d) : i.records.splice(g - 1, 0, d)), i.sortData = [], p(i.box).find(`#grid_${i.name}_columns .w2ui-col-header`).removeClass("w2ui-col-sorted"), a(), h.finish();
            } else a();
          }
          delete i.last.move, p(document).off(".w2ui-" + i.name);
        }
      }, a = function() {
        p(i.box).find(`#grid_${i.name}_ghost`).remove(), p(i.box).find(`#grid_${i.name}_ghost_line`).remove(), i.refresh(), delete i.last.move;
      };
      if (e = typeof this.url != "object" ? this.url : this.url.get, this.reset(true), !this.last.field) if (this.multiSearch && this.show.searchAll) this.last.field = "all", this.last.label = "All Fields";
      else {
        let h = 0;
        for (; h < this.searches.length && (this.searches[h].hidden || this.searches[h].simple === false); ) h++;
        h >= this.searches.length ? (this.last.field = "", this.last.label = "") : (this.last.field = this.searches[h].field, this.last.label = this.searches[h].label);
      }
      if (p(this.box).attr("name", this.name).addClass("w2ui-reset w2ui-grid w2ui-inactive").html('<div class="w2ui-grid-box">    <div id="grid_' + this.name + '_header" class="w2ui-grid-header"></div>    <div id="grid_' + this.name + '_toolbar" class="w2ui-grid-toolbar"></div>    <div id="grid_' + this.name + '_body" class="w2ui-grid-body"></div>    <div id="grid_' + this.name + '_fsummary" class="w2ui-grid-body w2ui-grid-summary"></div>    <div id="grid_' + this.name + '_summary" class="w2ui-grid-body w2ui-grid-summary"></div>    <div id="grid_' + this.name + '_footer" class="w2ui-grid-footer"></div>    <textarea id="grid_' + this.name + '_focus" class="w2ui-grid-focus-input" ' + (this.tabIndex ? 'tabindex="' + this.tabIndex + '"' : "") + (b.isIOS ? "readonly" : "") + "></textarea></div>"), this.selectType != "row" && p(this.box).addClass("w2ui-ss"), 0 < p(this.box).length && (p(this.box)[0].style.cssText += this.style), this.initToolbar(), this.toolbar != null && this.toolbar.render(p(this.box).find("#grid_" + this.name + "_toolbar")[0]), this.last.toolbar_height = p(this.box).find(`#grid_${this.name}_toolbar`).prop("offsetHeight"), this.last.field && this.last.field != "all") {
        let h = this.searchData;
        setTimeout(() => {
          this.searchInitInput(this.last.field, h.length == 1 ? h[0].value : null);
        }, 1);
      }
      p(this.box).find(`#grid_${this.name}_footer`).html(this.getFooterHTML()), this.last.state || (this.last.state = this.stateSave(true)), this.stateRestore(), e && (this.clear(), this.refresh());
      let l = false;
      for (let h = 0; h < this.searches.length; h++) if (this.searches[h].hidden) {
        l = true;
        break;
      }
      l ? (this.searchReset(false), e || setTimeout(() => {
        this.searchReset();
      }, 1)) : this.reload(), p(this.box).find(`#grid_${this.name}_focus`).on("focus", (h) => {
        clearTimeout(this.last.kbd_timer), this.hasFocus || this.focus();
      }).on("blur", (h) => {
        clearTimeout(this.last.kbd_timer), this.last.kbd_timer = setTimeout(() => {
          this.hasFocus && this.blur();
        }, 100);
      }).on("paste", (h) => {
        var d = h.clipboardData || null;
        if (d) {
          let m = d.items, _ = [];
          for (var u in m = m.length == 2 && (m = m.length == 2 && m[1].kind == "file" ? [m[1]] : m).length == 2 && m[0].type == "text/plain" && m[1].type == "text/html" ? [m[1]] : m) if (u = m[u], u.kind === "file") {
            var f = u.getAsFile();
            _.push({ kind: "file", data: f });
          } else if (u.kind === "string" && (u.type === "text/plain" || u.type === "text/html")) {
            h.preventDefault();
            let g = d.getData("text/plain");
            g.indexOf("\r") != -1 && g.indexOf(`
`) == -1 && (g = g.replace(/\r/g, `
`)), _.push({ kind: u.type == "text/html" ? "html" : "text", data: g });
          }
          _.length === 1 && _[0].kind != "file" && (_ = _[0].data), on[this.name].paste(_, h), h.preventDefault();
        }
      }).on("keydown", function(h) {
        on[i.name].keydown.call(on[i.name], h);
      });
      let c;
      return p(this.box).off("mousedown.mouseStart").on("mousedown.mouseStart", function(h) {
        if (h.which == 1 && (i.last.userSelect == "text" && (i.last.userSelect = "", p(i.box).find(".w2ui-grid-body").css("user-select", "none")), !(i.selectType == "row" && (p(h.target).parents().hasClass("w2ui-head") || p(h.target).hasClass("w2ui-head")) || i.last.move && i.last.move.type == "expand"))) {
          if (h.altKey) p(i.box).find(".w2ui-grid-body").css("user-select", "text"), i.selectNone(), i.last.move = { type: "text-select" }, i.last.userSelect = "text";
          else {
            let v = h.target;
            var d = { x: h.offsetX - 10, y: h.offsetY - 10 };
            let y = false;
            for (; v && (!v.classList || !v.classList.contains("w2ui-grid")); ) v.tagName && v.tagName.toUpperCase() == "TD" && (y = true), v.tagName && v.tagName.toUpperCase() != "TR" && y == 1 && (d.x += v.offsetLeft, d.y += v.offsetTop), v = v.parentNode;
            i.last.move = { x: h.screenX, y: h.screenY, divX: 0, divY: 0, focusX: d.x, focusY: d.y, recid: p(h.target).parents("tr").attr("recid"), column: parseInt((h.target.tagName.toUpperCase() == "TD" ? p(h.target) : p(h.target).parents("td")).attr("col")), type: "select", ghost: false, start: true }, i.last.move.recid == null && (i.last.move.type = "select-column");
            let x = h.target, S = p(i.box).find("#grid_" + i.name + "_focus");
            if (i.last.move) {
              let A = i.last.move.focusX, R = i.last.move.focusY;
              var u = p(x).parents("table").parent();
              (u.hasClass("w2ui-grid-records") || u.hasClass("w2ui-grid-frecords") || u.hasClass("w2ui-grid-columns") || u.hasClass("w2ui-grid-fcolumns") || u.hasClass("w2ui-grid-summary")) && (A = i.last.move.focusX - p(i.box).find("#grid_" + i.name + "_records").prop("scrollLeft"), R = i.last.move.focusY - p(i.box).find("#grid_" + i.name + "_records").prop("scrollTop")), (p(x).hasClass("w2ui-grid-footer") || 0 < p(x).parents("div.w2ui-grid-footer").length) && (R = p(i.box).find("#grid_" + i.name + "_footer").get(0).offsetTop), u.hasClass("w2ui-scroll-wrapper") && u.parent().hasClass("w2ui-toolbar") && (A = i.last.move.focusX - u.prop("scrollLeft")), S.css({ left: A - 10, top: R });
            }
            setTimeout(() => {
              var _a2;
              i.last.inEditMode || (["INPUT", "TEXTAREA", "SELECT"].includes(x.tagName) ? x.focus() : S.get(0) !== document.active && ((_a2 = S.get(0)) == null ? void 0 : _a2.focus({ preventScroll: true })));
            }, 50), i.multiSelect || i.reorderRows || i.last.move.type != "drag" || delete i.last.move;
          }
          if (i.reorderRows == 1) {
            let v = h.target;
            var f, m, _, g;
            v.tagName.toUpperCase() != "TD" && (v = p(v).parents("td")[0]), p(v).hasClass("w2ui-col-number") || p(v).hasClass("w2ui-col-order") ? (i.selectNone(), i.last.move.reorder = true, u = p(i.box).find(".w2ui-even.w2ui-empty-record").css("background-color"), f = p(i.box).find(".w2ui-odd.w2ui-empty-record").css("background-color"), p(i.box).find(".w2ui-even td").filter(":not(.w2ui-col-number)").css("background-color", u), p(i.box).find(".w2ui-odd td").filter(":not(.w2ui-col-number)").css("background-color", f), f = i.last.move, m = p(i.box).find(".w2ui-grid-records"), f.ghost || (_ = p(i.box).find(`#grid_${i.name}_rec_` + f.recid), g = _.parents("table").find("tr:first-child").get(0).cloneNode(true), f.offsetY = h.offsetY, f.from = f.recid, f.pos = { top: _.get(0).offsetTop - 1, left: _.get(0).offsetLeft }, f.ghost = p(_.get(0).cloneNode(true)), f.ghost.removeAttr("id"), f.ghost.find("td").css({ "border-top": "1px solid silver", "border-bottom": "1px solid silver" }), _.find("td").remove(), _.append(`<td colspan="1000"><div class="w2ui-reorder-empty" style="height: ${i.recordHeight - 2}px"></div></td>`), m.append('<div id="grid_' + i.name + '_ghost_line" style="position: absolute; z-index: 999999; pointer-events: none; width: 100%;"></div>'), m.append('<table id="grid_' + i.name + '_ghost" style="position: absolute; z-index: 999998; opacity: 0.9; pointer-events: none;"></table>'), p(i.box).find("#grid_" + i.name + "_ghost").append(g).append(f.ghost)), p(i.box).find("#grid_" + i.name + "_ghost").css({ top: f.pos.top + "px", left: f.pos.left + "px" })) : i.last.move.reorder = false;
          }
          p(document).on("mousemove.w2ui-" + i.name, r).on("mouseup.w2ui-" + i.name, o), h.stopPropagation();
        }
      }), this.updateToolbar(), n.finish(), this.last.observeResize = new ResizeObserver(() => {
        this.resize();
      }), this.last.observeResize.observe(this.box), Date.now() - t;
    }
  }
  destroy() {
    var _a2;
    var e = this.trigger("destroy", { target: this.name });
    e.isCancelled !== true && (p(this.box).off(), typeof this.toolbar == "object" && this.toolbar.destroy && this.toolbar.destroy(), 0 < p(this.box).find(`#grid_${this.name}_body`).length && p(this.box).removeAttr("name").removeClass("w2ui-reset w2ui-grid w2ui-inactive").html(""), (_a2 = this.last.observeResize) == null ? void 0 : _a2.disconnect(), delete on[this.name], e.finish());
  }
  initColumnOnOff() {
    var e, t = [{ id: "line-numbers", text: "Line #", checked: this.show.lineNumbers }];
    for (let r = 0; r < this.columns.length; r++) {
      var i = this.columns[r];
      let o = this.columns[r].text;
      i.hideable !== false && (o = (o = !o && this.columns[r].tooltip ? this.columns[r].tooltip : o) || "- column " + (parseInt(r) + 1) + " -", t.push({ id: i.field, text: b.stripTags(o), checked: !i.hidden }));
    }
    ((typeof this.url != "object" ? this.url : this.url.get) && this.show.skipRecords || this.show.saveRestoreState) && t.push({ text: "--" }), this.show.skipRecords && (e = b.lang("Skip") + `<input id="${this.name}_skip" type="text" class="w2ui-input w2ui-grid-skip" value="${this.offset}">` + b.lang("records"), t.push({ id: "w2ui-skip", text: e, group: false, icon: "w2ui-icon-empty" })), this.show.saveRestoreState && t.push({ id: "w2ui-stateSave", text: b.lang("Save Grid State"), icon: "w2ui-icon-empty", group: false }, { id: "w2ui-stateReset", text: b.lang("Restore Default State"), icon: "w2ui-icon-empty", group: false });
    let n = [];
    return t.forEach((r) => {
      r.text = b.lang(r.text), r.checked && n.push(r.id);
    }), this.toolbar.set("w2ui-column-on-off", { selected: n, items: t }), t;
  }
  initColumnDrag(e) {
    if (this.columnGroups && this.columnGroups.length) throw "Draggable columns are not currently supported with column groups.";
    let t = this, i = { pressed: false, targetPos: null, columnHead: null }, n = (a, l) => {
      var c = ["w2ui-col-number", "w2ui-col-expand", "w2ui-col-select"];
      l !== true && c.push("w2ui-head-last");
      for (let h = 0; h < c.length; h++) if (p(a).closest(".w2ui-head").hasClass(c[h])) return true;
      return false;
    };
    function r(a) {
      var l, c, h, d;
      i.pressed && i.columnHead && (l = a.pageX, c = a.pageY, n(a.target, true) || (a = a, p(a.target).closest("td").length != 0 && (d = p(t.box).find(".w2ui-grid-body").get(0).getBoundingClientRect(), h = p(a.target).closest("td").get(0).getBoundingClientRect(), p(t.box).find(".w2ui-intersection-marker").show().css({ left: h.left - d.left + "px" }), h = p(a.target).closest("td"), i.targetPos = h.hasClass("w2ui-head-last") ? t.columns.length : parseInt(h.attr("col")))), d = l, a = c, p(i.ghost).css({ left: d - 10 + "px", top: a - 10 + "px" }).show());
    }
    function o(a) {
      if (i.pressed && i.columnHead) {
        i.pressed = false;
        var l, c, h = () => {
          var d = p(t.box).find(".w2ui-grid-ghost");
          p(t.box).find(".w2ui-intersection-marker").hide(), p(i.ghost).remove(), d.remove(), p(document).off(".colDrag"), i = {};
        };
        if (a.pageX == i.initialX && a.pageY == i.initialY) t.columnClick(t.columns[i.originalPos].field, a), h();
        else {
          if ((a = t.trigger("columnDragEnd", { originalEvent: a, target: i.columnHead[0], dragData: i })).isCancelled === true) return false;
          l = t.columns[i.originalPos], c = t.columns, i.originalPos != i.targetPos && i.targetPos != null && (c.splice(i.targetPos, 0, b.clone(l)), c.splice(c.indexOf(l), 1)), h(), t.refresh(), a.finish({ targetColumn: NaN });
        }
      }
    }
    return p(t.box).off(".colDrag").on("mousedown.colDrag", function(a) {
      if (!i.pressed && i.numberPreColumnsPresent !== 0 && a.button === 0) {
        var l, c;
        if (p(a.target).parents().hasClass("w2ui-head") && !n(a.target)) {
          if (i.pressed = true, i.initialX = a.pageX, i.initialY = a.pageY, i.numberPreColumnsPresent = p(t.box).find(".w2ui-head.w2ui-col-number, .w2ui-head.w2ui-col-expand, .w2ui-head.w2ui-col-select").length, i.columnHead = h = p(a.target).closest(".w2ui-head"), i.originalPos = c = parseInt(h.attr("col"), 10), (c = t.trigger("columnDragStart", { originalEvent: a, origColumnNumber: c, target: h[0] })).isCancelled === true) return false;
          l = i.columns = p(t.box).find(".w2ui-head:not(.w2ui-head-last)"), p(document).on("mouseup.colDrag", o), p(document).on("mousemove.colDrag", r);
          var h = t.columns[i.originalPos], h = b.lang(typeof h.text == "function" ? h.text(h) : h.text);
          i.ghost = p.html(`<span col="${i.originalPos}">${h}</span>`)[0], p(document.body).append(i.ghost), p(i.ghost).css({ display: "none", left: a.pageX, top: a.pageY, opacity: 1, margin: "3px 0 0 20px", padding: "3px", "background-color": "white", position: "fixed", "z-index": 999999 }).addClass(".w2ui-grid-ghost"), i.offsets = [];
          for (let u = 0, f = l.length; u < f; u++) {
            var d = l[u].getBoundingClientRect();
            i.offsets.push(d.left);
          }
          c.finish();
        }
      }
    }), { remove() {
      p(t.box).off(".colDrag"), t.last.columnDrag = false;
    } };
  }
  columnOnOff(e, t) {
    if (e = this.trigger("columnOnOff", { target: this.name, field: t, originalEvent: e }), e.isCancelled !== true) {
      var i = this.find({ "w2ui.expanded": true }, true);
      for (let r = 0; r < i.length; r++) {
        var n = this.records[r].w2ui;
        n && !Array.isArray(n.children) && (this.records[r].w2ui.expanded = false);
      }
      t == "line-numbers" ? (this.show.lineNumbers = !this.show.lineNumbers, this.refresh()) : (t = this.getColumn(t)).hidden ? this.showColumn(t.field) : this.hideColumn(t.field), e.finish();
    }
  }
  initToolbar() {
    if (this.toolbar.render == null) {
      let t = this.toolbar.items || [];
      var e;
      this.toolbar.items = [], this.toolbar = new xM(b.extend({}, this.toolbar, { name: this.name + "_toolbar", owner: this })), this.show.toolbarReload && this.toolbar.items.push(b.extend({}, this.buttons.reload)), this.show.toolbarColumns && this.toolbar.items.push(b.extend({}, this.buttons.columns)), this.show.toolbarSearch && (e = `
                <div class="w2ui-grid-search-input">
                    ${this.buttons.search.html}
                    <div id="grid_${this.name}_search_name" class="w2ui-grid-search-name">
                        <span class="name-icon w2ui-icon-search"></span>
                        <span class="name-text"></span>
                        <span class="name-cross w2ui-action" data-click="searchReset">x</span>
                    </div>
                    <input type="text" id="grid_${this.name}_search_all" class="w2ui-search-all" tabindex="-1"
                        autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false"
                        placeholder="${b.lang(this.last.label, true)}" value="${this.last.search}"
                        data-focus="searchSuggest" data-click="stop"
                    >
                    <div class="w2ui-search-drop w2ui-action" data-click="searchOpen"
                            style="${this.multiSearch ? "" : "display: none"}">
                        <span class="w2ui-icon-drop"></span>
                    </div>
                </div>`, this.toolbar.items.push({ id: "w2ui-search", type: "html", html: e, onRefresh: async (n) => {
        await n.complete;
        var n = p(this.box).find(`#grid_${this.name}_search_all`), r = (b.bindEvents(p(this.box).find(`#grid_${this.name}_search_all, .w2ui-action`), this), b.debounce((o) => {
          var a = o.target.value;
          this.liveSearch && this.last.liveText != a && (this.last.liveText = a, this.search(this.last.field, a)), o.keyCode == 40 && this.searchSuggest(true);
        }, 250));
        n.on("change", (o) => {
          this.liveSearch || (this.search(this.last.field, o.target.value), this.searchSuggest(true, true, this));
        }).on("blur", () => {
          this.last.liveText = "";
        }).on("keyup", r);
      } })), Array.isArray(t) && (e = t.map((i) => i.id), this.show.toolbarAdd && !e.includes(this.buttons.add.id) && this.toolbar.items.push(b.extend({}, this.buttons.add)), this.show.toolbarEdit && !e.includes(this.buttons.edit.id) && this.toolbar.items.push(b.extend({}, this.buttons.edit)), this.show.toolbarDelete && !e.includes(this.buttons.delete.id) && this.toolbar.items.push(b.extend({}, this.buttons.delete)), this.show.toolbarSave && !e.includes(this.buttons.save.id) && ((this.show.toolbarAdd || this.show.toolbarDelete || this.show.toolbarEdit) && this.toolbar.items.push({ type: "break", id: "w2ui-break2" }), this.toolbar.items.push(b.extend({}, this.buttons.save))), t = t.map((i) => this.buttons[i.name] ? b.extend({}, this.buttons[i.name], i) : i)), this.toolbar.items.push(...t), this.toolbar.on("click", (i) => {
        var n = this.trigger("toolbar", { target: i.target, originalEvent: i });
        if (n.isCancelled !== true) {
          let o;
          switch (i.detail.item.id) {
            case "w2ui-reload":
              if ((o = this.trigger("reload", { target: this.name })).isCancelled === true) return false;
              this.reload(), o.finish();
              break;
            case "w2ui-column-on-off":
              i.detail.subItem ? (r = i.detail.subItem.id, ["w2ui-stateSave", "w2ui-stateReset"].includes(r) ? this[r.substring(5)]() : r != "w2ui-skip" && this.columnOnOff(i, i.detail.subItem.id)) : (this.initColumnOnOff(), setTimeout(() => {
                p(`#w2overlay-${this.name}_toolbar-drop .w2ui-grid-skip`).off(".w2ui-grid").on("click.w2ui-grid", (a) => {
                  a.stopPropagation();
                }).on("keypress", (a) => {
                  a.keyCode == 13 && (this.skip(a.target.value), this.toolbar.click("w2ui-column-on-off"));
                });
              }, 100));
              break;
            case "w2ui-add":
              if ((o = this.trigger("add", { target: this.name, recid: null })).isCancelled === true) return false;
              o.finish();
              break;
            case "w2ui-edit": {
              var r = this.getSelection();
              let a = null;
              if (r.length == 1 && (a = r[0]), (o = this.trigger("edit", { target: this.name, recid: a })).isCancelled === true) return false;
              o.finish();
              break;
            }
            case "w2ui-delete":
              this.delete();
              break;
            case "w2ui-save":
              this.save();
          }
          n.finish();
        }
      }), this.toolbar.on("refresh", (i) => {
        if (i.target == "w2ui-search") {
          let n = this.searchData;
          setTimeout(() => {
            this.searchInitInput(this.last.field, n.length == 1 ? n[0].value : null);
          }, 1);
        }
      });
    }
  }
  initResize() {
    let e = this;
    p(this.box).find(".w2ui-resizer").off(".grid-col-resize").on("click.grid-col-resize", function(t) {
      t.stopPropagation ? t.stopPropagation() : t.cancelBubble = true, t.preventDefault && t.preventDefault();
    }).on("mousedown.grid-col-resize", function(t) {
      t = t || window.event, e.last.colResizing = true, e.last.tmp = { x: t.screenX, y: t.screenY, gx: t.screenX, gy: t.screenY, col: parseInt(p(this).attr("name")) }, e.last.tmp.tds = p(e.box).find("#grid_" + e.name + '_body table tr:first-child td[col="' + e.last.tmp.col + '"]'), t.stopPropagation ? t.stopPropagation() : t.cancelBubble = true, t.preventDefault && t.preventDefault();
      for (let r = 0; r < e.columns.length; r++) e.columns[r].hidden || (e.columns[r].sizeOriginal == null && (e.columns[r].sizeOriginal = e.columns[r].size), e.columns[r].size = e.columns[r].sizeCalculated);
      let i = { phase: "before", type: "columnResize", target: e.name, column: e.last.tmp.col, field: e.columns[e.last.tmp.col].field };
      i = e.trigger(b.extend(i, { resizeBy: 0, originalEvent: t }));
      let n;
      p(document).off(".grid-col-resize").on("mousemove.grid-col-resize", function(r) {
        var o;
        e.last.colResizing == 1 && (r = r || window.event, (i = e.trigger(b.extend(i, { resizeBy: r.screenX - e.last.tmp.gx, originalEvent: r }))).isCancelled === true ? i.isCancelled = false : (e.last.tmp.x = r.screenX - e.last.tmp.x, e.last.tmp.y = r.screenY - e.last.tmp.y, o = parseInt(e.columns[e.last.tmp.col].size) + e.last.tmp.x + "px", e.columns[e.last.tmp.col].size = o, n && clearTimeout(n), n = setTimeout(() => {
          e.resizeRecords(), e.scroll();
        }, 100), e.last.tmp.tds.css({ width: o }), e.last.tmp.x = r.screenX, e.last.tmp.y = r.screenY));
      }).on("mouseup.grid-col-resize", function(r) {
        p(document).off(".grid-col-resize"), e.resizeRecords(), e.scroll(), i.finish({ originalEvent: r }), setTimeout(() => {
          e.last.colResizing = false;
        }, 1);
      });
    }).on("dblclick.grid-col-resize", function(t) {
      let i = parseInt(p(this).attr("name")), n = e.columns[i], r = 0;
      if (n.autoResize === false) return true;
      t.stopPropagation ? t.stopPropagation() : t.cancelBubble = true, t.preventDefault && t.preventDefault(), p(e.box).find('.w2ui-grid-records td[col="' + i + '"] > div', e.box).each(() => {
        var a = this.offsetWidth - this.scrollWidth;
        a < r && (r = a - 3);
      });
      var o = { phase: "before", type: "columnAutoResize", target: e.name, column: n, field: n.field };
      (o = e.trigger(b.extend(o, { resizeBy: Math.abs(r), originalEvent: t }))).isCancelled === true ? o.isCancelled = false : (r < 0 && (n.size = Math.min(parseInt(n.size) + Math.abs(r), n.max || 1 / 0) + "px", e.resizeRecords(), e.resizeRecords(), e.scroll()), o.finish({ originalEvent: t }));
    }).each((t) => {
      var i = p(t).get(0).parentNode;
      p(t).css({ height: i.clientHeight + "px", "margin-left": i.clientWidth - 3 + "px" });
    });
  }
  resizeBoxes() {
    var e = p(this.box).find(`#grid_${this.name}_header`), t = p(this.box).find(`#grid_${this.name}_toolbar`), i = p(this.box).find(`#grid_${this.name}_fsummary`), n = p(this.box).find(`#grid_${this.name}_summary`), r = p(this.box).find(`#grid_${this.name}_footer`), o = p(this.box).find(`#grid_${this.name}_body`);
    this.show.header && e.css({ top: "0px", left: "0px", right: "0px" }), this.show.toolbar && t.css({ top: 0 + (this.show.header ? b.getSize(e, "height") : 0) + "px", left: "0px", right: "0px" }), 0 < this.summary.length && (i.css({ bottom: 0 + (this.show.footer ? b.getSize(r, "height") : 0) + "px" }), n.css({ bottom: 0 + (this.show.footer ? b.getSize(r, "height") : 0) + "px", right: "0px" })), this.show.footer && r.css({ bottom: "0px", left: "0px", right: "0px" }), o.css({ top: 0 + (this.show.header ? b.getSize(e, "height") : 0) + (this.show.toolbar ? b.getSize(t, "height") : 0) + "px", bottom: 0 + (this.show.footer ? b.getSize(r, "height") : 0) + (0 < this.summary.length ? b.getSize(n, "height") : 0) + "px", left: "0px", right: "0px" });
  }
  resizeRecords() {
    var _a2, _b2, _c2, _d2, _e, _f2;
    let e = this;
    p(this.box).find(".w2ui-empty-record").remove();
    var t, i, n = p(this.box), r = p(this.box).find(":scope > div.w2ui-grid-box"), o = p(this.box).find(`#grid_${this.name}_header`), a = p(this.box).find(`#grid_${this.name}_toolbar`), l = p(this.box).find(`#grid_${this.name}_summary`), c = p(this.box).find(`#grid_${this.name}_fsummary`), h = p(this.box).find(`#grid_${this.name}_footer`), d = p(this.box).find(`#grid_${this.name}_body`), u = p(this.box).find(`#grid_${this.name}_columns`), f = p(this.box).find(`#grid_${this.name}_fcolumns`), m = p(this.box).find(`#grid_${this.name}_records`), _ = p(this.box).find(`#grid_${this.name}_frecords`), g = p(this.box).find(`#grid_${this.name}_scroll1`);
    let v = 8 * String(this.total).length + 10, y = (v < 34 && (v = 34), this.lineNumberWidth != null && (v = this.lineNumberWidth), false), x = false, S = 0;
    for (let O = 0; O < this.columns.length; O++) this.columns[O].frozen || this.columns[O].hidden || (t = parseInt(this.columns[O].sizeCalculated || this.columns[O].size), S += t);
    ((_a2 = m[0]) == null ? void 0 : _a2.clientWidth) < S && (y = true), ((_b2 = d[0]) == null ? void 0 : _b2.clientHeight) - (((_c2 = u[0]) == null ? void 0 : _c2.clientHeight) ?? 0) < (((_d2 = p(m).find(":scope > table")[0]) == null ? void 0 : _d2.clientHeight) ?? 0) + (y ? b.scrollBarSize() : 0) && (x = true), this.fixedBody ? (i = ((_e = r[0]) == null ? void 0 : _e.clientHeight) - (this.show.header ? b.getSize(o, "height") : 0) - (this.show.toolbar ? b.getSize(a, "height") : 0) - (l.css("display") != "none" ? b.getSize(l, "height") : 0) - (this.show.footer ? b.getSize(h, "height") : 0), d.css("height", i + "px")) : (o = (i = b.getSize(u, "height") + b.getSize(p(this.box).find("#grid_" + this.name + "_records table"), "height") + (y ? b.scrollBarSize() : 0)) + (this.show.header ? b.getSize(o, "height") : 0) + (this.show.toolbar ? b.getSize(a, "height") : 0) + (l.css("display") != "none" ? b.getSize(l, "height") : 0) + (this.show.footer ? b.getSize(h, "height") : 0), r.css("height", o + "px"), d.css("height", i + "px"), n.css("height", b.getSize(r, "height") + "px"));
    let A = this.records.length;
    if (a = typeof this.url != "object" ? this.url : this.url.get, this.searchData.length == 0 || a || (A = this.last.searchIds.length), this.fixedBody || (x = false), y || x ? (u.find(":scope > table > tbody > tr:nth-child(1) td.w2ui-head-last").css("width", b.scrollBarSize() + "px").show(), m.css({ top: (0 < this.columnGroups.length && this.show.columns ? 1 : 0) + b.getSize(u, "height") + "px", "-webkit-overflow-scrolling": "touch", "overflow-x": y ? "auto" : "hidden", "overflow-y": x ? "auto" : "hidden" })) : (u.find(":scope > table > tbody > tr:nth-child(1) td.w2ui-head-last").hide(), m.css({ top: (0 < this.columnGroups.length && this.show.columns ? 1 : 0) + b.getSize(u, "height") + "px", overflow: "hidden" }), 0 < m.length && (this.last.scrollTop = 0, this.last.scrollLeft = 0)), y ? (_.css("margin-bottom", b.scrollBarSize() + "px"), g.show()) : (_.css("margin-bottom", 0), g.hide()), _.css({ overflow: "hidden", top: m.css("top") }), this.show.emptyRecords && !x) {
      let O = Math.floor((((_f2 = m[0]) == null ? void 0 : _f2.clientHeight) ?? 0) / this.recordHeight) - 1, Q = 0;
      if ((Q = m[0] ? m[0].scrollHeight - O * this.recordHeight : Q) >= this.recordHeight && (Q -= this.recordHeight, O++), this.fixedBody) {
        for (let X = A; X < O; X++) R(X, this.recordHeight, this);
        R(O, Q, this);
      }
    }
    function R(O, Q, X) {
      let K = "", Le = "";
      var Re;
      K += '<tr class="' + (O % 2 ? "w2ui-even" : "w2ui-odd") + ' w2ui-empty-record" recid="-none-" style="height: ' + Q + 'px">', Le += '<tr class="' + (O % 2 ? "w2ui-even" : "w2ui-odd") + ' w2ui-empty-record" recid="-none-" style="height: ' + Q + 'px">', X.show.lineNumbers && (K += '<td class="w2ui-col-number"></td>'), X.show.selectColumn && (K += '<td class="w2ui-grid-data w2ui-col-select"></td>'), X.show.expandColumn && (K += '<td class="w2ui-grid-data w2ui-col-expand"></td>'), Le += '<td class="w2ui-grid-data-spacer" col="start" style="border-right: 0"></td>', X.reorderRows && (Le += '<td class="w2ui-grid-data w2ui-col-order" col="order"></td>');
      for (let se = 0; se < X.columns.length; se++) {
        var Y = X.columns[se];
        (Y.hidden || se < X.last.colStart || se > X.last.colEnd) && !Y.frozen || (Re = '<td class="w2ui-grid-data" ' + (Y.attr != null ? Y.attr : "") + ' col="' + se + '"></td>', Y.frozen ? K += Re : Le += Re);
      }
      K += '<td class="w2ui-grid-data-last"></td> </tr>', Le += '<td class="w2ui-grid-data-last" col="end"></td> </tr>', p(X.box).find("#grid_" + X.name + "_frecords > table").append(K), p(X.box).find("#grid_" + X.name + "_records > table").append(Le);
    }
    let C, P;
    if (0 < d.length) {
      let O = parseInt(d[0].clientWidth) - (x ? b.scrollBarSize() : 0) - (this.show.lineNumbers ? v : 0) - (this.reorderRows ? 26 : 0) - (this.show.selectColumn ? 26 : 0) - (this.show.expandColumn ? 26 : 0) - 1, Q = (C = O, false);
      for (let X = P = 0; X < this.columns.length; X++) {
        var z = this.columns[X];
        0 < z.gridMinWidth && (z.gridMinWidth > C && z.hidden !== true && (z.hidden = true, Q = true), z.gridMinWidth < C) && z.hidden === true && (z.hidden = false, Q = true);
      }
      if (Q === true) return void this.refresh();
      for (let X = 0; X < this.columns.length; X++) {
        var w = this.columns[X];
        w.hidden || (String(w.size).substr(String(w.size).length - 2).toLowerCase() == "px" ? (O -= parseFloat(w.size), this.columns[X].sizeCalculated = w.size, this.columns[X].sizeType = "px") : (P += parseFloat(w.size), this.columns[X].sizeType = "%", delete w.sizeCorrected));
      }
      if (P != 100 && 0 < P) for (let X = 0; X < this.columns.length; X++) {
        var E = this.columns[X];
        E.hidden || E.sizeType == "%" && (E.sizeCorrected = Math.round(100 * parseFloat(E.size) * 100 / P) / 100 + "%");
      }
      for (let X = 0; X < this.columns.length; X++) {
        var N = this.columns[X];
        N.hidden || N.sizeType == "%" && (this.columns[X].sizeCorrected != null ? this.columns[X].sizeCalculated = Math.floor(O * parseFloat(N.sizeCorrected) / 100) - 1 + "px" : this.columns[X].sizeCalculated = Math.floor(O * parseFloat(N.size) / 100) - 1 + "px");
      }
    }
    let k = 0;
    for (let O = 0; O < this.columns.length; O++) {
      var V = this.columns[O];
      V.hidden || (V.min == null && (V.min = 20), parseInt(V.sizeCalculated) < parseInt(V.min) && (V.sizeCalculated = V.min + "px"), parseInt(V.sizeCalculated) > parseInt(V.max) && (V.sizeCalculated = V.max + "px"), k += parseInt(V.sizeCalculated));
    }
    let q = parseInt(C) - parseInt(k);
    if (0 < q && 0 < P) {
      let O = 0;
      for (; ; ) {
        var G = this.columns[O];
        if (G == null) O = 0;
        else {
          if (!G.hidden && G.sizeType != "px" && (G.sizeCalculated = parseInt(G.sizeCalculated) + 1 + "px", --q === 0)) break;
          O++;
        }
      }
    } else 0 < q && u.find(":scope > table > tbody > tr:nth-child(1) td.w2ui-head-last").css("width", b.scrollBarSize() + "px").show();
    let ee = 1;
    this.show.lineNumbers && (ee += v), this.show.selectColumn && (ee += 26), this.show.expandColumn && (ee += 26);
    for (let O = 0; O < this.columns.length; O++) this.columns[O].hidden || this.columns[O].frozen && (ee += parseInt(this.columns[O].sizeCalculated));
    f.css("width", ee + "px"), _.css("width", ee + "px"), c.css("width", ee + "px"), g.css("width", ee + "px"), u.css("left", ee + "px"), m.css("left", ee + "px"), l.css("left", ee + "px"), u.find(":scope > table > tbody > tr:nth-child(1) td").add(f.find(":scope > table > tbody > tr:nth-child(1) td")).each((O) => {
      p(O).hasClass("w2ui-col-number") && p(O).css("width", v + "px");
      var Q = p(O).attr("col");
      if (Q != null) {
        if (Q == "start") {
          let X = 0;
          for (let K = 0; K < e.last.colStart; K++) !e.columns[K] || e.columns[K].frozen || e.columns[K].hidden || (X += parseInt(e.columns[K].sizeCalculated));
          p(O).css("width", X + "px");
        }
        e.columns[Q] && p(O).css("width", e.columns[Q].sizeCalculated);
      }
      if (p(O).hasClass("w2ui-head-last")) if (e.last.colEnd + 1 < e.columns.length) {
        let X = 0;
        for (let K = e.last.colEnd + 1; K < e.columns.length; K++) !e.columns[K] || e.columns[K].frozen || e.columns[K].hidden || (X += parseInt(e.columns[K].sizeCalculated));
        p(O).css("width", X + "px");
      } else p(O).css("width", b.scrollBarSize() + (0 < q && P === 0 ? q : 0) + "px");
    }), u.find(":scope > table > tbody > tr").length == 3 && u.find(":scope > table > tbody > tr:nth-child(1) td").add(f.find(":scope > table > tbody > tr:nth-child(1) td")).html("").css({ height: "0", border: "0", padding: "0", margin: "0" }), m.find(":scope > table > tbody > tr:nth-child(1) td").add(_.find(":scope > table > tbody > tr:nth-child(1) td")).each((O) => {
      p(O).hasClass("w2ui-col-number") && p(O).css("width", v + "px");
      var Q = p(O).attr("col");
      if (Q != null) {
        if (Q == "start") {
          let X = 0;
          for (let K = 0; K < e.last.colStart; K++) !e.columns[K] || e.columns[K].frozen || e.columns[K].hidden || (X += parseInt(e.columns[K].sizeCalculated));
          p(O).css("width", X + "px");
        }
        e.columns[Q] && p(O).css("width", e.columns[Q].sizeCalculated);
      }
      if (p(O).hasClass("w2ui-grid-data-last") && p(O).parents(".w2ui-grid-frecords").length === 0) if (e.last.colEnd + 1 < e.columns.length) {
        let X = 0;
        for (let K = e.last.colEnd + 1; K < e.columns.length; K++) !e.columns[K] || e.columns[K].frozen || e.columns[K].hidden || (X += parseInt(e.columns[K].sizeCalculated));
        p(O).css("width", X + "px");
      } else p(O).css("width", (0 < q && P === 0 ? q : 0) + "px");
    }), l.find(":scope > table > tbody > tr:nth-child(1) td").add(c.find(":scope > table > tbody > tr:nth-child(1) td")).each((O) => {
      p(O).hasClass("w2ui-col-number") && p(O).css("width", v + "px");
      var Q = p(O).attr("col");
      if (Q != null) {
        if (Q == "start") {
          let X = 0;
          for (let K = 0; K < e.last.colStart; K++) !e.columns[K] || e.columns[K].frozen || e.columns[K].hidden || (X += parseInt(e.columns[K].sizeCalculated));
          p(O).css("width", X + "px");
        }
        e.columns[Q] && p(O).css("width", e.columns[Q].sizeCalculated);
      }
      p(O).hasClass("w2ui-grid-data-last") && p(O).parents(".w2ui-grid-frecords").length === 0 && p(O).css("width", b.scrollBarSize() + (0 < q && P === 0 ? q : 0) + "px");
    }), this.initResize(), this.refreshRanges(), (this.last.scrollTop || this.last.scrollLeft) && 0 < m.length && (u.prop("scrollLeft", this.last.scrollLeft), m.prop("scrollTop", this.last.scrollTop), m.prop("scrollLeft", this.last.scrollLeft)), u.css("will-change", "scroll-position");
  }
  getSearchesHTML() {
    let e = `
            <div class="search-title">
                ${b.lang("Advanced Search")}
                <span class="search-logic" style="${this.show.searchLogic ? "" : "display: none"}">
                    <select id="grid_${this.name}_logic" class="w2ui-input">
                        <option value="AND" ${this.last.logic == "AND" ? "selected" : ""}>${b.lang("All")}</option>
                        <option value="OR" ${this.last.logic == "OR" ? "selected" : ""}>${b.lang("Any")}</option>
                    </select>
                </span>
            </div>
            <table cellspacing="0"><tbody>
        `;
    for (let n = 0; n < this.searches.length; n++) {
      var t = this.searches[n];
      if (t.type = String(t.type).toLowerCase(), !t.hidden) {
        t.attr == null && (t.attr = ""), t.text == null && (t.text = ""), t.style == null && (t.style = ""), t.type == null && (t.type = "text"), t.label == null && t.caption != null && (console.log("NOTICE: grid search.caption property is deprecated, please use search.label. Search ->", t), t.label = t.caption);
        var i = `<select id="grid_${this.name}_operator_${n}" class="w2ui-input" data-change="initOperator|${n}">
                    ${this.getOperators(t.type, t.operators)}
                </select>`;
        e += `<tr>
                        <td class="caption">${b.lang(t.label) || ""}</td>
                        <td class="operator">${i}</td>
                        <td class="value">`;
        let r;
        switch (t.type) {
          case "text":
          case "alphanumeric":
          case "hex":
          case "color":
          case "list":
          case "combo":
          case "enum":
            r = "width: 250px;", ["hex", "color"].indexOf(t.type) != -1 && (r = "width: 90px;"), e += `<input rel="search" type="text" id="grid_${this.name}_field_${n}" name="${t.field}"
                               class="w2ui-input" style="${r + t.style}" ${t.attr}>`;
            break;
          case "int":
          case "float":
          case "money":
          case "currency":
          case "percent":
          case "date":
          case "time":
          case "datetime":
            r = "width: 90px;", t.type == "datetime" && (r = "width: 140px;"), e += `<input id="grid_${this.name}_field_${n}" name="${t.field}" ${t.attr} rel="search" type="text"
                                class="w2ui-input" style="${r + t.style}">
                            <span id="grid_${this.name}_range_${n}" style="display: none">&#160;-&#160;&#160;
                                <input rel="search" type="text" class="w2ui-input" style="${r + t.style}" id="grid_${this.name}_field2_${n}" name="${t.field}" ${t.attr}>
                            </span>`;
            break;
          case "select":
            e += `<select rel="search" class="w2ui-input" style="${t.style}" id="grid_${this.name}_field_${n}"
                                name="${t.field}" ${t.attr}></select>`;
        }
        e += t.text + "    </td></tr>";
      }
    }
    return e += `<tr>
            <td colspan="2" class="actions">
                <button type="button" class="w2ui-btn close-btn" data-click="searchClose">${b.lang("Close")}</button>
            </td>
            <td class="actions">
                <button type="button" class="w2ui-btn" data-click="searchReset">${b.lang("Reset")}</button>
                <button type="button" class="w2ui-btn w2ui-btn-blue" data-click="search">${b.lang("Search")}</button>
            </td>
        </tr></tbody></table>`;
  }
  getOperators(e, t) {
    let i = this.operators[this.operatorsMap[e]] || [], n = (t != null && Array.isArray(t) && (i = t), "");
    return i.forEach((r) => {
      let o = r, a = r;
      Array.isArray(r) ? (o = r[1], a = r[0]) : b.isPlainObject(r) && (o = r.text, a = r.oper), o == null && (o = r), n += `<option name="11" value="${a}">${b.lang(o)}</option>
`;
    }), n;
  }
  initOperator(e) {
    let t;
    var i = this.searches[e], n = this.getSearchData(i.field), r = p(`#w2overlay-${this.name}-search-overlay`), o = r.find(`#grid_${this.name}_range_` + e);
    let a = r.find(`#grid_${this.name}_field_` + e), l = r.find(`#grid_${this.name}_field2_` + e);
    var c = r.find(`#grid_${this.name}_operator_` + e).val();
    switch (a.show(), o.hide(), c) {
      case "between":
        o.show();
        break;
      case "null":
      case "not null":
        a.hide(), a.val(c), a.trigger("change");
    }
    switch (i.type) {
      case "text":
      case "alphanumeric":
        var h = a[0]._w2field;
        h && h.reset();
        break;
      case "int":
      case "float":
      case "hex":
      case "color":
      case "money":
      case "currency":
      case "percent":
      case "date":
      case "time":
      case "datetime":
        a[0]._w2field || (new Eo(i.type, { el: a[0], ...i.options }), new Eo(i.type, { el: l[0], ...i.options }), setTimeout(() => {
          a.trigger("keydown"), l.trigger("keydown");
        }, 1));
        break;
      case "list":
      case "combo":
      case "enum":
        t = i.options, i.type == "list" && (t.selected = {}), i.type == "enum" && (t.selected = []), n && (t.selected = n.value), a[0]._w2field || (h = new Eo(i.type, { el: a[0], ...t }), n && n.text != null && h.set({ id: n.value, text: n.text }));
        break;
      case "select":
        t = '<option value="">--</option>';
        for (let u = 0; u < i.options.items.length; u++) {
          var d = i.options.items[u];
          if (b.isPlainObject(i.options.items[u])) {
            let f = d.id, m = d.text;
            f == null && d.value != null && (f = d.value), m == null && d.text != null && (m = d.text), f == null && (f = ""), t += '<option value="' + f + '">' + m + "</option>";
          } else t += '<option value="' + d + '">' + d + "</option>";
        }
        a.html(t);
    }
  }
  initSearches() {
    var e = p(`#w2overlay-${this.name}-search-overlay`);
    for (let r = 0; r < this.searches.length; r++) {
      var i = this.searches[r], t = this.getSearchData(i.field);
      i.type = String(i.type).toLowerCase(), typeof i.options != "object" && (i.options = {});
      let o = i.operator, a = [...this.operators[this.operatorsMap[i.type]]];
      i.operators && (a = i.operators), b.isPlainObject(o) && (o = o.oper), a.forEach((l, c) => {
        b.isPlainObject(l) && (a[c] = l.oper);
      }), t && t.operator && (o = t.operator);
      var i = this.defaultOperator[this.operatorsMap[i.type]], i = (a.indexOf(o) == -1 && (o = i), e.find(`#grid_${this.name}_operator_` + r).val(o), this.initOperator(r), e.find(`#grid_${this.name}_field_` + r)), n = e.find(`#grid_${this.name}_field2_` + r);
      t != null && (Array.isArray(t.value) ? ["in", "not in"].includes(t.operator) ? i[0]._w2field.set(t.value) : (i.val(t.value[0]).trigger("change"), n.val(t.value[1]).trigger("change")) : t.value != null && i.val(t.value).trigger("change"));
    }
    e.find(".w2ui-grid-search-advanced *[rel=search]").on("keypress", (r) => {
      r.keyCode == 13 && (this.search(), Ge.hide(this.name + "-search-overlay"));
    });
  }
  getColumnsHTML() {
    let e = this, t = "", i = "";
    var n, r, o;
    return this.show.columnHeaders && (i = 0 < this.columnGroups.length ? (o = a(true), n = function() {
      let l = "<tr>", c = "<tr>", h = "", d = e.columnGroups.length - 1;
      e.columnGroups[d].text == null && e.columnGroups[d].caption != null && (console.log("NOTICE: grid columnGroup.caption property is deprecated, please use columnGroup.text. Group -> ", e.columnGroups[d]), e.columnGroups[d].text = e.columnGroups[d].caption), e.columnGroups[e.columnGroups.length - 1].text != "" && e.columnGroups.push({ text: "" }), e.show.lineNumbers && (l += '<td class="w2ui-head w2ui-col-number" col="line-number">    <div>&#160;</div></td>'), e.show.selectColumn && (l += '<td class="w2ui-head w2ui-col-select" col="select">    <div style="height: 25px">&#160;</div></td>'), e.show.expandColumn && (l += '<td class="w2ui-head w2ui-col-expand" col="expand">    <div style="height: 25px">&#160;</div></td>');
      let u = 0;
      c += `<td id="grid_${e.name}_column_start" class="w2ui-head" col="start" style="border-right: 0"></td>`, e.reorderRows && (c += '<td class="w2ui-head w2ui-col-order" col="order">    <div style="height: 25px">&#160;</div></td>');
      for (let g = 0; g < e.columnGroups.length; g++) {
        var f = e.columnGroups[g], m = e.columns[u] || {};
        f.colspan != null && (f.span = f.colspan), f.span != null && f.span == parseInt(f.span) || (f.span = 1), m.text == null && m.caption != null && (console.log("NOTICE: grid column.caption property is deprecated, please use column.text. Column ->", m), m.text = m.caption);
        let v = 0;
        for (let y = u; y < u + f.span; y++) e.columns[y] && !e.columns[y].hidden && v++;
        if (!((v = g == e.columnGroups.length - 1 ? 100 : v) <= 0)) {
          if (f.main === true) {
            let y = "";
            for (let S = 0; S < e.sortData.length; S++) e.sortData[S].field == m.field && ((e.sortData[S].direction || "").toLowerCase() === "asc" && (y = "w2ui-sort-up"), (e.sortData[S].direction || "").toLowerCase() === "desc") && (y = "w2ui-sort-down");
            let x = "";
            m.resizable !== false && (x = `<div class="w2ui-resizer" name="${u}"></div>`);
            var _ = b.lang(typeof m.text == "function" ? m.text(m) : m.text);
            h = `<td id="grid_${e.name}_column_${u}" class="w2ui-head ${y}" col="${u}"     rowspan="2" colspan="${v}">` + x + `    <div class="w2ui-col-group w2ui-col-header ${y ? "w2ui-col-sorted" : ""}">        <div class="${y}"></div>` + (_ || "&#160;") + "    </div></td>";
          } else _ = b.lang(typeof f.text == "function" ? f.text(f) : f.text), h = `<td id="grid_${e.name}_column_${u}" class="w2ui-head" col="${u}" colspan="${v}">    <div class="w2ui-col-group" style="${f.style ?? ""}">${_ || "&#160;"}</div></td>`;
          m && m.frozen ? l += h : c += h;
        }
        u += f.span;
      }
      return l += "<td></td></tr>", c += `<td id="grid_${e.name}_column_end" class="w2ui-head" col="end"></td></tr>`, [l, c];
    }(), r = a(false), t = o[0] + n[0] + r[0], o[1] + n[1] + r[1]) : (o = a(true), t = o[0], o[1])), [t, i];
    function a(l) {
      let c = "<tr>", h = "<tr>", d = (e.show.lineNumbers && (c += '<td class="w2ui-head w2ui-col-number" col="line-number">    <div>#</div></td>'), e.show.selectColumn && (c += `<td class="w2ui-head w2ui-col-select" col="select">    <div>        <input type="checkbox" id="grid_${e.name}_check_all" class="w2ui-select-all" tabindex="-1"            style="${e.multiSelect == 0 ? "display: none;" : ""}"        >    </div></td>`), e.show.expandColumn && (c += '<td class="w2ui-head w2ui-col-expand" col="expand">    <div>&#160;</div></td>'), 0), u = 0, f;
      h += `<td id="grid_${e.name}_column_start" class="w2ui-head" col="start" style="border-right: 0"></td>`, e.reorderRows && (h += '<td class="w2ui-head w2ui-col-order" col="order">    <div>&#160;</div></td>');
      for (let g = 0; g < e.columns.length; g++) {
        var m, _ = e.columns[g];
        _.text == null && _.caption != null && (console.log("NOTICE: grid column.caption property is deprecated, please use column.text. Column -> ", _), _.text = _.caption), _.size == null && (_.size = "100%"), g == u && (f = e.columnGroups[d++] || {}, u += f.span), (g < e.last.colStart || g > e.last.colEnd) && !_.frozen || _.hidden || f.main === true && !l || (m = e.getColumnCellHTML(g), _ && _.frozen ? c += m : h += m);
      }
      return c += '<td class="w2ui-head w2ui-head-last"><div>&#160;</div></td>', h += '<td class="w2ui-head w2ui-head-last" col="end"><div>&#160;</div></td>', c += "</tr>", h += "</tr>", [c, h];
    }
  }
  getColumnCellHTML(e) {
    var t = this.columns[e];
    if (t == null) return "";
    var i = !this.reorderColumns || this.columnGroups && this.columnGroups.length ? "" : " w2ui-col-reorderable ";
    let n = "";
    for (let c = 0; c < this.sortData.length; c++) this.sortData[c].field == t.field && ((this.sortData[c].direction || "").toLowerCase() === "asc" && (n = "w2ui-sort-up"), (this.sortData[c].direction || "").toLowerCase() === "desc") && (n = "w2ui-sort-down");
    var r, o = this.last.selection.columns;
    let a = false;
    for (r in o) for (let c = 0; c < o[r].length; c++) o[r][c] == e && (a = true);
    var l = b.lang(typeof t.text == "function" ? t.text(t) : t.text);
    return '<td id="grid_' + this.name + "_column_" + e + '" col="' + e + '" class="w2ui-head ' + n + i + '">' + (t.resizable !== false ? '<div class="w2ui-resizer" name="' + e + '"></div>' : "") + '    <div class="w2ui-col-header ' + (n ? "w2ui-col-sorted" : "") + " " + (a ? "w2ui-col-selected" : "") + '">        <div class="' + n + '"></div>' + (l || "&#160;") + "    </div></td>";
  }
  columnTooltipShow(n, t) {
    var i = p(this.box).find("#grid_" + this.name + "_column_" + n), n = this.columns[n], r = this.columnTooltip;
    Ge.show({ name: this.name + "-column-tooltip", anchor: i.get(0), html: n == null ? void 0 : n.tooltip, position: r });
  }
  columnTooltipHide(e, t) {
    Ge.hide(this.name + "-column-tooltip");
  }
  getRecordsHTML() {
    var _a2;
    let e = this.records.length;
    var t = typeof this.url != "object" ? this.url : this.url.get, t = ((e = this.searchData.length == 0 || t ? e : this.last.searchIds.length) > this.vs_start ? this.last.show_extra = this.vs_extra : this.last.show_extra = this.vs_start, p(this.box).find(`#grid_${this.name}_records`));
    let i = Math.floor((((_a2 = t.get(0)) == null ? void 0 : _a2.clientHeight) || 0) / this.recordHeight) + this.last.show_extra + 1;
    (!this.fixedBody || i > e) && (i = e);
    var n = this.getRecordHTML(-1, 0);
    let r = "<table><tbody>" + n[0], o = "<table><tbody>" + n[1];
    r += '<tr id="grid_' + this.name + '_frec_top" line="top" style="height: 0px">    <td colspan="2000"></td></tr>', o += '<tr id="grid_' + this.name + '_rec_top" line="top" style="height: 0px">    <td colspan="2000"></td></tr>';
    for (let a = 0; a < i; a++) n = this.getRecordHTML(a, a + 1), r += n[0], o += n[1];
    return t = (e - i) * this.recordHeight, r += '<tr id="grid_' + this.name + '_frec_bottom" rec="bottom" line="bottom" style="height: ' + t + 'px; vertical-align: top">    <td colspan="2000" style="border-right: 1px solid #D6D5D7;"></td></tr><tr id="grid_' + this.name + '_frec_more" style="display: none; ">    <td colspan="2000" class="w2ui-load-more"></td></tr></tbody></table>', o += '<tr id="grid_' + this.name + '_rec_bottom" rec="bottom" line="bottom" style="height: ' + t + 'px; vertical-align: top">    <td colspan="2000" style="border: 0"></td></tr><tr id="grid_' + this.name + '_rec_more" style="display: none">    <td colspan="2000" class="w2ui-load-more"></td></tr></tbody></table>', this.last.range_start = 0, this.last.range_end = i, [r, o];
  }
  getSummaryHTML() {
    if (this.summary.length !== 0) {
      var e = this.getRecordHTML(-1, 0);
      let t = "<table><tbody>" + e[0], i = "<table><tbody>" + e[1];
      for (let n = 0; n < this.summary.length; n++) e = this.getRecordHTML(n, n + 1, true), t += e[0], i += e[1];
      return t += "</tbody></table>", i += "</tbody></table>", [t, i];
    }
  }
  scroll(e) {
    let t = this;
    var i = typeof this.url != "object" ? this.url : this.url.get, n = p(this.box).find(`#grid_${this.name}_records`), r = p(this.box).find(`#grid_${this.name}_frecords`);
    e && (x = e.target.scrollTop, e = e.target.scrollLeft, this.last.scrollTop = x, this.last.scrollLeft = e, d = p(this.box).find(`#grid_${this.name}_columns`)[0], u = p(this.box).find(`#grid_${this.name}_summary`)[0], d && (d.scrollLeft = e), u && (u.scrollLeft = e), r[0]) && (r[0].scrollTop = x), this.last.bubbleEl && (Ge.hide(this.name + "-bubble"), this.last.bubbleEl = null);
    let o = null, a = null;
    if (this.disableCVS || 0 < this.columnGroups.length) o = 0, a = this.columns.length - 1;
    else {
      var l, c = n.prop("clientWidth");
      let w = 0;
      for (let E = 0; E < this.columns.length; E++) this.columns[E].frozen || this.columns[E].hidden || (l = parseInt(this.columns[E].sizeCalculated || this.columns[E].size), w + l + 30 > this.last.scrollLeft && o == null && (o = E), w + l - 30 > this.last.scrollLeft + c && a == null && (a = E), w += l);
      a == null && (a = this.columns.length - 1);
    }
    if (o != null && (o < 0 && (o = 0), a < 0 && (a = 0), o == a && (0 < o ? o-- : a++), o != this.last.colStart || a != this.last.colEnd)) {
      var h = p(this.box), d = Math.abs(o - this.last.colStart), u = Math.abs(a - this.last.colEnd);
      if (d < 5 && u < 5) {
        var f = h.find(`.w2ui-grid-columns #grid_${this.name}_column_start`), m = h.find(".w2ui-grid-columns .w2ui-head-last"), _ = h.find(`#grid_${this.name}_records .w2ui-grid-data-spacer`), g = h.find(`#grid_${this.name}_records .w2ui-grid-data-last`), v = h.find(`#grid_${this.name}_summary .w2ui-grid-data-spacer`), y = h.find(`#grid_${this.name}_summary .w2ui-grid-data-last`);
        if (o > this.last.colStart) for (let w = this.last.colStart; w < o; w++) h.find("#grid_" + this.name + "_columns #grid_" + this.name + "_column_" + w).remove(), h.find("#grid_" + this.name + '_records td[col="' + w + '"]').remove(), h.find("#grid_" + this.name + '_summary td[col="' + w + '"]').remove();
        if (a < this.last.colEnd) for (let w = this.last.colEnd; w > a; w--) h.find("#grid_" + this.name + "_columns #grid_" + this.name + "_column_" + w).remove(), h.find("#grid_" + this.name + '_records td[col="' + w + '"]').remove(), h.find("#grid_" + this.name + '_summary td[col="' + w + '"]').remove();
        if (o < this.last.colStart) for (let w = this.last.colStart - 1; w >= o; w--) this.columns[w] && (this.columns[w].frozen || this.columns[w].hidden) || (f.after(this.getColumnCellHTML(w)), _.each((E) => {
          var N = p(E).parent().attr("index");
          let k = '<td class="w2ui-grid-data" col="' + w + '" style="height: 0px"></td>';
          N != null && (k = this.getCellHTML(parseInt(N), w, false)), p(E).after(k);
        }), v.each((E) => {
          var N = p(E).parent().attr("index");
          let k = '<td class="w2ui-grid-data" col="' + w + '" style="height: 0px"></td>';
          N != null && (k = this.getCellHTML(parseInt(N), w, true)), p(E).after(k);
        }));
        if (a > this.last.colEnd) for (let w = this.last.colEnd + 1; w <= a; w++) this.columns[w] && (this.columns[w].frozen || this.columns[w].hidden) || (m.before(this.getColumnCellHTML(w)), g.each((E) => {
          var N = p(E).parent().attr("index");
          let k = '<td class="w2ui-grid-data" col="' + w + '" style="height: 0px"></td>';
          N != null && (k = this.getCellHTML(parseInt(N), w, false)), p(E).before(k);
        }), y.each((E) => {
          var N = p(E).parent().attr("index") || -1, N = this.getCellHTML(parseInt(N), w, true);
          p(E).before(N);
        }));
        this.last.colStart = o, this.last.colEnd = a;
      } else {
        this.last.colStart = o, this.last.colEnd = a;
        var e = this.getColumnsHTML(), x = this.getRecordsHTML(), d = this.getSummaryHTML(), u = h.find(`#grid_${this.name}_columns`);
        let k = h.find(`#grid_${this.name}_records`);
        var S = h.find(`#grid_${this.name}_frecords`);
        let V = h.find(`#grid_${this.name}_summary`);
        u.find("tbody").html(e[1]), S.html(x[0]), k.prepend(x[1]), d != null && V.html(d[1]), setTimeout(() => {
          k.find(":scope > table").filter(":not(table:first-child)").remove(), V[0] && (V[0].scrollLeft = this.last.scrollLeft);
        }, 1);
      }
      this.resizeRecords();
    }
    let A = this.records.length;
    if (A > this.total && this.total !== -1 && (A = this.total), (A = this.searchData.length == 0 || i ? A : this.last.searchIds.length) !== 0 && n.length !== 0 && n.prop("clientHeight") !== 0) {
      A > this.vs_start ? this.last.show_extra = this.vs_extra : this.last.show_extra = this.vs_start;
      let w = Math.round(n.prop("scrollTop") / this.recordHeight + 1), E = w + (Math.round(n.prop("clientHeight") / this.recordHeight) - 1);
      if (w > A && (w = A), E >= A - 1 && (E = A), p(this.box).find("#grid_" + this.name + "_footer .w2ui-footer-right").html((this.show.statusRange ? b.formatNumber(this.offset + w) + "-" + b.formatNumber(this.offset + E) + (this.total != -1 ? " " + b.lang("of") + " " + b.formatNumber(this.total) : "") : "") + (i && this.show.statusBuffered ? " (" + b.lang("buffered") + " " + b.formatNumber(A) + (0 < this.offset ? ", skip " + b.formatNumber(this.offset) : "") + ")" : "")), i || this.fixedBody && !(this.total != -1 && this.total <= this.vs_start)) {
        let N = function() {
          t.markSearch && (clearTimeout(t.last.marker_timer), t.last.marker_timer = setTimeout(() => {
            var Re = [];
            for (let me = 0; me < t.searchData.length; me++) {
              var Y = t.searchData[me], se = t.getSearch(Y.field);
              se && !se.hidden && (se = t.getColumn(Y.field, true), Re.push({ field: Y.field, search: Y.value, col: se }));
            }
            0 < Re.length && Re.forEach((me) => {
              var de = p(t.box).find('td[col="' + me.col + '"]:not(.w2ui-head)');
              b.marker(de, me.search);
            });
          }, 50));
        }, k = Math.floor(n.prop("scrollTop") / this.recordHeight) - this.last.show_extra, V = k + Math.floor(n.prop("clientHeight") / this.recordHeight) + 2 * this.last.show_extra + 1;
        k < 1 && (k = 1), V > this.total && this.total != -1 && (V = this.total);
        var R = n.find("#grid_" + this.name + "_rec_top"), C = n.find("#grid_" + this.name + "_rec_bottom"), P = r.find("#grid_" + this.name + "_frec_top"), z = r.find("#grid_" + this.name + "_frec_bottom"), u = (String(R.next().prop("id")).indexOf("_expanded_row") != -1 && (R.next().remove(), P.next().remove()), this.total > V && String(C.prev().prop("id")).indexOf("_expanded_row") != -1 && (C.prev().remove(), z.prev().remove()), parseInt(R.next().attr("line"))), e = parseInt(C.prev().attr("line"));
        let ee, O, Q, X, K;
        if (u < k || u == 1 || this.last.pull_refresh) {
          if (V <= e + this.last.show_extra - 2 && V != this.total) return;
          for (this.last.pull_refresh = false; O = r.find("#grid_" + this.name + "_frec_top").next(), !((Q = n.find("#grid_" + this.name + "_rec_top").next()).attr("line") == "bottom" || !(parseInt(Q.attr("line")) < k)); ) O.remove(), Q.remove();
          ee = n.find("#grid_" + this.name + "_rec_bottom").prev(), (X = ee.attr("line")) == "top" && (X = k);
          for (let Re = parseInt(X) + 1; Re <= V; Re++) this.records[Re - 1] && ((Q = this.records[Re - 1].w2ui) && !Array.isArray(Q.children) && (Q.expanded = false), K = this.getRecordHTML(Re - 1, Re), C.before(K[1]), z.before(K[0]));
        } else {
          if (k >= u - this.last.show_extra + 2 && 1 < k) return;
          for (; O = r.find("#grid_" + this.name + "_frec_bottom").prev(), !((Q = n.find("#grid_" + this.name + "_rec_bottom").prev()).attr("line") == "top" || !(parseInt(Q.attr("line")) > V)); ) O.remove(), Q.remove();
          ee = n.find("#grid_" + this.name + "_rec_top").next(), (X = ee.attr("line")) == "bottom" && (X = V);
          for (let Re = parseInt(X) - 1; Re >= k; Re--) this.records[Re - 1] && ((Q = this.records[Re - 1].w2ui) && !Array.isArray(Q.children) && (Q.expanded = false), K = this.getRecordHTML(Re - 1, Re), R.after(K[1]), P.after(K[0]));
        }
        N(), setTimeout(() => {
          this.refreshRanges();
        }, 0), S = (k - 1) * this.recordHeight;
        let Le = (A - V) * this.recordHeight;
        Le < 0 && (Le = 0), R.css("height", S + "px"), P.css("height", S + "px"), C.css("height", Le + "px"), z.css("height", Le + "px"), this.last.range_start = k, this.last.range_end = V, Math.floor(n.prop("scrollTop") / this.recordHeight) + Math.floor(n.prop("clientHeight") / this.recordHeight) + 10 > A && this.last.pull_more !== true && (A < this.total - this.offset || this.total == -1 && this.last.fetch.hasMore) && (this.autoLoad === true && (this.last.pull_more = true, this.last.fetch.offset += this.limit, this.request("load")), p(this.box).find("#grid_" + this.name + "_rec_more, #grid_" + this.name + "_frec_more").show().eq(1).off(".load-more").on("click.load-more", function() {
          p(this).find("td").html('<div><div style="width: 20px; height: 20px;" class="w2ui-spinner"></div></div>'), t.last.pull_more = true, t.last.fetch.offset += t.limit, t.request("load");
        }).find("td").html(t.autoLoad ? '<div><div style="width: 20px; height: 20px;" class="w2ui-spinner"></div></div>' : '<div style="padding-top: 15px">' + b.lang("Load ${count} more...", { count: t.limit }) + "</div>"));
      }
    }
  }
  getRecordHTML(e, t, i) {
    var _a2, _b2, _c2, _d2, _e;
    let n = "", r = "";
    var o = this.last.selection;
    let a;
    if (e == -1) {
      n += '<tr line="0">', r += '<tr line="0">', this.show.lineNumbers && (n += '<td class="w2ui-col-number" style="height: 0px"></td>'), this.show.selectColumn && (n += '<td class="w2ui-col-select" style="height: 0px"></td>'), this.show.expandColumn && (n += '<td class="w2ui-col-expand" style="height: 0px"></td>'), r += '<td class="w2ui-grid-data w2ui-grid-data-spacer" col="start" style="height: 0px; width: 0px"></td>', this.reorderRows && (r += '<td class="w2ui-col-order" style="height: 0px"></td>');
      for (let _ = 0; _ < this.columns.length; _++) {
        var l = this.columns[_], c = '<td class="w2ui-grid-data" col="' + _ + '" style="height: 0px;"></td>';
        l.frozen && !l.hidden ? n += c : l.hidden || _ < this.last.colStart || _ > this.last.colEnd || (r += c);
      }
      n += '<td class="w2ui-grid-data-last" style="height: 0px"></td>', r += '<td class="w2ui-grid-data-last" col="end" style="height: 0px"></td>';
    } else {
      var h = typeof this.url != "object" ? this.url : this.url.get;
      if (i !== true) {
        if (0 < this.searchData.length && !h) {
          if (e >= this.last.searchIds.length) return "";
          e = this.last.searchIds[e];
        } else if (e >= this.records.length) return "";
        a = this.records[e];
      } else {
        if (e >= this.summary.length) return "";
        a = this.summary[e];
      }
      if (!a) return "";
      a.recid == null && this.recid != null && (h = this.parseField(a, this.recid)) != null && (a.recid = h);
      let _ = false, g = (o.indexes.indexOf(e) != -1 && (_ = true), a.w2ui ? a.w2ui.style : ""), v = (g != null && typeof g == "string" || (g = ""), a.w2ui ? a.w2ui.class : "");
      if (v != null && typeof v == "string" || (v = ""), n += '<tr id="grid_' + this.name + "_frec_" + a.recid + '" recid="' + a.recid + '" line="' + t + '" index="' + e + '"  class="' + (t % 2 == 0 ? "w2ui-even" : "w2ui-odd") + " w2ui-record " + v + (_ && this.selectType == "row" ? " w2ui-selected" : "") + (a.w2ui && a.w2ui.editable === false ? " w2ui-no-edit" : "") + (a.w2ui && a.w2ui.expanded === true ? " w2ui-expanded" : "") + '"  style="height: ' + this.recordHeight + "px; " + (_ || g == "" ? g.replace("background-color", "none") : g) + '" ' + (g != "" ? 'custom_style="' + g + '"' : "") + ">", r += '<tr id="grid_' + this.name + "_rec_" + a.recid + '" recid="' + a.recid + '" line="' + t + '" index="' + e + '"  class="' + (t % 2 == 0 ? "w2ui-even" : "w2ui-odd") + " w2ui-record " + v + (_ && this.selectType == "row" ? " w2ui-selected" : "") + (a.w2ui && a.w2ui.editable === false ? " w2ui-no-edit" : "") + (a.w2ui && a.w2ui.expanded === true ? " w2ui-expanded" : "") + '"  style="height: ' + this.recordHeight + "px; " + (_ || g == "" ? g.replace("background-color", "none") : g) + '" ' + (g != "" ? 'custom_style="' + g + '"' : "") + ">", this.show.lineNumbers && (n += '<td id="grid_' + this.name + "_cell_" + e + "_number" + (i ? "_s" : "") + '"    class="w2ui-col-number ' + (_ ? " w2ui-row-selected" : "") + '"' + (this.reorderRows ? ' style="cursor: move"' : "") + ">" + (i !== true ? this.getLineHTML(t, a) : "") + "</td>"), this.show.selectColumn && (n += '<td id="grid_' + this.name + "_cell_" + e + "_select" + (i ? "_s" : "") + '" class="w2ui-grid-data w2ui-col-select">' + (i === true || a.w2ui && a.w2ui.hideCheckBox === true ? "" : '    <div>        <input class="w2ui-grid-select-check" type="checkbox" tabindex="-1" ' + (_ ? 'checked="checked"' : "") + ' style="pointer-events: none"/>    </div>') + "</td>"), this.show.expandColumn) {
        let S = "";
        S = ((_a2 = a.w2ui) == null ? void 0 : _a2.expanded) === true ? "-" : "+", ((_b2 = a.w2ui) == null ? void 0 : _b2.expanded) != "none" && Array.isArray((_c2 = a.w2ui) == null ? void 0 : _c2.children) && ((_d2 = a.w2ui) == null ? void 0 : _d2.children.length) || (S = "+"), ((_e = a.w2ui) == null ? void 0 : _e.expanded) == "spinner" && (S = '<div class="w2ui-spinner" style="width: 16px; margin: -2px 2px;"></div>'), n += '<td id="grid_' + this.name + "_cell_" + e + "_expand" + (i ? "_s" : "") + '" class="w2ui-grid-data w2ui-col-expand">' + (i !== true ? `<div>${S}</div>` : "") + "</td>";
      }
      r += '<td class="w2ui-grid-data-spacer" col="start" style="border-right: 0"></td>', this.reorderRows && (r += '<td id="grid_' + this.name + "_cell_" + e + "_order" + (i ? "_s" : "") + '" class="w2ui-grid-data w2ui-col-order" col="order">' + (i !== true ? '<div title="Drag to reorder">&nbsp;</div>' : "") + "</td>");
      let y = 0, x = 0;
      for (; ; ) {
        let S = 1;
        var d, u = this.columns[y];
        if (u == null) break;
        if (u.hidden) y++, 0 < x && x--;
        else if (0 < x) {
          if (y++, this.columns[y] == null) break;
          a.w2ui.colspan[this.columns[y - 1].field] = 0, x--;
        } else {
          if (a.w2ui && (m = a.w2ui.colspan, d = this.columns[y].field, m) && m[d] === 0 && delete m[d], !(y < this.last.colStart || y > this.last.colEnd) || u.frozen) {
            if (a.w2ui && typeof a.w2ui.colspan == "object") {
              var f = parseInt(a.w2ui.colspan[u.field]) || null;
              if (1 < f) {
                let A = 0;
                for (let R = y; R < y + f && !(R >= this.columns.length); R++) this.columns[R].hidden && A++;
                S = f - A, x = f - 1;
              }
            }
            var m = this.getCellHTML(e, y, i, S);
            u.frozen ? n += m : r += m;
          }
          y++;
        }
      }
      n += '<td class="w2ui-grid-data-last"></td>', r += '<td class="w2ui-grid-data-last" col="end"></td>';
    }
    return n += "</tr>", r += "</tr>", [n, r];
  }
  getLineHTML(e) {
    return "<div>" + e + "</div>";
  }
  getCellHTML(e, t, i, n) {
    var _a2, _b2, _c2, _d2;
    let r = this, o = this.columns[t];
    if (o == null) return "";
    let a = (i !== true ? this.records : this.summary)[e], { value: l, style: c, className: h, attr: d, divAttr: u } = this.getCellValue(e, t, i, true);
    var f = e !== -1 ? this.getCellEditable(e, t) : "";
    let m = "max-height: " + parseInt(this.recordHeight) + "px;" + (o.clipboardCopy ? "margin-right: 20px" : "");
    var _ = !i && ((_a2 = a == null ? void 0 : a.w2ui) == null ? void 0 : _a2.changes) && a.w2ui.changes[o.field] != null, g = this.last.selection;
    let v = false, y = "";
    if (g.indexes.indexOf(e) != -1 && (v = true), n == null && (n = ((_b2 = a == null ? void 0 : a.w2ui) == null ? void 0 : _b2.colspan) && a.w2ui.colspan[o.field] ? a.w2ui.colspan[o.field] : 1), t === 0 && Array.isArray((_c2 = a == null ? void 0 : a.w2ui) == null ? void 0 : _c2.children)) {
      let P = 0, z = this.get(a.w2ui.parent_recid, true);
      for (; z != null; ) {
        P++;
        var x = this.records[z].w2ui;
        if (x == null || x.parent_recid == null) break;
        z = this.get(x.parent_recid, true);
      }
      if (a.w2ui.parent_recid) for (let w = 0; w < P; w++) y += '<span class="w2ui-show-children w2ui-icon-empty"></span>';
      var S = 0 < a.w2ui.children.length ? a.w2ui.expanded ? "w2ui-icon-collapse" : "w2ui-icon-expand" : "w2ui-icon-empty";
      y += `<span class="w2ui-show-children ${S}"></span>`;
    }
    if (o.info === true && (o.info = {}), o.info != null) {
      let P = "w2ui-icon-info", z = (typeof o.info.icon == "function" ? P = o.info.icon(a, { self: this, index: e, colIndex: t, summary: !!i }) : typeof o.info.icon == "object" ? P = o.info.icon[this.parseField(a, o.field)] || "" : typeof o.info.icon == "string" && (P = o.info.icon), o.info.style || "");
      typeof o.info.style == "function" ? z = o.info.style(a, { self: this, index: e, colIndex: t, summary: !!i }) : typeof o.info.style == "object" ? z = o.info.style[this.parseField(a, o.field)] || "" : typeof o.info.style == "string" && (z = o.info.style), y += `<span class="w2ui-info ${P}" style="${z}"></span>`;
    }
    let A = l, R = (f && ["checkbox", "check"].indexOf(f.type) != -1 && (m += "text-align: center;", A = `<input tabindex="-1" type="checkbox" class="w2ui-editable-checkbox"
                            data-changeInd="${i ? -(e + 1) : e}" data-colInd="${t}" ${A ? 'checked="checked"' : ""}>`, y = ""), (A = `<div style="${m}" ${function(P) {
      let z;
      return r.show.recordTitles && (o.title != null ? (typeof o.title == "function" && (z = o.title.call(r, a, { self: this, index: e, colIndex: t, summary: !!i })), typeof o.title == "string" && (z = o.title)) : z = b.stripTags(String(P).replace(/"/g, "''"))), z != null ? 'title="' + String(z) + '"' : "";
    }(A)} ${u}>${y}${String(A)}</div>`) == null && (A = ""), typeof o.render == "string" && (S = o.render.toLowerCase().split(":"), ["number", "int", "float", "money", "currency", "percent", "size"].indexOf(S[0]) != -1) && (c += "text-align: right;"), (a == null ? void 0 : a.w2ui) && (typeof a.w2ui.style == "object" && (typeof a.w2ui.style[t] == "string" && (c += a.w2ui.style[t] + ";"), typeof a.w2ui.style[o.field] == "string") && (c += a.w2ui.style[o.field] + ";"), typeof a.w2ui.class == "object") && (typeof a.w2ui.class[t] == "string" && (h += a.w2ui.class[t] + " "), typeof a.w2ui.class[o.field] == "string") && (h += a.w2ui.class[o.field] + " "), false);
    v && ((_d2 = g.columns[e]) == null ? void 0 : _d2.includes(t)) && (R = true);
    let C;
    return o.clipboardCopy && (C = '<span class="w2ui-clipboard-copy w2ui-icon-paste"></span>'), A = '<td class="w2ui-grid-data' + (R ? " w2ui-selected" : "") + " " + h + (_ ? " w2ui-changed" : "") + '"    id="grid_' + this.name + "_data_" + e + "_" + t + '" col="' + t + '"    style="' + c + (o.style != null ? o.style : "") + '" ' + (o.attr != null ? o.attr : "") + d + (1 < n ? 'colspan="' + n + '"' : "") + ">" + A + (C && b.stripTags(A) ? C : "") + "</td>", A = e === -1 && i === true ? '<td class="w2ui-grid-data" col="' + t + '" style="height: 0px; ' + c + '" ' + (1 < n ? 'colspan="' + n + '"' : "") + "></td>" : A;
  }
  clipboardCopy(e, t, i) {
    var n = (i ? this.summary : this.records)[e], r = this.columns[t];
    let o = r ? this.parseField(n, r.field) : "";
    typeof r.clipboardCopy == "function" && (o = r.clipboardCopy(n, { self: this, index: e, colIndex: t, summary: !!i })), p(this.box).find("#grid_" + this.name + "_focus").text(o).get(0).select(), document.execCommand("copy");
  }
  showBubble(e, t, i) {
    var n = this.columns[t].info;
    if (n) {
      let u = "";
      var r = this.records[e], o = p(this.box).find(`${i ? ".w2ui-grid-summary" : ""} #grid_${this.name}_data_${e}_${t} .w2ui-info`);
      if (this.last.bubbleEl && Ge.hide(this.name + "-bubble"), this.last.bubbleEl = o, n.fields == null) {
        n.fields = [];
        for (let m = 0; m < this.columns.length; m++) {
          var a = this.columns[m];
          n.fields.push(a.field + (typeof a.render == "string" ? ":" + a.render : ""));
        }
      }
      let f = n.fields;
      if (typeof f == "function" && (f = f(r, { self: this, index: e, colIndex: t, summary: !!i })), typeof n.render == "function") u = n.render(r, { self: this, index: e, colIndex: t, summary: !!i });
      else if (Array.isArray(f)) {
        u = '<table cellpadding="0" cellspacing="0">';
        for (let m = 0; m < f.length; m++) {
          var l = String(f[m]).split(":");
          if (l[0] == "" || l[0] == "-" || l[0] == "--" || l[0] == "---") u += '<tr><td colspan=2><div style="border-top: ' + (l[0] == "" ? "0" : "1") + 'px solid #C1BEBE; margin: 6px 0px;"></div></td></tr>';
          else {
            let _ = this.getColumn(l[0]), g = (_ = _ ?? { field: l[0], caption: l[0] }) ? this.parseField(r, _.field) : "";
            1 < l.length && (b.formatters[l[1]] ? g = b.formatters[l[1]](g, l[2] || null, r) : console.log('ERROR: w2utils.formatters["' + l[1] + '"] does not exists.')), (n.showEmpty === true || g != null && g != "") && (n.maxLength != null && typeof g == "string" && g.length > n.maxLength && (g = g.substr(0, n.maxLength) + "..."), u += "<tr><td>" + _.text + "</td><td>" + ((g === 0 ? "0" : g) || "") + "</td></tr>");
          }
        }
        u += "</table>";
      } else if (b.isPlainObject(f)) {
        for (var c in u = '<table cellpadding="0" cellspacing="0">', f) {
          var h = f[c];
          if (h == "" || h == "-" || h == "--" || h == "---") u += '<tr><td colspan=2><div style="border-top: ' + (h == "" ? "0" : "1") + 'px solid #C1BEBE; margin: 6px 0px;"></div></td></tr>';
          else {
            var d = String(h).split(":");
            let m = this.getColumn(d[0]), _ = (m = m ?? { field: d[0], caption: d[0] }) ? this.parseField(r, m.field) : "";
            1 < d.length && (b.formatters[d[1]] ? _ = b.formatters[d[1]](_, d[2] || null, r) : console.log('ERROR: w2utils.formatters["' + d[1] + '"] does not exists.')), typeof h == "function" && (_ = h(r, { self: this, index: e, colIndex: t, summary: !!i })), (n.showEmpty === true || _ != null && _ != "") && (n.maxLength != null && typeof _ == "string" && _.length > n.maxLength && (_ = _.substr(0, n.maxLength) + "..."), u += "<tr><td>" + c + "</td><td>" + ((_ === 0 ? "0" : _) || "") + "</td></tr>");
          }
        }
        u += "</table>";
      }
      return Ge.show(b.extend({ name: this.name + "-bubble", html: u, anchor: o.get(0), position: "top|bottom", class: "w2ui-info-bubble", style: "", hideOn: ["doc-click"] }, n.options ?? {})).hide(() => [this.last.bubbleEl = null]);
    }
  }
  getCellEditable(e, t) {
    var i = this.columns[t], n = this.records[e];
    if (!n || !i) return null;
    let r = n.w2ui ? n.w2ui.editable : null;
    return r === false ? null : (r != null && r !== true || typeof (r = 0 < Object.keys(i.editable ?? {}).length ? i.editable : null) == "function" && (i = this.getCellValue(e, t, false), r = r.call(this, n, { self: this, value: i, index: e, colIndex: t })), r);
  }
  getCellValue(e, t, i, n) {
    var _a2, _b2;
    var r = this.columns[t], o = (i !== true ? this.records : this.summary)[e];
    let a = this.parseField(o, r.field), l = "", c = "", h = "", d = "";
    if (((_b2 = (_a2 = o == null ? void 0 : o.w2ui) == null ? void 0 : _a2.changes) == null ? void 0 : _b2[r.field]) != null && (a = o.w2ui.changes[r.field]), r.render != null && e !== -1) {
      if (typeof r.render == "function" && o != null) {
        let u;
        try {
          u = r.render(o, { self: this, value: a, index: e, colIndex: t, summary: !!i });
        } catch (f) {
          throw new Error(`Render function for column "${r.field}" in grid "${this.name}": -- ` + f.message);
        }
        u != null && typeof u == "object" && typeof u != "function" ? (u.id != null && u.text != null ? a = u.text : typeof u.html == "string" ? a = (u.html || "").trim() : (a = "", console.log("ERROR: render function should return a primitive or an object of the following structure.", { html: "", attr: "", style: "", class: "", divAttr: "" })), h = u.attr ?? "", c = u.style ?? "", l = u.class ?? "", d = u.divAttr ?? "") : a = String(u || "").trim();
      }
      if (typeof r.render == "object" && (e = r.render[a]) != null && e !== "" && (a = e), typeof r.render == "string") {
        t = r.render.toLowerCase().indexOf(":"), i = [], t == -1 ? (i[0] = r.render.toLowerCase(), i[1] = "") : (i[0] = r.render.toLowerCase().substr(0, t), i[1] = r.render.toLowerCase().substr(t + 1));
        let u = b.formatters[i[0]];
        r.options && r.options.autoFormat === false && (u = null), a = typeof u == "function" ? u(a, i[1], o) : "";
      }
    }
    return a == null && (a = ""), n ? { value: a, attr: h, style: c, className: l, divAttr: d } : a;
  }
  getFooterHTML() {
    return '<div>    <div class="w2ui-footer-left"></div>    <div class="w2ui-footer-right"></div>    <div class="w2ui-footer-center"></div></div>';
  }
  status(e) {
    if (e != null) p(this.box).find(`#grid_${this.name}_footer`).find(".w2ui-footer-left").html(e);
    else {
      let t = "";
      if (e = this.getSelection(), 0 < e.length && (this.show.statusSelection && 1 < e.length && (t = String(e.length).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + b.settings.groupSymbol) + " " + b.lang("selected")), this.show.statusRecordID) && e.length == 1) {
        let i = e[0];
        typeof i == "object" && (i = i.recid + ", " + b.lang("Column") + ": " + i.column), t = b.lang("Record ID") + ": " + i + " ";
      }
      p(this.box).find("#grid_" + this.name + "_footer .w2ui-footer-left").html(t);
    }
  }
  lock(e, t) {
    let i = Array.from(arguments);
    i.unshift(this.box), setTimeout(() => {
      p(this.box).find("#grid_" + this.name + "_empty_msg").remove(), b.lock(...i);
    }, 10);
  }
  unlock(e) {
    setTimeout(() => {
      p(this.box).find(".w2ui-message").hasClass("w2ui-closing") || b.unlock(this.box, e);
    }, 25);
  }
  stateSave(e) {
    var t = { columns: [], show: b.clone(this.show), last: { search: this.last.search, multi: this.last.multi, logic: this.last.logic, label: this.last.label, field: this.last.field, scrollTop: this.last.scrollTop, scrollLeft: this.last.scrollLeft }, sortData: [], searchData: [] };
    let i;
    for (let r = 0; r < this.columns.length; r++) {
      let o = this.columns[r], a = {};
      Object.keys(this.stateColProps).forEach((l, c) => {
        this.stateColProps[l] && (i = o[l] !== void 0 ? o[l] : this.colTemplate[l] || null, a[l] = i);
      }), t.columns.push(a);
    }
    for (let r = 0; r < this.sortData.length; r++) t.sortData.push(b.clone(this.sortData[r]));
    for (let r = 0; r < this.searchData.length; r++) t.searchData.push(b.clone(this.searchData[r]));
    var n = this.trigger("stateSave", { target: this.name, state: t });
    if (n.isCancelled !== true) return e !== true && this.cacheSave("state", t), n.finish(), t;
  }
  stateRestore(e) {
    var _a2, _b2, _c2;
    let t = typeof this.url != "object" ? this.url : this.url.get;
    e = e || this.cache("state");
    var i = this.trigger("stateRestore", { target: this.name, state: e });
    if (i.isCancelled !== true) {
      if (b.isPlainObject(e)) {
        b.extend(this.show, e.show ?? {}), b.extend(this.last, e.last ?? {});
        let o = this.last.scrollTop, a = this.last.scrollLeft;
        for (let l = 0; l < ((_a2 = e.columns) == null ? void 0 : _a2.length); l++) {
          var n = e.columns[l], r = this.getColumn(n.field, true);
          r !== null && (b.extend(this.columns[r], n), l !== r) && this.columns.splice(l, 0, this.columns.splice(r, 1)[0]);
        }
        this.sortData.splice(0, this.sortData.length);
        for (let l = 0; l < ((_b2 = e.sortData) == null ? void 0 : _b2.length); l++) this.sortData.push(e.sortData[l]);
        this.searchData.splice(0, this.searchData.length);
        for (let l = 0; l < ((_c2 = e.searchData) == null ? void 0 : _c2.length); l++) this.searchData.push(e.searchData[l]);
        setTimeout(() => {
          t || (0 < this.sortData.length && this.localSort(), 0 < this.searchData.length && this.localSearch()), this.last.scrollTop = o, this.last.scrollLeft = a, this.refresh();
        }, 1), console.log(`INFO (w2ui): state restored for "${this.name}"`);
      }
      return i.finish(), true;
    }
  }
  stateReset() {
    this.stateRestore(this.last.state), this.cacheSave("state", null);
  }
  parseField(e, t) {
    if (this.nestedFields) {
      let n = "";
      try {
        n = e;
        var i = String(t).split(".");
        for (let r = 0; r < i.length; r++) n = n[i[r]];
      } catch {
        n = "";
      }
      return n;
    }
    return e ? e[t] : "";
  }
  prepareData() {
    let e = this;
    for (let t = 0; t < this.records.length; t++) (function i(n) {
      var _a2, _b2;
      for (let r = 0; r < e.columns.length; r++) {
        let o = e.columns[r];
        if (n[o.field] != null && typeof o.render == "string") {
          if (["number", "int", "float", "money", "currency", "percent"].indexOf(o.render.split(":")[0]) != -1 && typeof n[o.field] != "number" && (n[o.field] = parseFloat(n[o.field])), ["date", "age"].indexOf(o.render.split(":")[0]) != -1 && !n[o.field + "_"]) {
            let a = n[o.field];
            b.isInt(a) && (a = parseInt(a)), n[o.field + "_"] = new Date(a);
          }
          if (["time"].indexOf(o.render) != -1) if (b.isTime(n[o.field])) {
            let a = b.isTime(n[o.field], true), l = /* @__PURE__ */ new Date();
            l.setHours(a.hours, a.minutes, a.seconds || 0, 0), n[o.field + "_"] || (n[o.field + "_"] = l);
          } else {
            let a = n[o.field], l = (a = (a = b.isInt(a) ? parseInt(a) : a) != null ? new Date(a) : /* @__PURE__ */ new Date(), /* @__PURE__ */ new Date());
            l.setHours(a.getHours(), a.getMinutes(), a.getSeconds(), 0), n[o.field + "_"] || (n[o.field + "_"] = l);
          }
        }
      }
      if (((_a2 = n.w2ui) == null ? void 0 : _a2.children) && ((_b2 = n.w2ui) == null ? void 0 : _b2.expanded) !== true) for (let r = 0; r < n.w2ui.children.length; r++) {
        let o = n.w2ui.children[r];
        i(o);
      }
    })(this.records[t]);
  }
  nextCell(e, t, i) {
    if (t += 1, t >= this.columns.length) return (e = this.nextRow(e)) == null ? e : this.nextCell(e, -1, i);
    var r = this.records[e].w2ui, n = this.columns[t], r = r && r.colspan && !isNaN(r.colspan[n.field]) ? parseInt(r.colspan[n.field]) : 1;
    return n == null ? null : n && n.hidden || r === 0 ? this.nextCell(e, t, i) : i && (n = this.getCellEditable(e, t), n == null || ["checkbox", "check"].indexOf(n.type) != -1) ? this.nextCell(e, t, i) : { index: e, colIndex: t };
  }
  prevCell(e, t, i) {
    if (t -= 1, t < 0) return (e = this.prevRow(e)) == null ? e : this.prevCell(e, this.columns.length, i);
    if (t < 0) return null;
    var r = this.records[e].w2ui, n = this.columns[t], r = r && r.colspan && !isNaN(r.colspan[n.field]) ? parseInt(r.colspan[n.field]) : 1;
    return n == null ? null : n && n.hidden || r === 0 ? this.prevCell(e, t, i) : i && (n = this.getCellEditable(e, t), n == null || ["checkbox", "check"].indexOf(n.type) != -1) ? this.prevCell(e, t, i) : { index: e, colIndex: t };
  }
  nextRow(e, t, i) {
    var n = this.last.searchIds;
    let r = null;
    if ((i = i ?? 1) == -1) return this.records.length - 1;
    if (e + i < this.records.length && n.length === 0 || 0 < n.length && e < n[n.length - i]) {
      if (e += i, 0 < n.length) for (; !(n.includes(e) || e > this.records.length); ) e += i;
      var a = this.records[e].w2ui, o = this.columns[t], a = a && a.colspan && o != null && !isNaN(a.colspan[o.field]) ? parseInt(a.colspan[o.field]) : 1;
      r = a === 0 ? this.nextRow(e, t, i) : e;
    }
    return r;
  }
  prevRow(e, t, i) {
    var n = this.last.searchIds;
    let r = null;
    if ((i = i ?? 1) == -1) return 0;
    if (0 <= e - i && n.length === 0 || 0 < n.length && e > n[0]) {
      if (e -= i, 0 < n.length) for (; !(n.includes(e) || e < 0); ) e -= i;
      var a = this.records[e].w2ui, o = this.columns[t], a = a && a.colspan && o != null && !isNaN(a.colspan[o.field]) ? parseInt(a.colspan[o.field]) : 1;
      r = a === 0 ? this.prevRow(e, t, i) : e;
    }
    return r;
  }
  selectionSave() {
    return this.last.saved_sel = this.getSelection(), this.last.saved_sel;
  }
  selectionRestore(e) {
    var t, i = Date.now(), n = (this.last.selection = { indexes: [], columns: {} }, this.last.selection), r = this.last.saved_sel;
    if (r) for (let o = 0; o < r.length; o++) b.isPlainObject(r[o]) ? (t = this.get(r[o].recid, true)) != null && (n.indexes.indexOf(t) == -1 && n.indexes.push(t), n.columns[t] || (n.columns[t] = []), n.columns[t].push(r[o].column)) : (t = this.get(r[o], true)) != null && n.indexes.push(t);
    return delete this.last.saved_sel, e !== true && this.refresh(), Date.now() - i;
  }
  message(e) {
    return b.message({ owner: this, box: this.box, after: ".w2ui-grid-header" }, e);
  }
  confirm(e) {
    return b.confirm({ owner: this, box: this.box, after: ".w2ui-grid-header" }, e);
  }
}
class Eo extends Xn {
  constructor(e, t) {
    super(), typeof e == "string" && t == null && (t = { type: e }), typeof e == "object" && t == null && (t = b.clone(e)), typeof e == "string" && typeof t == "object" && (t.type = e), t.type = String(t.type).toLowerCase(), this.el = t.el ?? null, this.selected = null, this.helpers = {}, this.type = t.type ?? "text", this.options = b.clone(t), this.onClick = t.onClick ?? null, this.onAdd = t.onAdd ?? null, this.onNew = t.onNew ?? null, this.onRemove = t.onRemove ?? null, this.onMouseEnter = t.onMouseEnter ?? null, this.onMouseLeave = t.onMouseLeave ?? null, this.onScroll = t.onScroll ?? null, this.tmp = {}, delete this.options.type, delete this.options.onClick, delete this.options.onMouseEnter, delete this.options.onMouseLeave, delete this.options.onScroll, this.el && this.render(this.el);
  }
  render(e) {
    e instanceof HTMLElement ? (e._w2field ? e._w2field.reset() : e._w2field = this, this.el = e, this.init()) : console.log("ERROR: Cannot init w2field on empty subject");
  }
  init() {
    let e = this.options, t;
    if (["INPUT", "TEXTAREA"].includes(this.el.tagName.toUpperCase())) {
      switch (this.type) {
        case "text":
        case "int":
        case "float":
        case "money":
        case "currency":
        case "percent":
        case "alphanumeric":
        case "bin":
        case "hex":
          t = { min: null, max: null, step: 1, autoFormat: true, autoCorrect: true, currencyPrefix: b.settings.currencyPrefix, currencySuffix: b.settings.currencySuffix, currencyPrecision: b.settings.currencyPrecision, decimalSymbol: b.settings.decimalSymbol, groupSymbol: b.settings.groupSymbol, arrow: false, keyboard: true, precision: null, prefix: "", suffix: "" }, this.options = b.extend({}, t, e), (e = this.options).numberRE = new RegExp("[" + e.groupSymbol + "]", "g"), e.moneyRE = new RegExp("[" + e.currencyPrefix + e.currencySuffix + e.groupSymbol + "]", "g"), e.percentRE = new RegExp("[" + e.groupSymbol + "%]", "g"), ["text", "alphanumeric", "hex", "bin"].includes(this.type) && (e.arrow = false, e.keyboard = false);
          break;
        case "color":
          t = { prefix: "#", suffix: `<div style="width: ${parseInt(getComputedStyle(this.el)["font-size"]) || 12}px">&#160;</div>`, arrow: false, advanced: null, transparent: true }, this.options = b.extend({}, t, e), e = this.options;
          break;
        case "date":
          t = { format: b.settings.dateFormat, keyboard: true, autoCorrect: true, start: null, end: null, blockDates: [], blockWeekdays: [], colored: {}, btnNow: true }, this.options = b.extend({ type: "date" }, t, e), e = this.options, p(this.el).attr("placeholder") == null && p(this.el).attr("placeholder", e.format);
          break;
        case "time":
          t = { format: b.settings.timeFormat, keyboard: true, autoCorrect: true, start: null, end: null, btnNow: true, noMinutes: false }, this.options = b.extend({ type: "time" }, t, e), e = this.options, p(this.el).attr("placeholder") == null && p(this.el).attr("placeholder", e.format);
          break;
        case "datetime":
          t = { format: b.settings.dateFormat + "|" + b.settings.timeFormat, keyboard: true, autoCorrect: true, start: null, end: null, startTime: null, endTime: null, blockDates: [], blockWeekdays: [], colored: {}, btnNow: true, noMinutes: false }, this.options = b.extend({ type: "datetime" }, t, e), e = this.options, p(this.el).attr("placeholder") == null && p(this.el).attr("placeholder", e.placeholder || e.format);
          break;
        case "list":
        case "combo":
          t = { items: [], selected: {}, url: null, recId: null, recText: null, method: null, debounce: 250, postData: {}, minLength: 1, cacheMax: 250, maxDropHeight: 350, maxDropWidth: null, minDropWidth: null, match: "begins", icon: null, iconStyle: "", align: "both", altRows: true, renderDrop: null, compare: null, filter: true, hideSelected: false, prefix: "", suffix: "", msgNoItems: "No matches", msgSearch: "Type to search...", openOnFocus: false, markSearch: false, onSearch: null, onRequest: null, onLoad: null, onError: null }, typeof e.items == "function" && (e._items_fun = e.items), e.items = b.normMenu.call(this, e.items), this.type === "list" && (p(this.el).addClass("w2ui-select"), !b.isPlainObject(e.selected)) && Array.isArray(e.items) && e.items.forEach((i) => {
            i && i.id === e.selected && (e.selected = b.clone(i));
          }), e = b.extend({}, t, e), this.options = e, b.isPlainObject(e.selected) || (e.selected = {}), this.selected = e.selected, p(this.el).attr("autocapitalize", "off").attr("autocomplete", "off").attr("autocorrect", "off").attr("spellcheck", "false"), e.selected.text != null && p(this.el).val(e.selected.text);
          break;
        case "enum":
          t = { items: [], selected: [], max: 0, url: null, recId: null, recText: null, debounce: 250, method: null, postData: {}, minLength: 1, cacheMax: 250, maxItemWidth: 250, maxDropHeight: 350, maxDropWidth: null, match: "contains", align: "", altRows: true, openOnFocus: false, markSearch: false, renderDrop: null, renderItem: null, compare: null, filter: true, hideSelected: true, style: "", msgNoItems: "No matches", msgSearch: "Type to search...", onSearch: null, onRequest: null, onLoad: null, onError: null, onClick: null, onAdd: null, onNew: null, onRemove: null, onMouseEnter: null, onMouseLeave: null, onScroll: null }, typeof (e = b.extend({}, t, e, { suffix: "" })).items == "function" && (e._items_fun = e.items), e.items = b.normMenu.call(this, e.items), e.selected = b.normMenu.call(this, e.selected), this.options = e, Array.isArray(e.selected) || (e.selected = []), this.selected = e.selected;
          break;
        case "file":
          t = { selected: [], max: 0, maxSize: 0, maxFileSize: 0, maxItemWidth: 250, maxDropHeight: 350, maxDropWidth: null, readContent: true, silent: true, align: "both", altRows: true, renderItem: null, style: "", onClick: null, onAdd: null, onRemove: null, onMouseEnter: null, onMouseLeave: null }, e = b.extend({}, t, e), this.options = e, Array.isArray(e.selected) || (e.selected = []), this.selected = e.selected, p(this.el).attr("placeholder") == null && p(this.el).attr("placeholder", b.lang("Attach files by dragging and dropping or Click to Select"));
      }
      p(this.el).css("box-sizing", "border-box").addClass("w2field w2ui-input").off(".w2field").on("change.w2field", (i) => {
        this.change(i);
      }).on("click.w2field", (i) => {
        this.click(i);
      }).on("focus.w2field", (i) => {
        this.focus(i);
      }).on("blur.w2field", (i) => {
        this.type !== "list" && this.blur(i);
      }).on("keydown.w2field", (i) => {
        this.keyDown(i);
      }).on("keyup.w2field", (i) => {
        this.keyUp(i);
      }), this.addPrefix(), this.addSuffix(), this.addSearch(), this.addMultiSearch(), this.change(new Event("change"));
    } else console.log("ERROR: w2field could only be applied to INPUT or TEXTAREA.", this.el);
  }
  get() {
    return ["list", "enum", "file"].indexOf(this.type) !== -1 ? this.selected : p(this.el).val();
  }
  set(e, t) {
    ["list", "enum", "file"].indexOf(this.type) !== -1 ? (this.type !== "list" && t ? (Array.isArray(this.selected) || (this.selected = []), this.selected.push(e), (t = Ot.get(this.el.id + "_menu")) && (t.options.selected = this.selected)) : (e == null && (e = []), t = this.type !== "enum" || Array.isArray(e) ? e : [e], this.selected = t), p(this.el).trigger("input").trigger("change"), this.refresh()) : p(this.el).val(e);
  }
  setIndex(e, t) {
    if (["list", "enum"].indexOf(this.type) !== -1) {
      var i = this.options.items;
      if (i && i[e]) return this.type == "list" && (this.selected = i[e]), this.type == "enum" && (t || (this.selected = []), this.selected.push(i[e])), (t = Ot.get(this.el.id + "_menu")) && (t.options.selected = this.selected), p(this.el).trigger("input").trigger("change"), this.refresh(), true;
    }
    return false;
  }
  refresh() {
    var _a2, _b2;
    let e = this.options;
    var t = Date.now(), i = getComputedStyle(this.el);
    if (this.type == "list") {
      if (p(this.el).parent().css("white-space", "nowrap"), this.helpers.prefix && this.helpers.prefix.hide(), !this.helpers.search) return;
      this.selected == null && e.icon ? e.prefix = `
                    <span class="w2ui-icon ${e.icon} "style="cursor: pointer; font-size: 14px;
                        display: inline-block; margin-top: -1px; color: #7F98AD; ${e.iconStyle}">
                    </span>` : e.prefix = "", this.addPrefix();
      let l = p(this.helpers.search_focus);
      var n = p(l[0].previousElementSibling);
      l.css({ outline: "none" }), l.val() === "" ? (l.css("opacity", 0), n.css("opacity", 0), ((_a2 = this.selected) == null ? void 0 : _a2.id) ? (a = this.selected.text, o = this.findItemIndex(e.items, this.selected.id), a != null && p(this.el).val(b.lang(a)).data({ selected: a, selectedIndex: o[0] })) : (this.el.value = "", p(this.el).removeData("selected selectedIndex"))) : (l.css("opacity", 1), n.css("opacity", 1), p(this.el).val(""), setTimeout(() => {
        this.helpers.prefix && this.helpers.prefix.hide(), e.icon ? (l.css("margin-left", "17px"), p(this.helpers.search).find(".w2ui-icon-search").addClass("show-search")) : (l.css("margin-left", "0px"), p(this.helpers.search).find(".w2ui-icon-search").removeClass("show-search"));
      }, 1)), p(this.el).prop("readOnly") || p(this.el).prop("disabled") ? setTimeout(() => {
        this.helpers.prefix && p(this.helpers.prefix).css("opacity", "0.6"), this.helpers.suffix && p(this.helpers.suffix).css("opacity", "0.6");
      }, 1) : setTimeout(() => {
        this.helpers.prefix && p(this.helpers.prefix).css("opacity", "1"), this.helpers.suffix && p(this.helpers.suffix).css("opacity", "1");
      }, 1);
    }
    let r = this.helpers.multi;
    if (["enum", "file"].includes(this.type) && r) {
      let l = "";
      Array.isArray(this.selected) && this.selected.forEach((c, h) => {
        c != null && (l += `
                        <div class="li-item" index="${h}" style="max-width: ${parseInt(e.maxItemWidth)}px; ${c.style || ""}">
                        ${typeof e.renderItem == "function" ? e.renderItem(c, h, `<div class="w2ui-list-remove" index="${h}">&#160;&#160;</div>`) : `
                               ${c.icon ? `<span class="w2ui-icon ${c.icon}"></span>` : ""}
                               <div class="w2ui-list-remove" index="${h}">&#160;&#160;</div>
                               ${(this.type === "enum" ? c.text : c.name) ?? c.id ?? c}
                               ${c.size ? `<span class="file-size"> - ${b.formatSize(c.size)}</span>` : ""}
                            `}
                        </div>`);
      });
      var o, a = r.find(".w2ui-multi-items");
      e.style && r.attr("style", r.attr("style") + ";" + e.style), p(this.el).css("z-index", "-1"), p(this.el).prop("readOnly") || p(this.el).prop("disabled") ? setTimeout(() => {
        r[0].scrollTop = 0, r.addClass("w2ui-readonly").find(".li-item").css("opacity", "0.9").parent().find(".li-search").hide().find("input").prop("readOnly", true).closest(".w2ui-multi-items").find(".w2ui-list-remove").hide();
      }, 1) : setTimeout(() => {
        r.removeClass("w2ui-readonly").find(".li-item").css("opacity", "1").parent().find(".li-search").show().find("input").prop("readOnly", false).closest(".w2ui-multi-items").find(".w2ui-list-remove").show();
      }, 1), 0 < ((_b2 = this.selected) == null ? void 0 : _b2.length) && p(this.el).attr("placeholder", ""), r.find(".w2ui-enum-placeholder").remove(), a.find(".li-item").remove(), l !== "" ? a.prepend(l) : p(this.el).attr("placeholder") != null && r.find("input").val() === "" && (o = b.stripSpaces(`
                    padding-top: ${i["padding-top"]};
                    padding-left: ${i["padding-left"]};
                    box-sizing: ${i["box-sizing"]};
                    line-height: ${i["line-height"]};
                    font-size: ${i["font-size"]};
                    font-family: ${i["font-family"]};
                `), r.prepend(`<div class="w2ui-enum-placeholder" style="${o}">${p(this.el).attr("placeholder")}</div>`)), r.off(".w2item").on("scroll.w2item", (c) => {
        c = this.trigger("scroll", { target: this.el, originalEvent: c }), c.isCancelled !== true && (Ge.hide(this.el.id + "_preview"), c.finish());
      }).find(".li-item").on("click.w2item", (c) => {
        var h = p(c.target).closest(".li-item"), d = h.attr("index"), u = this.selected[d];
        if (!p(h).hasClass("li-search")) {
          c.stopPropagation();
          let f;
          if (p(c.target).hasClass("w2ui-list-remove")) p(this.el).prop("readOnly") || p(this.el).prop("disabled") || (f = this.trigger("remove", { target: this.el, originalEvent: c, item: u })).isCancelled !== true && (this.selected.splice(d, 1), p(this.el).trigger("input").trigger("change"), p(c.target).remove());
          else if ((f = this.trigger("click", { target: this.el, originalEvent: c.originalEvent, item: u })).isCancelled !== true) {
            let m = u.tooltip;
            if (this.type === "file" && (/image/i.test(u.type) && (m = `
                                    <div class="w2ui-file-preview">
                                        <img src="${u.content ? "data:" + u.type + ";base64," + u.content : ""}"
                                            style="max-width: 300px">
                                    </div>`), m += `
                                <div class="w2ui-file-info">
                                    <div class="file-caption">${b.lang("Name")}:</div>
                                    <div class="file-value">${u.name}</div>
                                    <div class="file-caption">${b.lang("Size")}:</div>
                                    <div class="file-value">${b.formatSize(u.size)}</div>
                                    <div class="file-caption">${b.lang("Type")}:</div>
                                    <div class="file-value file-type">${u.type}</div>
                                    <div class="file-caption">${b.lang("Modified")}:</div>
                                    <div class="file-value">${b.date(u.modified)}</div>
                                </div>`), m) {
              let _ = this.el.id + "_preview";
              Ge.show({ name: _, anchor: h.get(0), html: m, hideOn: ["doc-click"], class: "" }).show((g) => {
                p(`#w2overlay-${_} img`).on("load", function(v) {
                  var y = this.clientWidth, x = this.clientHeight;
                  y < 300 & x < 300 || (x <= y && 300 < y && p(this).css("width", "300px"), y < x && 300 < x && p(this).css("height", "300px"));
                }).on("error", function(v) {
                  this.style.display = "none";
                });
              });
            }
            f.finish();
          }
        }
      }).on("mouseenter.w2item", (c) => {
        var h = p(c.target).closest(".li-item");
        p(h).hasClass("li-search") || (h = this.selected[p(c.target).attr("index")], (c = this.trigger("mouseEnter", { target: this.el, originalEvent: c, item: h })).isCancelled !== true && c.finish());
      }).on("mouseleave.w2item", (c) => {
        var h = p(c.target).closest(".li-item");
        p(h).hasClass("li-search") || (h = this.selected[p(c.target).attr("index")], (c = this.trigger("mouseLeave", { target: this.el, originalEvent: c, item: h })).isCancelled !== true && c.finish());
      }), this.type === "enum" ? this.helpers.multi.find("input").css({ width: "15px" }) : this.helpers.multi.find(".li-search").hide(), this.resize();
    }
    return Date.now() - t;
  }
  resize() {
    var e = this.el.clientWidth, t = getComputedStyle(this.el), o = this.helpers.search, i = this.helpers.multi, n = this.helpers.suffix, r = this.helpers.prefix, o = (o && p(o).css("width", e), i && p(i).css("width", e - parseInt(t["margin-left"], 10) - parseInt(t["margin-right"], 10)), n && this.addSuffix(), r && this.addPrefix(), this.helpers.multi);
    if (["enum", "file"].includes(this.type) && o) {
      p(this.el).css("height", "auto");
      let a = p(o).find(":scope div.w2ui-multi-items").get(0).clientHeight + 5;
      (a = (a = a < 20 ? 20 : a) > this.tmp["max-height"] ? this.tmp["max-height"] : a) < this.tmp["min-height"] && (a = this.tmp["min-height"]), i = b.getSize(this.el, "height") - 2, i > a && (a = i), p(o).css({ height: a + "px", overflow: a == this.tmp["max-height"] ? "auto" : "hidden" }), p(o).css("height", a + "px"), p(this.el).css({ height: a + "px" });
    }
    this.tmp.current_width = e;
  }
  reset() {
    this.tmp != null && (p(this.el).css("height", "auto"), Array("padding-left", "padding-right", "background-color", "border-color").forEach((e) => {
      this.tmp && this.tmp["old-" + e] != null && (p(this.el).css(e, this.tmp["old-" + e]), delete this.tmp["old-" + e]);
    }), clearInterval(this.tmp.sizeTimer)), p(this.el).val(this.clean(p(this.el).val())).removeClass("w2field").removeData("selected selectedIndex").off(".w2field"), Object.keys(this.helpers).forEach((e) => {
      p(this.helpers[e]).remove();
    }), this.helpers = {};
  }
  clean(e) {
    var t;
    return e = typeof e != "number" && (t = this.options, e = String(e).trim(), ["int", "float", "money", "currency", "percent"].includes(this.type)) ? (e = typeof e == "string" ? (e = t.autoFormat && (["money", "currency"].includes(this.type) && (e = String(e).replace(t.moneyRE, "")), this.type === "percent" && (e = String(e).replace(t.percentRE, "")), ["int", "float"].includes(this.type)) ? String(e).replace(t.numberRE, "") : e).replace(/\s+/g, "").replace(new RegExp(t.groupSymbol, "g"), "").replace(t.decimalSymbol, ".") : e) !== "" && b.isFloat(e) ? Number(e) : "" : e;
  }
  format(e) {
    var t = this.options;
    if (t.autoFormat && e !== "") {
      switch (this.type) {
        case "money":
        case "currency":
          (e = b.formatNumber(e, t.currencyPrecision, true)) !== "" && (e = t.currencyPrefix + e + t.currencySuffix);
          break;
        case "percent":
          (e = b.formatNumber(e, t.precision, true)) !== "" && (e += "%");
          break;
        case "float":
          e = b.formatNumber(e, t.precision, true);
          break;
        case "int":
          e = b.formatNumber(e, 0, true);
      }
      var i = parseInt(1e3).toLocaleString(b.settings.locale, { useGrouping: true }).slice(1, 2);
      i !== this.options.groupSymbol && (e = e.replaceAll(i, this.options.groupSymbol));
    }
    return e;
  }
  change(e) {
    if (["int", "float", "money", "currency", "percent"].indexOf(this.type) !== -1) {
      var t = p(this.el).val(), i = this.format(this.clean(p(this.el).val()));
      if (t !== "" && t != i) return p(this.el).val(i), e.stopPropagation(), e.preventDefault(), false;
    }
    if (this.type === "color") {
      let n = p(this.el).val();
      n.substr(0, 3).toLowerCase() !== "rgb" && (n = "#" + n, (t = p(this.el).val().length) !== 8) && t !== 6 && t !== 3 && (n = ""), i = p(this.el).get(0).nextElementSibling, p(i).find("div").css("background-color", n), p(this.el).hasClass("has-focus") && this.updateOverlay();
    }
    if (["list", "enum", "file"].indexOf(this.type) !== -1 && this.refresh(), ["date", "time", "datetime"].indexOf(this.type) !== -1) {
      let n = parseInt(this.el.value);
      b.isInt(this.el.value) && 3e3 < n && (this.type === "time" && (n = b.formatTime(new Date(n), this.options.format)), this.type === "date" && (n = b.formatDate(new Date(n), this.options.format)), this.type === "datetime" && (n = b.formatDateTime(new Date(n), this.options.format)), p(this.el).val(n).trigger("input").trigger("change"));
    }
  }
  click(e) {
    ["list", "combo", "enum"].includes(this.type) && (p(this.el).hasClass("has-focus") || this.focus(e), this.type == "combo" && this.updateOverlay(), this.type == "list") && (this.updateOverlay(), e.stopPropagation()), ["date", "time", "datetime", "color"].includes(this.type) && this.updateOverlay();
  }
  focus(e) {
    if (this.type == "list" && document.activeElement == this.el) this.helpers.search_focus.focus();
    else {
      if (["color", "date", "time", "datetime"].indexOf(this.type) !== -1) {
        if (p(this.el).prop("readOnly") || p(this.el).prop("disabled")) return;
        this.updateOverlay();
      }
      if (["list", "combo", "enum"].indexOf(this.type) !== -1) {
        if (p(this.el).prop("readOnly") || p(this.el).prop("disabled")) return void p(this.el).addClass("has-focus");
        typeof this.options._items_fun == "function" && (this.options.items = b.normMenu.call(this, this.options._items_fun)), this.helpers.search && ((t = this.helpers.search_focus).value = "", t.select()), this.type == "enum" && (t = p(this.el.previousElementSibling).find(".li-search input").get(0), document.activeElement !== t) && t.focus(), this.resize(), e.showMenu === false || this.options.openOnFocus === false && !p(this.el).hasClass("has-focus") || setTimeout(() => {
          this.updateOverlay();
        }, 100);
      }
      var t;
      this.type == "file" && (t = p(this.el).get(0).previousElementSibling, p(t).addClass("has-focus")), p(this.el).addClass("has-focus");
    }
  }
  blur(e) {
    var _a2;
    var t, i = p(this.el).val().trim();
    if (p(this.el).removeClass("has-focus"), ["int", "float", "money", "currency", "percent"].includes(this.type) && i !== "") {
      let n = i, r = "";
      this.isStrValid(i) ? (t = this.clean(i), this.options.min != null && t < this.options.min && (n = this.options.min, r = "Should be >= " + this.options.min), this.options.max != null && t > this.options.max && (n = this.options.max, r = "Should be <= " + this.options.max)) : n = "", this.options.autoCorrect && (p(this.el).val(n).trigger("input").trigger("change"), r) && (Ge.show({ name: this.el.id + "_error", anchor: this.el, html: r }), setTimeout(() => {
        Ge.hide(this.el.id + "_error");
      }, 3e3));
    }
    ["date", "time", "datetime"].includes(this.type) && this.options.autoCorrect && i !== "" && (t = this.type == "date" ? b.isDate : this.type == "time" ? b.isTime : b.isDateTime, er.inRange(this.el.value, this.options) && t.bind(b)(this.el.value, this.options.format) || p(this.el).val("").trigger("input").trigger("change")), this.type === "enum" && p(this.helpers.multi).find("input").val("").css("width", "15px"), this.type == "file" && (i = this.el.previousElementSibling, p(i).removeClass("has-focus")), this.type === "list" && (this.el.value = ((_a2 = this.selected) == null ? void 0 : _a2.text) ?? "");
  }
  keyDown(e, r) {
    var i, n = this.options, r = e.keyCode || r && r.keyCode;
    let o = false, a, l, c, h, d, u;
    if (["int", "float", "money", "currency", "percent", "hex", "bin", "color", "alphanumeric"].includes(this.type) && !(e.metaKey || e.ctrlKey || e.altKey || this.isStrValid(e.key ?? "1", true) || [9, 8, 13, 27, 37, 38, 39, 40, 46].includes(e.keyCode))) return e.preventDefault(), e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true, false;
    if (["int", "float", "money", "currency", "percent"].includes(this.type)) {
      if (!n.keyboard || p(this.el).prop("readOnly") || p(this.el).prop("disabled")) return;
      switch (a = parseFloat(p(this.el).val().replace(n.moneyRE, "")) || 0, l = n.step, (e.ctrlKey || e.metaKey) && (l = 10 * n.step), r) {
        case 38:
          e.shiftKey || (d = a + l <= n.max || n.max == null ? Number((a + l).toFixed(12)) : n.max, p(this.el).val(d).trigger("input").trigger("change"), o = true);
          break;
        case 40:
          e.shiftKey || (d = a - l >= n.min || n.min == null ? Number((a - l).toFixed(12)) : n.min, p(this.el).val(d).trigger("input").trigger("change"), o = true);
      }
      o && (e.preventDefault(), this.moveCaret2end());
    }
    if (["date", "datetime"].includes(this.type)) {
      if (!n.keyboard || p(this.el).prop("readOnly") || p(this.el).prop("disabled")) return;
      var f = (this.type == "date" ? b.isDate : b.isDateTime).bind(b), m = (this.type == "date" ? b.formatDate : b.formatDateTime).bind(b);
      switch (c = 864e5, l = 1, (e.ctrlKey || e.metaKey) && (l = 10), (h = f(p(this.el).val(), n.format, true)) || (h = /* @__PURE__ */ new Date(), c = 0), r) {
        case 38:
          e.shiftKey || (l == 10 ? h.setMonth(h.getMonth() + 1) : h.setTime(h.getTime() + c), u = m(h.getTime(), n.format), p(this.el).val(u).trigger("input").trigger("change"), o = true);
          break;
        case 40:
          e.shiftKey || (l == 10 ? h.setMonth(h.getMonth() - 1) : h.setTime(h.getTime() - c), u = m(h.getTime(), n.format), p(this.el).val(u).trigger("input").trigger("change"), o = true);
      }
      o && (e.preventDefault(), this.moveCaret2end(), this.updateOverlay());
    }
    if (this.type === "time") {
      if (!n.keyboard || p(this.el).prop("readOnly") || p(this.el).prop("disabled")) return;
      l = e.ctrlKey || e.metaKey ? 60 : 1, a = p(this.el).val();
      let _ = er.str2min(a) || er.str2min((/* @__PURE__ */ new Date()).getHours() + ":" + ((/* @__PURE__ */ new Date()).getMinutes() - 1));
      switch (r) {
        case 38:
          e.shiftKey || (_ += l, o = true);
          break;
        case 40:
          e.shiftKey || (_ -= l, o = true);
      }
      o && (e.preventDefault(), p(this.el).val(er.min2str(_)).trigger("input").trigger("change"), this.moveCaret2end());
    }
    if (["list", "enum"].includes(this.type)) switch (r) {
      case 8:
      case 46:
        this.type == "list" ? p(this.helpers.search_focus).val() == "" && (this.selected = null, Ot.hide(this.el.id + "_menu"), p(this.el).val("").trigger("input").trigger("change")) : p(this.helpers.multi).find("input").val() == "" && (Ot.hide(this.el.id + "_menu"), this.selected.pop(), (i = Ot.get(this.el.id + "_menu")) && (i.options.selected = this.selected), this.refresh());
        break;
      case 9:
      case 16:
        break;
      case 27:
        Ot.hide(this.el.id + "_menu"), this.refresh();
    }
  }
  keyUp(e) {
    var _a2, _b2;
    if (this.type == "list") {
      let n = p(this.helpers.search_focus);
      n.val() !== "" ? p(this.el).attr("placeholder", "") : p(this.el).attr("placeholder", this.tmp.pholder), e.keyCode == 13 && setTimeout(() => {
        n.val(""), Ot.hide(this.el.id + "_menu"), this.refresh();
      }, 1), [38, 40].includes(e.keyCode) && !this.tmp.overlay.overlay.displayed && this.updateOverlay(), this.refresh();
    }
    var t, i;
    this.type == "combo" && this.updateOverlay(), this.type == "enum" && (t = this.helpers.multi.find("input"), i = getComputedStyle(t.get(0)), i = b.getStrWidth(t.val(), `font-family: ${i["font-family"]}; font-size: ${i["font-size"]};`), t.css({ width: i + 15 + "px" }), this.resize(), [38, 40].includes(e.keyCode)) && !((_b2 = (_a2 = this.tmp.overlay) == null ? void 0 : _a2.overlay) == null ? void 0 : _b2.displayed) && this.updateOverlay();
  }
  findItemIndex(e, t, i) {
    let n = [];
    var r;
    return i = i || [], ["list", "combo", "enum"].includes(this.type) && this.options.url && (r = Ot.get(this.el.id + "_menu")) && (e = r.options.items, this.options.items = e), e.forEach((o, a) => {
      o.id === t && (n = i.concat([a]), this.options.index = [a]), n.length == 0 && o.items && 0 < o.items.length && (i.push(a), n = this.findItemIndex(o.items, t, i), i.pop());
    }), n;
  }
  updateOverlay(e) {
    let t = this.options;
    if (this.type === "color") {
      if (p(this.el).prop("readOnly") || p(this.el).prop("disabled")) return;
      rf.show(b.extend({ name: this.el.id + "_color", anchor: this.el, transparent: t.transparent, advanced: t.advanced, color: this.el.value, liveUpdate: true }, this.options)).select((n) => {
        n = n.detail.color, p(this.el).val(n).trigger("input").trigger("change");
      }).liveUpdate((n) => {
        n = n.detail.color, p(this.helpers.suffix).find(":scope > div").css("background-color", "#" + n);
      });
    }
    if (["list", "combo", "enum"].includes(this.type)) {
      var i;
      this.el;
      let n = this.el;
      this.type === "enum" && (i = this.helpers.multi.get(0), n = p(i).find("input").get(0)), this.type === "list" && (i = this.selected, b.isPlainObject(i) && 0 < Object.keys(i).length && 0 < (i = this.findItemIndex(t.items, i.id)).length && (t.index = i), n = this.helpers.search_focus), !p(this.el).hasClass("has-focus") || this.el.readOnly || this.el.disabled || (i = b.extend({}, t, { name: this.el.id + "_menu", anchor: n, selected: this.selected, search: false, render: t.renderDrop, anchorClass: "", offsetY: 5, maxHeight: t.maxDropHeight, maxWidth: t.maxDropWidth, minWidth: t.minDropWidth }), this.tmp.overlay = Ot.show(i).select((r) => {
        var _a2;
        var o, a;
        ["list", "combo"].includes(this.type) ? (this.selected = r.detail.item, p(n).val(""), p(this.el).val(this.selected.text).trigger("input").trigger("change"), this.focus({ showMenu: false })) : (a = this.selected, (o = (_a2 = r.detail) == null ? void 0 : _a2.item) && (r = this.trigger("add", { target: this.el, item: o, originalEvent: r })).isCancelled !== true && (a.length >= t.max && 0 < t.max && a.pop(), delete o.hidden, a.push(o), p(this.el).trigger("input").trigger("change"), p(this.helpers.multi).find("input").val(""), (a = Ot.get(this.el.id + "_menu")) && (a.options.selected = this.selected), r.finish()));
      }));
    }
    !["date", "time", "datetime"].includes(this.type) || p(this.el).prop("readOnly") || p(this.el).prop("disabled") || er.show(b.extend({ name: this.el.id + "_date", anchor: this.el, value: this.el.value }, this.options)).select((n) => {
      n = n.detail.date, n != null && p(this.el).val(n).trigger("input").trigger("change");
    });
  }
  isStrValid(e, t) {
    let i = true;
    switch (this.type) {
      case "int":
        i = !(!t || !["-", this.options.groupSymbol].includes(e)) || b.isInt(e.replace(this.options.numberRE, ""));
        break;
      case "percent":
        e = e.replace(/%/g, "");
      case "float":
        i = !(!t || !["-", "", this.options.decimalSymbol, this.options.groupSymbol].includes(e)) || b.isFloat(e.replace(this.options.numberRE, ""));
        break;
      case "money":
      case "currency":
        i = !(!t || !["-", this.options.decimalSymbol, this.options.groupSymbol, this.options.currencyPrefix, this.options.currencySuffix].includes(e)) || b.isFloat(e.replace(this.options.moneyRE, ""));
        break;
      case "bin":
        i = b.isBin(e);
        break;
      case "color":
      case "hex":
        i = b.isHex(e);
        break;
      case "alphanumeric":
        i = b.isAlphaNumeric(e);
    }
    return i;
  }
  addPrefix() {
    var e, t;
    this.options.prefix && (t = getComputedStyle(this.el), this.tmp["old-padding-left"] == null && (this.tmp["old-padding-left"] = t["padding-left"]), this.helpers.prefix && p(this.helpers.prefix).remove(), p(this.el).before(`<div class="w2ui-field-helper">${this.options.prefix}</div>`), e = p(this.el).get(0).previousElementSibling, p(e).css({ color: t.color, "font-family": t["font-family"], "font-size": t["font-size"], height: this.el.clientHeight + "px", "padding-top": t["padding-top"], "padding-bottom": t["padding-bottom"], "padding-left": this.tmp["old-padding-left"], "padding-right": 0, "margin-top": parseInt(t["margin-top"], 10) + 2 + "px", "margin-bottom": parseInt(t["margin-bottom"], 10) + 1 + "px", "margin-left": t["margin-left"], "margin-right": 0, "z-index": 1 }), p(this.el).css("padding-left", e.clientWidth + "px !important"), this.helpers.prefix = e);
  }
  addSuffix() {
    if (this.options.suffix || this.options.arrow) {
      let i, n = this;
      var e = getComputedStyle(this.el), t = (this.tmp["old-padding-right"] == null && (this.tmp["old-padding-right"] = e["padding-right"]), parseInt(e["padding-right"] || 0));
      this.options.arrow && (this.helpers.arrow && p(this.helpers.arrow).remove(), p(this.el).after('<div class="w2ui-field-helper" style="border: 1px solid transparent">&#160;    <div class="w2ui-field-up" type="up">        <div class="arrow-up" type="up"></div>    </div>    <div class="w2ui-field-down" type="down">        <div class="arrow-down" type="down"></div>    </div></div>'), i = p(this.el).get(0).nextElementSibling, p(i).css({ color: e.color, "font-family": e["font-family"], "font-size": e["font-size"], height: this.el.clientHeight + "px", padding: 0, "margin-top": parseInt(e["margin-top"], 10) + 1 + "px", "margin-bottom": 0, "border-left": "1px solid silver", width: "16px", transform: "translateX(-100%)" }).on("mousedown", function(r) {
        p(r.target).hasClass("arrow-up") && n.keyDown(r, { keyCode: 38 }), p(r.target).hasClass("arrow-down") && n.keyDown(r, { keyCode: 40 });
      }), t += i.clientWidth, p(this.el).css("padding-right", t + "px !important"), this.helpers.arrow = i), this.options.suffix !== "" && (this.helpers.suffix && p(this.helpers.suffix).remove(), p(this.el).after(`<div class="w2ui-field-helper">${this.options.suffix}</div>`), i = p(this.el).get(0).nextElementSibling, p(i).css({ color: e.color, "font-family": e["font-family"], "font-size": e["font-size"], height: this.el.clientHeight + "px", "padding-top": e["padding-top"], "padding-bottom": e["padding-bottom"], "padding-left": 0, "padding-right": e["padding-right"], "margin-top": parseInt(e["margin-top"], 10) + 2 + "px", "margin-bottom": parseInt(e["margin-bottom"], 10) + 1 + "px", transform: "translateX(-100%)" }), p(this.el).css("padding-right", i.clientWidth + "px !important"), this.helpers.suffix = i);
    }
  }
  addSearch() {
    if (this.type === "list") {
      this.helpers.search && p(this.helpers.search).remove();
      let i = parseInt(p(this.el).attr("tabIndex")), n = (isNaN(i) || i === -1 || (this.tmp["old-tabIndex"] = i), (i = this.tmp["old-tabIndex"] ? this.tmp["old-tabIndex"] : i) != null && !isNaN(i) || (i = 0), "");
      var e = `
            <div class="w2ui-field-helper">
                <span class="w2ui-icon w2ui-icon-search"></span>
                <input ${n = p(this.el).attr("id") != null ? 'id="' + p(this.el).attr("id") + '_search"' : n} type="text" tabIndex="${i}" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false"/>
            </div>`, e = (p(this.el).attr("tabindex", -1).before(e), p(this.el).get(0).previousElementSibling), t = (this.helpers.search = e, this.helpers.search_focus = p(e).find("input").get(0), getComputedStyle(this.el));
      p(e).css({ width: this.el.clientWidth + "px", "margin-top": t["margin-top"], "margin-left": t["margin-left"], "margin-bottom": t["margin-bottom"], "margin-right": t["margin-right"] }).find("input").css({ cursor: "default", width: "100%", opacity: 1, padding: t.padding, margin: t.margin, border: "1px solid transparent", "background-color": "transparent" }), p(e).find("input").off(".helper").on("focus.helper", (r) => {
        p(r.target).val(""), this.tmp.pholder = p(this.el).attr("placeholder") ?? "", this.focus(r), r.stopPropagation();
      }).on("blur.helper", (r) => {
        p(r.target).val(""), this.tmp.pholder != null && p(this.el).attr("placeholder", this.tmp.pholder), this.blur(r), r.stopPropagation();
      }).on("keydown.helper", (r) => {
        this.keyDown(r);
      }).on("keyup.helper", (r) => {
        this.keyUp(r);
      }), p(e).on("click", (r) => {
        p(r.target).find("input").focus();
      });
    }
  }
  addMultiSearch() {
    if (["enum", "file"].includes(this.type)) {
      p(this.helpers.multi).remove();
      let r = "";
      var e, t, i = getComputedStyle(this.el), n = b.stripSpaces(`
            margin-top: 0px;
            margin-bottom: 0px;
            margin-left: ${i["margin-left"]};
            margin-right: ${i["margin-right"]};
            width: ${b.getSize(this.el, "width") - parseInt(i["margin-left"], 10) - parseInt(i["margin-right"], 10)}px;
        `);
      this.tmp["min-height"] == null && (e = this.tmp["min-height"] = parseInt((i["min-height"] != "none" ? i["min-height"] : 0) || 0), t = parseInt(i.height), this.tmp["min-height"] = Math.max(e, t)), this.tmp["max-height"] == null && i["max-height"] != "none" && (this.tmp["max-height"] = parseInt(i["max-height"]));
      let o = "", a = (p(this.el).attr("id") != null && (o = `id="${p(this.el).attr("id")}_search"`), parseInt(p(this.el).attr("tabIndex"))), l = (isNaN(a) || a === -1 || (this.tmp["old-tabIndex"] = a), (a = this.tmp["old-tabIndex"] ? this.tmp["old-tabIndex"] : a) != null && !isNaN(a) || (a = 0), this.type === "enum" && (r = `
            <div class="w2ui-field-helper w2ui-list" style="${n}">
                <div class="w2ui-multi-items">
                    <div class="li-search">
                        <input ${o} type="text" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false"
                            tabindex="${a}"
                            ${p(this.el).prop("readOnly") ? "readonly" : ""}
                            ${p(this.el).prop("disabled") ? "disabled" : ""}>
                    </div>
                </div>
            </div>`), this.type === "file" && (r = `
            <div class="w2ui-field-helper w2ui-list" style="${n}">
                <div class="w2ui-multi-file">
                    <input name="attachment" class="file-input" type="file" tabindex="-1"'
                        style="width: 100%; height: 100%; opacity: 0" title=""
                        ${this.options.max !== 1 ? "multiple" : ""}
                        ${p(this.el).prop("readOnly") || p(this.el).prop("disabled") ? "disabled" : ""}
                        ${p(this.el).attr("accept") ? ' accept="' + p(this.el).attr("accept") + '"' : ""}>
                </div>
                <div class="w2ui-multi-items">
                    <div class="li-search" style="display: none">
                        <input ${o} type="text" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false"
                            tabindex="${a}"
                            ${p(this.el).prop("readOnly") ? "readonly" : ""}
                            ${p(this.el).prop("disabled") ? "disabled" : ""}>
                    </div>
                </div>
            </div>`), this.tmp["old-background-color"] = i["background-color"], this.tmp["old-border-color"] = i["border-color"], p(this.el).before(r).css({ "border-color": "transparent", "background-color": "transparent" }), p(this.el.previousElementSibling));
      this.helpers.multi = l, p(this.el).attr("tabindex", -1), l.on("click", (c) => {
        this.focus(c);
      }), l.find("input:not(.file-input)").on("click", (c) => {
        this.click(c);
      }).on("focus", (c) => {
        this.focus(c);
      }).on("blur", (c) => {
        this.blur(c);
      }).on("keydown", (c) => {
        this.keyDown(c);
      }).on("keyup", (c) => {
        this.keyUp(c);
      }), this.type === "file" && l.find("input.file-input").off(".drag").on("click.drag", (c) => {
        c.stopPropagation(), p(this.el).prop("readOnly") || p(this.el).prop("disabled") || this.focus(c);
      }).on("dragenter.drag", (c) => {
        p(this.el).prop("readOnly") || p(this.el).prop("disabled") || l.addClass("w2ui-file-dragover");
      }).on("dragleave.drag", (c) => {
        p(this.el).prop("readOnly") || p(this.el).prop("disabled") || l.removeClass("w2ui-file-dragover");
      }).on("drop.drag", (c) => {
        p(this.el).prop("readOnly") || p(this.el).prop("disabled") || (l.removeClass("w2ui-file-dragover"), Array.from(c.dataTransfer.files).forEach((h) => {
          this.addFile(h);
        }), this.focus(c), c.preventDefault(), c.stopPropagation());
      }).on("dragover.drag", (c) => {
        c.preventDefault(), c.stopPropagation();
      }).on("change.drag", (c) => {
        c.target.files !== void 0 && Array.from(c.target.files).forEach((h) => {
          this.addFile(h);
        }), this.focus(c);
      }), this.refresh();
    }
  }
  addFile(e) {
    var t = this.options, i = this.selected;
    let n = { name: e.name, type: e.type, modified: e.lastModifiedDate, size: e.size, content: null, file: e }, r = 0, o = 0, a = [], l = (Array.isArray(i) && i.forEach((c) => {
      c.name == e.name && c.size == e.size && a.push(b.lang('The file "${name}" (${size}) is already added.', { name: e.name, size: b.formatSize(e.size) })), r += c.size, o++;
    }), t.maxFileSize !== 0 && n.size > t.maxFileSize && a.push(b.lang("Maximum file size is ${size}", { size: b.formatSize(t.maxFileSize) })), t.maxSize !== 0 && r + n.size > t.maxSize && a.push(b.lang("Maximum total size is ${size}", { size: b.formatSize(t.maxSize) })), t.max !== 0 && o >= t.max && a.push(b.lang("Maximum number of files is ${count}", { count: t.max })), this.trigger("add", { target: this.el, file: n, total: o, totalSize: r, errors: a }));
    if (l.isCancelled !== true) if (t.silent !== true && 0 < a.length) Ge.show({ anchor: this.el, html: "Errors: " + a.join("<br>") }), console.log("ERRORS (while adding files): ", a);
    else if (i.push(n), typeof FileReader < "u" && t.readContent === true) {
      i = new FileReader();
      let c = this;
      i.onload = function(d) {
        var d = d.target.result, u = d.indexOf(",");
        n.content = d.substr(u + 1), c.refresh(), p(c.el).trigger("input").trigger("change"), l.finish();
      }, i.readAsDataURL(e);
    } else this.refresh(), p(this.el).trigger("input").trigger("change"), l.finish();
  }
  moveCaret2end() {
    setTimeout(() => {
      this.el.setSelectionRange(this.el.value.length, this.el.value.length);
    }, 0);
  }
}
/**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
const eh = globalThis, Jo = eh.trustedTypes, Qd = Jo ? Jo.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, of = "$lit$", nn = `lit$${Math.random().toFixed(9).slice(2)}$`, af = "?" + nn, wM = `<${af}>`, Hn = document, br = () => Hn.createComment(""), xr = (s) => s === null || typeof s != "object" && typeof s != "function", th = Array.isArray, yM = (s) => th(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", rl = `[ 	
\f\r]`, tr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, eu = /-->/g, tu = />/g, Cn = RegExp(`>|${rl}(?:([^\\s"'>=/]+)(${rl}*=${rl}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), iu = /'/g, nu = /"/g, lf = /^(?:script|style|textarea|title)$/i, SM = (s) => (e, ...t) => ({ _$litType$: s, strings: e, values: t }), ko = SM(1), wr = Symbol.for("lit-noChange"), Dt = Symbol.for("lit-nothing"), su = /* @__PURE__ */ new WeakMap(), Ln = Hn.createTreeWalker(Hn, 129);
function cf(s, e) {
  if (!th(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Qd !== void 0 ? Qd.createHTML(e) : e;
}
const EM = (s, e) => {
  const t = s.length - 1, i = [];
  let n, r = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = tr;
  for (let a = 0; a < t; a++) {
    const l = s[a];
    let c, h, d = -1, u = 0;
    for (; u < l.length && (o.lastIndex = u, h = o.exec(l), h !== null); ) u = o.lastIndex, o === tr ? h[1] === "!--" ? o = eu : h[1] !== void 0 ? o = tu : h[2] !== void 0 ? (lf.test(h[2]) && (n = RegExp("</" + h[2], "g")), o = Cn) : h[3] !== void 0 && (o = Cn) : o === Cn ? h[0] === ">" ? (o = n ?? tr, d = -1) : h[1] === void 0 ? d = -2 : (d = o.lastIndex - h[2].length, c = h[1], o = h[3] === void 0 ? Cn : h[3] === '"' ? nu : iu) : o === nu || o === iu ? o = Cn : o === eu || o === tu ? o = tr : (o = Cn, n = void 0);
    const f = o === Cn && s[a + 1].startsWith("/>") ? " " : "";
    r += o === tr ? l + wM : d >= 0 ? (i.push(c), l.slice(0, d) + of + l.slice(d) + nn + f) : l + nn + (d === -2 ? a : f);
  }
  return [cf(s, r + (s[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), i];
};
class yr {
  constructor({ strings: e, _$litType$: t }, i) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = e.length - 1, l = this.parts, [c, h] = EM(e, t);
    if (this.el = yr.createElement(c, i), Ln.currentNode = this.el.content, t === 2 || t === 3) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (n = Ln.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes()) for (const d of n.getAttributeNames()) if (d.endsWith(of)) {
          const u = h[o++], f = n.getAttribute(d).split(nn), m = /([.?@])?(.*)/.exec(u);
          l.push({ type: 1, index: r, name: m[2], strings: f, ctor: m[1] === "." ? CM : m[1] === "?" ? TM : m[1] === "@" ? AM : aa }), n.removeAttribute(d);
        } else d.startsWith(nn) && (l.push({ type: 6, index: r }), n.removeAttribute(d));
        if (lf.test(n.tagName)) {
          const d = n.textContent.split(nn), u = d.length - 1;
          if (u > 0) {
            n.textContent = Jo ? Jo.emptyScript : "";
            for (let f = 0; f < u; f++) n.append(d[f], br()), Ln.nextNode(), l.push({ type: 2, index: ++r });
            n.append(d[u], br());
          }
        }
      } else if (n.nodeType === 8) if (n.data === af) l.push({ type: 2, index: r });
      else {
        let d = -1;
        for (; (d = n.data.indexOf(nn, d + 1)) !== -1; ) l.push({ type: 7, index: r }), d += nn.length - 1;
      }
      r++;
    }
  }
  static createElement(e, t) {
    const i = Hn.createElement("template");
    return i.innerHTML = e, i;
  }
}
function Ns(s, e, t = s, i) {
  var _a2, _b2;
  if (e === wr) return e;
  let n = i !== void 0 ? (_a2 = t._$Co) == null ? void 0 : _a2[i] : t._$Cl;
  const r = xr(e) ? void 0 : e._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((_b2 = n == null ? void 0 : n._$AO) == null ? void 0 : _b2.call(n, false), r === void 0 ? n = void 0 : (n = new r(s), n._$AT(s, t, i)), i !== void 0 ? (t._$Co ?? (t._$Co = []))[i] = n : t._$Cl = n), n !== void 0 && (e = Ns(s, n._$AS(s, e.values), n, i)), e;
}
class MM {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: i } = this._$AD, n = ((e == null ? void 0 : e.creationScope) ?? Hn).importNode(t, true);
    Ln.currentNode = n;
    let r = Ln.nextNode(), o = 0, a = 0, l = i[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new Fr(r, r.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, e) : l.type === 6 && (c = new PM(r, this, e)), this._$AV.push(c), l = i[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = Ln.nextNode(), o++);
    }
    return Ln.currentNode = Hn, n;
  }
  p(e) {
    let t = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
  }
}
class Fr {
  get _$AU() {
    var _a2;
    return ((_a2 = this._$AM) == null ? void 0 : _a2._$AU) ?? this._$Cv;
  }
  constructor(e, t, i, n) {
    this.type = 2, this._$AH = Dt, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? true;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = Ns(this, e, t), xr(e) ? e === Dt || e == null || e === "" ? (this._$AH !== Dt && this._$AR(), this._$AH = Dt) : e !== this._$AH && e !== wr && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : yM(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== Dt && xr(this._$AH) ? this._$AA.nextSibling.data = e : this.T(Hn.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var _a2;
    const { values: t, _$litType$: i } = e, n = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = yr.createElement(cf(i.h, i.h[0]), this.options)), i);
    if (((_a2 = this._$AH) == null ? void 0 : _a2._$AD) === n) this._$AH.p(t);
    else {
      const r = new MM(n, this), o = r.u(this.options);
      r.p(t), this.T(o), this._$AH = r;
    }
  }
  _$AC(e) {
    let t = su.get(e.strings);
    return t === void 0 && su.set(e.strings, t = new yr(e)), t;
  }
  k(e) {
    th(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let i, n = 0;
    for (const r of e) n === t.length ? t.push(i = new Fr(this.O(br()), this.O(br()), this, this.options)) : i = t[n], i._$AI(r), n++;
    n < t.length && (this._$AR(i && i._$AB.nextSibling, n), t.length = n);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var _a2;
    for ((_a2 = this._$AP) == null ? void 0 : _a2.call(this, false, true, t); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var _a2;
    this._$AM === void 0 && (this._$Cv = e, (_a2 = this._$AP) == null ? void 0 : _a2.call(this, e));
  }
}
class aa {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, i, n, r) {
    this.type = 1, this._$AH = Dt, this._$AN = void 0, this.element = e, this.name = t, this._$AM = n, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Dt;
  }
  _$AI(e, t = this, i, n) {
    const r = this.strings;
    let o = false;
    if (r === void 0) e = Ns(this, e, t, 0), o = !xr(e) || e !== this._$AH && e !== wr, o && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = r[0], l = 0; l < r.length - 1; l++) c = Ns(this, a[i + l], t, l), c === wr && (c = this._$AH[l]), o || (o = !xr(c) || c !== this._$AH[l]), c === Dt ? e = Dt : e !== Dt && (e += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    o && !n && this.j(e);
  }
  j(e) {
    e === Dt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class CM extends aa {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Dt ? void 0 : e;
  }
}
class TM extends aa {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Dt);
  }
}
class AM extends aa {
  constructor(e, t, i, n, r) {
    super(e, t, i, n, r), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = Ns(this, e, t, 0) ?? Dt) === wr) return;
    const i = this._$AH, n = e === Dt && i !== Dt || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive, r = e !== Dt && (i === Dt || n);
    n && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var _a2;
    typeof this._$AH == "function" ? this._$AH.call(((_a2 = this.options) == null ? void 0 : _a2.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class PM {
  constructor(e, t, i) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    Ns(this, e);
  }
}
const RM = eh.litHtmlPolyfillSupport;
RM == null ? void 0 : RM(yr, Fr), (eh.litHtmlVersions ?? (eh.litHtmlVersions = [])).push("3.2.1");
const DM = (s, e, t) => {
  const i = e;
  let n = i._$litPart$;
  return n === void 0 && (i._$litPart$ = n = new Fr(e.insertBefore(br(), null), null, void 0, {})), n._$AI(s), n;
};
function FM({ buttons: s, clickedButton: e, author: t, sourceCode: i }) {
  const n = document.createElement("div"), r = ko`
    <div class="buttons-container">
      ${s == null ? void 0 : s.map((l) => ko`<button class="btn btn-text" @click=${o}>
            ${l}
          </button>`)}
      <button class="btn btn-icon" @click=${a}>
        ${LM()}
      </button>
    </div>

    <div id="dropdown-menu" style="display: none;">
      <a
        href="${i || "https://github.com/madil4/awatif"}"
        class="dropdown-link"
        >Source Code</a
      >
      ${t ? ko`<a href="${t}" class="dropdown-link">Message Author</a>` : ""}
      <a href="https://awatif.co/examples" class="dropdown-link"
        >More Examples</a
      >
    </div>
  `;
  n.id = "toolbar", DM(r, n);
  function o(l) {
    const c = l.target;
    e.val = "", setTimeout(() => e.val = c.innerText);
  }
  function a(l) {
    const c = document.getElementById("dropdown-menu");
    c.style.display = c.style.display === "block" ? "none" : "block";
  }
  return n;
}
function LM() {
  return ko`<svg
    xmlns="http://www.w3.org/2000/svg"
    width="15"
    height="25"
    viewBox="0 -3 35 35"
  >
    <path
      d="M2,29.14l9.86-16.87c1.86,3.34,4.56,7.62,3.34,11.57a7.61,7.61,0,0,1-2.61,3.68,7.78,7.78,0,0,1-5,1.61c-1.48,0-3,0-4.47,0A4.5,4.5,0,0,0,2,29.14Z"
    ></path>
    <path
      d="M12.86,10.43l5.71-10L35.12,29.14H31a13.92,13.92,0,0,1-8.44-3.54,18.23,18.23,0,0,1-3.44-4.5c-.55-.92-1.08-1.85-1.61-2.79-1.25-2.21-2.56-4.39-3.85-6.58Z"
    ></path>
  </svg>`;
}
export {
  ft as B,
  Dt as E,
  lt as F,
  ys as L,
  Ut as M,
  pd as P,
  Ob as Q,
  Ss as S,
  I as V,
  FM as a,
  OM as b,
  fn as c,
  xM as d,
  DM as e,
  yc as f,
  kM as g,
  IM as h,
  Ju as i,
  re as j,
  _i as k,
  rt as l,
  XE as m,
  De as v,
  UM as w,
  ko as x
};
